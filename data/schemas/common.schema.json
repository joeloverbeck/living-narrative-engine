{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "schema://living-narrative-engine/common.schema.json",
  "title": "Common Definitions",
  "definitions": {
    "BaseDefinition": {
      "type": "object",
      "properties": {
        "$schema": {
          "type": "string",
          "format": "uri",
          "description": "Optional. A URI reference to the schema that this document conforms to."
        },
        "id": {
          "$ref": "#/definitions/namespacedId",
          "description": "Required. Unique, namespaced ID for the definition (e.g., 'core:player', 'combat:action_attack')."
        },
        "description": {
          "type": "string",
          "description": "Required. A human-readable explanation of what this definition represents or does."
        }
      },
      "required": ["id", "description"]
    },
    "namespacedId": {
      "description": "A unique identifier string, typically namespaced using a colon (e.g., 'core:player', 'mod_combat:action_attack'). Allows alphanumeric characters, underscore, hyphen, and colon.",
      "type": "string",
      "pattern": "^[a-zA-Z0-9_:-]+$"
    },
    "nullableNamespacedId": {
      "description": "A unique identifier string, typically namespaced (like namespacedId), or null.",
      "oneOf": [
        {
          "$ref": "#/definitions/namespacedId"
        },
        {
          "type": "null"
        }
      ]
    },
    "perceptionType": {
      "description": "Standardized category identifiers for perceptible events. Uses dotted notation (category.type). Legacy snake_case types are deprecated but still supported during migration. See specs/perceptionType-consolidation.md for details.",
      "type": "string",
      "enum": [
        "communication.speech",
        "communication.thought",
        "communication.notes",
        "movement.arrival",
        "movement.departure",
        "combat.attack",
        "combat.damage",
        "combat.death",
        "combat.violence",
        "item.pickup",
        "item.drop",
        "item.transfer",
        "item.use",
        "item.examine",
        "container.open",
        "container.take",
        "container.put",
        "connection.lock",
        "connection.unlock",
        "consumption.consume",
        "state.observable_change",
        "social.gesture",
        "social.interaction",
        "social.affection",
        "physical.self_action",
        "physical.target_action",
        "intimacy.sexual",
        "intimacy.sensual",
        "performance.music",
        "performance.dance",
        "magic.spell",
        "magic.ritual",
        "error.action_failed",
        "error.system_error",
        "movement.navigation",
        "action_self_general",
        "action_target_general",
        "character_enter",
        "character_exit",
        "combat_attack",
        "combat_effect",
        "connection_lock_failed",
        "connection_locked",
        "connection_unlock_failed",
        "connection_unlocked",
        "container_open_failed",
        "container_opened",
        "damage_received",
        "dimensional_arrival",
        "dimensional_departure",
        "drink_consumed",
        "entity_died",
        "error",
        "food_consumed",
        "item_drop",
        "item_dropped",
        "item_examined",
        "item_pickup",
        "item_pickup_failed",
        "item_picked_up",
        "item_put_in_container",
        "item_put_on_nearby_surface",
        "item_read",
        "item_taken_from_container",
        "item_taken_from_nearby_surface",
        "item_transfer",
        "item_transfer_failed",
        "item_use",
        "liquid_consumed",
        "liquid_consumed_entirely",
        "notes_jotted",
        "put_in_container_failed",
        "put_on_nearby_surface_failed",
        "rest_action",
        "speech_local",
        "state_change_observable",
        "take_from_container_failed",
        "take_from_nearby_surface_failed",
        "thought_internal"
      ]
    },
    "entityReference": {
      "description": "Specifies an entity. Can be a keyword ('actor', 'target'), a direct non-empty entity ID string, or an object containing the entity ID.",
      "oneOf": [
        {
          "type": "string",
          "description": "Keyword ('actor', 'target') or direct entity ID string.",
          "minLength": 1,
          "pattern": "^\\S(.*\\S)?$"
        },
        {
          "type": "object",
          "properties": {
            "entityId": {
              "type": "string",
              "description": "The specific entity ID.",
              "minLength": 1,
              "pattern": "^\\S(.*\\S)?$"
            }
          },
          "required": ["entityId"],
          "additionalProperties": false,
          "description": "Reference via explicit entityId property."
        }
      ]
    },
    "structuredNote": {
      "type": "object",
      "description": "A structured note with categorized subject information",
      "properties": {
        "text": {
          "type": "string",
          "minLength": 1,
          "description": "The note content"
        },
        "subject": {
          "type": "string",
          "minLength": 1,
          "description": "Primary subject of the note (entity, location, concept)"
        },
        "subjectType": {
          "type": "string",
          "enum": ["entity", "event", "plan", "knowledge", "state", "other"],
          "default": "other",
          "description": "Explicit categorization of the note's subject type: entity (who/what/where), event (past occurrences), plan (future intentions), knowledge (information/theories), state (mental/emotional conditions), other"
        },
        "context": {
          "type": ["string", "null"],
          "description": "Where/how this was observed (optional)"
        },
        "timestamp": {
          "type": ["string", "null"],
          "format": "date-time",
          "description": "When the note was created"
        }
      },
      "required": ["text", "subject"],
      "additionalProperties": false
    },
    "templateString": {
      "description": "A runtime template string resolved at execution. Format: {path.to.value}",
      "type": "string",
      "pattern": "^\\{[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*\\}$",
      "examples": [
        "{context.value}",
        "{event.payload.actorId}",
        "{context.targetGrabbingReqs.handsRequired}"
      ]
    },
    "integerOrTemplate": {
      "description": "Either a literal integer or a template string that resolves to integer at runtime",
      "oneOf": [
        { "type": "integer" },
        { "$ref": "#/definitions/templateString" }
      ]
    },
    "positiveIntegerOrTemplate": {
      "description": "Either a positive integer (â‰¥1) or a template string that resolves to positive integer at runtime",
      "oneOf": [
        { "type": "integer", "minimum": 1 },
        { "$ref": "#/definitions/templateString" }
      ]
    },
    "stringOrTemplate": {
      "description": "Either a literal string or a template string",
      "oneOf": [
        {
          "type": "string",
          "minLength": 1,
          "not": { "pattern": "^\\{.*\\}$" }
        },
        { "$ref": "#/definitions/templateString" }
      ]
    },
    "booleanOrTemplate": {
      "description": "Either a literal boolean or a template string that resolves to boolean at runtime",
      "oneOf": [
        { "type": "boolean" },
        { "$ref": "#/definitions/templateString" }
      ]
    },
    "entityIdOrTemplate": {
      "description": "Either a literal entity ID (modId:identifier) or a template string",
      "oneOf": [
        {
          "type": "string",
          "pattern": "^[a-z][a-z0-9_]*:[a-z][a-z0-9_]*$"
        },
        { "$ref": "#/definitions/templateString" }
      ]
    },
    "senseCategory": {
      "type": "string",
      "enum": ["visual", "auditory", "olfactory", "tactile", "proprioceptive", "omniscient"],
      "description": "Category of sense required to perceive an event. 'omniscient' events are always delivered regardless of sensory state."
    }
  }
}
