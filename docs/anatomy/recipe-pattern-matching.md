# Recipe Pattern Matching

## Purpose and Scope

This guide documents how anatomy recipes expand pattern definitions into concrete slot entries using the V2 recipe pattern resolver. It reflects the current implementation in:

- `src/anatomy/recipePatternResolver/patternResolver.js`
- `src/anatomy/recipePatternResolver/matchers/*.js`
- `src/anatomy/recipePatternResolver/validators/*.js`
- `data/schemas/anatomy.recipe.schema.json`

Refer to `data/mods/anatomy/recipes/` for complete examples that conform to this behavior.

---

## Lifecycle Overview

1. The recipe pattern resolver (`resolveRecipePatterns`) receives a recipe and the fully processed blueprint (generated slots merged with `additionalSlots`).
2. Each pattern is validated to ensure exactly one matcher is present and, when relevant, that the blueprint supports it (for example, `matchesGroup` requires a V2 blueprint with a structure template).
3. Patterns are resolved in order. For every matched slot key the resolver copies common fields (`partType`, `preferId`, `tags`, `notTags`, `properties`) into the output slot unless a higher-precedence source already set it.
4. The resolver records hints and conflicts, including overlaps with equal specificity, so tooling can surface warnings without altering resolution order.

Implementation references: `patternResolver.js` (resolution and precedence), `patternValidator.js` (matcher validation), and `blueprintLoader.js` (merging `additionalSlots`).

### Precedence Rules

When multiple definitions target the same slot key:

1. Explicit entries in `recipe.slots` win.
2. Blueprint `additionalSlots` override remaining pattern output.
3. Among patterns, the first pattern in the array that matches the slot applies.

Pattern specificity (explicit list → property filter → wildcard → slot group) is used only to raise warnings about overlapping definitions; it does not change these precedence rules. See `validators/precedenceValidator.js` for the warning logic.

---

## Pattern Definition Summary

Recipes support one legacy matcher and three V2 matchers. Exactly one matcher must be present per pattern; validators reject any pattern with zero or multiple matcher fields.

| Matcher        | Description                                                | Example |
| -------------- | ---------------------------------------------------------- | ------- |
| `matches`      | Explicit array of slot keys (V1 compatibility).            | `{ "matches": ["leg_front_left"], "partType": "custom_leg" }` |
| `matchesGroup` | Resolves structure-template groups (`limbSet` / `appendage`). Requires blueprint schemaVersion `2.0`. | `{ "matchesGroup": "limbSet:leg", "partType": "spider_leg" }` |
| `matchesPattern` | Wildcard match against slot keys generated by the blueprint. | `{ "matchesPattern": "leg_*", "partType": "spider_leg" }` |
| `matchesAll`   | Property-based filter (`slotType`, `orientation`, `socketId`). | `{ "matchesAll": { "orientation": "*_left" }, "partType": "left_leg" }` |

Common optional fields (`preferId`, `tags`, `notTags`, `properties`) are copied verbatim into each resolved slot. `properties` is shallow-cloned; nested objects are not deep-cloned by the resolver.

---

## `matchesGroup`: Structure Template Integration

- Format: `"limbSet:{type}"` or `"appendage:{type}"` where `{type}` matches the `type` property defined in the referenced structure template.
- Prerequisites: the blueprint must declare `schemaVersion: "2.0"` and `structureTemplate`, and the template must be registered in the `anatomyStructureTemplates` registry.
- Failure modes: the resolver raises validation errors when the group does not exist or generates zero slots (unless exclusions remove them later).
- Usage tip: When a template defines multiple limb sets with the same `type`, the matcher returns all of them; combine with `matchesPattern` or `matchesAll` if you need to separate subsets.

### Example

```json
{
  "recipeId": "anatomy:giant_spider_recipe",
  "blueprintId": "anatomy:giant_spider",
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

With the `structure_arachnid_8leg` template, this fills every generated leg slot. See `data/mods/anatomy/blueprints/giant_spider.blueprint.json` and its referenced structure template for the full data.

---

## `matchesPattern`: Wildcard Slot Key Matching

- Accepts lowercase letters, digits, and underscores with optional `*` wildcards at the start, end, or between tokens (e.g., `leg_*`, `*_left`, `*tentacle*`). The schema enforces this character set.
- Patterns are matched case-sensitively against blueprint slot keys. Wildcards expand to `.*` in the generated regular expression; other regex characters are escaped automatically.
- A pattern that matches no slots is allowed but produces a validation warning if exclusions or later filters remove all matches during resolution.

---

## `matchesAll`: Property Filters

- Supported properties: `slotType`, `orientation`, and `socketId` (mapped to the slot's `socket` value). At least one property is required.
- `slotType` comparisons are exact; wildcards are rejected during validation. `orientation` and `socketId` accept `*` wildcards that are converted to regular expressions.
- Filtering operates on the blueprint's merged slot definitions, so ensure the target slots expose the relevant `orientation` or `socket` metadata before relying on these filters.

### Example

```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "*_left"
  },
  "partType": "left_leg",
  "tags": ["anatomy:part", "anatomy:scaled"]
}
```

This selects every slot whose required part type is `leg` and whose orientation ends with `_left`.

---

## Exclusions

Use the optional `exclude` object to remove slots from a pattern after matching.

- `slotGroups`: array of group references (same format as `matchesGroup`). The resolver reuses structure template lookups to remove the referenced slots.
- `properties`: key-value pairs compared directly against blueprint slot definitions (no wildcard support). Typical properties include `orientation`, `socket`, or custom metadata emitted by the slot generator.

Example: exclude a special limb set while keeping the general match.

```json
{
  "matchesGroup": "limbSet:leg",
  "partType": "normal_leg",
  "exclude": {
    "slotGroups": ["limbSet:special_leg"],
    "properties": { "orientation": "mid" }
  }
}
```

---

## Conflict Detection and Diagnostics

- The resolver gathers `_patternHints` when a pattern loses its matcher (for example, because exclusions removed every slot).
- `_patternConflicts` capture precedence situations such as explicit slot overrides or blueprint `additionalSlots` replacing a pattern result, helping audit final slot assignments.
- The precedence validator computes specificity scores (4 → explicit list, 3 → property filter, 2 → wildcard, 1 → slot group) and logs warnings when patterns with the same specificity overlap the same slots.

Enable debug-level logging on the resolver to inspect slot counts for each pattern and to surface these hints during development.

---

## Testing and Troubleshooting

- Integration coverage exists in `tests/integration/anatomy/recipePatternResolution.integration.test.js`, which exercises `matchesGroup`, `matchesPattern`, `matchesAll`, and mixed scenarios.
- Schema validation for patterns lives in `tests/unit/schemas/anatomy.recipe.schema.test.js`; extend those tests when adding new pattern capabilities.
- To run only the pattern resolution integration suite:

  ```bash
  npm run test:integration -- recipePatternResolution
  ```

- When debugging mismatches:
  - Inspect the merged blueprint slots (`bodyBlueprintFactory.createAnatomyGraph`) to confirm slot metadata exists before filtering.
  - Temporarily add explicit slot entries in the recipe to verify slot keys and confirm precedence behavior matches expectations.

---

## Minimal End-to-End Example

The following fragment mirrors the spider coverage test and demonstrates V2 features working together:

```json
{
  "recipeId": "test:spider_basic",
  "blueprintId": "test:spider",
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "leg_segment",
      "tags": ["test:spider_leg"]
    },
    {
      "matchesAll": {
        "slotType": "leg_segment",
        "orientation": "*_left"
      },
      "partType": "leg_segment",
      "tags": ["test:spider_leg", "test:left_leg_override"],
      "exclude": {
        "properties": { "socket": "venom_gland" }
      }
    }
  ]
}
```

- Pattern 1 seeds every leg slot from the structure template.
- Pattern 2 overlays left-oriented slots with additional tags while leaving any `venom_gland` socket untouched.
- Explicit slots or `additionalSlots` would still override either pattern if present in the recipe or blueprint.

This configuration aligns with the resolver expectations validated by the automated integration tests mentioned above.
