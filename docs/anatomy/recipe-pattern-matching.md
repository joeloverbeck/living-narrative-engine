# Recipe Pattern Matching

## Overview

Anatomy recipes define what body parts a creature should have by matching blueprint slots to entity parts. The pattern matching system allows you to efficiently configure multiple slots at once, which is especially powerful for creatures with many repeating limbs generated by Structure Templates.

**Schema Location**: `data/schemas/anatomy.recipe.schema.json`

**Related Guides**:
- [Blueprint V2](./blueprints-v2.md) - Structure template integration
- [Structure Templates](./structure-templates.md) - Socket generation
- [Non-Human Quickstart](./non-human-quickstart.md) - Complete workflow tutorial

## Table of Contents

- [Part 1: Pattern Matching Fundamentals](#part-1-pattern-matching-fundamentals)
- [Part 2: Pattern Reference](#part-2-pattern-reference)
- [Part 3: Best Practices](#part-3-best-practices)
- [Part 4: Common Creature Patterns](#part-4-common-creature-patterns)
- [Part 5: Migration from V1 to V2](#part-5-migration-from-v1-to-v2)
- [Part 6: Complete Examples](#part-6-complete-examples)

---

# Part 1: Pattern Matching Fundamentals

## Pattern Types Overview

The recipe system supports two pattern definition formats:

### V1 Patterns (Explicit Slot Lists)

V1 patterns use an explicit `matches` array listing slot keys:

```json
{
  "patterns": [
    {
      "matches": ["leg_1", "leg_2", "leg_3", "leg_4"],
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Characteristics**:
- Explicit and clear
- Verbose for many slots
- Requires manual updates when blueprint changes

### V2 Patterns (Enhanced Matchers)

V2 patterns use one of three advanced matchers:
- **matchesGroup**: Slot group selector
- **matchesPattern**: Wildcard pattern
- **matchesAll**: Property-based filter

```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Characteristics**:
- Concise and maintainable
- Auto-adapts to template changes
- Powerful filtering capabilities

**Important**: Each pattern must use **exactly one** of `matches` (V1), `matchesGroup`, `matchesPattern`, or `matchesAll` (V2). Using multiple or none will fail validation.

## Pattern Matching Syntax

Patterns complement individual slot definitions:

```json
{
  "recipeId": "anatomy:spider_recipe",
  "blueprintId": "anatomy:spider_common",
  "slots": {
    "abdomen": {
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"]
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Priority**: Individual `slots` take precedence over `patterns`. If a slot appears in both, the explicit slot definition wins.

## Pattern Precedence

When multiple patterns or slots could configure the same slot key, priority is:

1. **Explicit `slots` definition** (highest priority)
2. **Blueprint `additionalSlots`** (overrides patterns)
3. **First matching pattern** (patterns are processed in order)

**Note on Pattern Specificity**: The pattern resolver calculates specificity scores (explicit matches=4, matchesAll=3, matchesPattern=2, matchesGroup=1) for **warning detection only**. These scores identify potential conflicts when patterns of equal specificity overlap, but do not affect which pattern wins. The actual resolution follows first-match-wins after explicit slots and blueprint additionalSlots are checked.

### Example: Override Pattern for One Slot

```json
{
  "slots": {
    "leg_1": {
      "partType": "special_leg",
      "tags": ["anatomy:part", "anatomy:golden"]
    }
  },
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "normal_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

Result:
- `leg_1`: Uses explicit slot definition → `special_leg` with golden tag
- `leg_2`, `leg_3`, etc.: Use pattern → `normal_leg`

## Choosing the Right Pattern Type

### Pattern Type Decision Tree

```
Need to populate slots?
├─ Single unique slot → Use explicit slots
├─ Multiple slots from same limb set → Use matchesGroup
├─ Slots follow naming pattern → Use matchesPattern
├─ Need property-based filtering → Use matchesAll
└─ Complex mixed requirements → Combine multiple approaches
```

### Use matchesGroup When:

- Targeting all limbs from a structure template limb set
- Targeting all appendages of a specific type
- Template-generated slots with consistent type
- Simple, broad matching needs

**Example**: All spider legs, all dragon wings

### Use matchesPattern When:

- Matching by slot key naming convention
- Targeting slots with common prefix/suffix
- Blueprint uses consistent naming patterns
- Need flexibility without knowing exact slot structure

**Example**: All legs (`leg_*`), all left-side parts (`*_left`)

### Use matchesAll When:

- Need fine-grained filtering by multiple properties
- Slots don't follow simple naming patterns
- Orientation-specific matching
- Complex blueprints with mixed slot types

**Example**: Only left legs, specific orientations, socket ID filters

### Use Explicit slots When:

- Single unique slot
- Slot needs different configuration than pattern matches
- Overriding a pattern for one specific slot

**Example**: Unique head, tail with special properties

---

# Part 2: Pattern Reference

## matchesGroup: Slot Group Selector

The `matchesGroup` matcher targets all slots generated from a specific limb set or appendage group in the structure template.

### Syntax

**Format**: `"limbSet:{type}"` or `"appendage:{type}"`

Where `{type}` matches the `type` property from the structure template's `limbSets` or `appendages`.

### Examples

#### Matching All Legs

**Structure Template**:
```json
{
  "topology": {
    "limbSets": [
      {
        "type": "leg",
        "count": 8,
        "socketPattern": { /* ... */ }
      }
    ]
  }
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

This matches all 8 leg slots generated by the "leg" limb set.

#### Matching All Wings

**Structure Template**:
```json
{
  "limbSets": [
    {
      "type": "wing",
      "count": 2,
      "socketPattern": { /* ... */ }
    }
  ]
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "red"
        }
      }
    }
  ]
}
```

#### Matching Appendages

**Structure Template**:
```json
{
  "appendages": [
    {
      "type": "tail",
      "count": 1,
      "attachment": "posterior",
      "socketPattern": { /* ... */ }
    }
  ]
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:prehensile"]
    }
  ]
}
```

### Multiple Limb Sets

If your template has multiple limb sets with the same type, `matchesGroup` matches **all** of them:

**Structure Template**:
```json
{
  "limbSets": [
    {
      "type": "leg",
      "count": 4,  // Front legs
      "socketPattern": { /* ... */ }
    },
    {
      "type": "leg",
      "count": 4,  // Rear legs
      "socketPattern": { /* ... */ }
    }
  ]
}
```

**Recipe Pattern**:
```json
{
  "matchesGroup": "limbSet:leg"  // Matches all 8 legs from both sets
}
```

To target specific legs, use `matchesPattern` or `matchesAll` with additional filters.

## matchesPattern: Wildcard Matching

The `matchesPattern` matcher uses wildcard patterns to match slot keys by name.

### Syntax

**Format**: `"prefix*"`, `"*suffix"`, or `"*middle*"`

The `*` wildcard matches any characters (including none).

**Pattern Rules**:
- Pattern must match the slot key (not socket ID)
- Case-sensitive matching
- `*` matches zero or more characters
- Anchor pattern at start, end, or both

### Examples

#### Prefix Matching

Match all legs regardless of numbering:

```json
{
  "matchesPattern": "leg_*",
  "partType": "spider_leg"
}
```

Matches: `leg_1`, `leg_2`, `leg_left`, `leg_right_front`, etc.

#### Suffix Matching

Match all left-side parts:

```json
{
  "matchesPattern": "*_left",
  "partType": "left_sided_part"
}
```

Matches: `arm_left`, `wing_left`, `eye_left`, etc.

#### Contains Matching

Match all tentacles:

```json
{
  "matchesPattern": "*tentacle*",
  "partType": "octopus_tentacle"
}
```

Matches: `tentacle_1`, `front_tentacle_left`, `tentacle_tip_2`, etc.

#### Exact Match (No Wildcard)

```json
{
  "matchesPattern": "head",
  "partType": "dragon_head"
}
```

Matches only: `head`

### Complex Wildcard Example

**Spider with Tagged Patterns**:

```json
{
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"],
      "properties": {
        "anatomy:segmented": {
          "segments": 7
        }
      }
    },
    {
      "matchesPattern": "abdomen",
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"],
      "preferId": "anatomy:spider_abdomen_female"
    }
  ]
}
```

## matchesAll: Property-Based Filtering

The `matchesAll` matcher filters slots based on their properties. This provides fine-grained control when `matchesGroup` or `matchesPattern` are too broad.

### Syntax

**Object with optional filters**:
- `slotType`: Filter by part type requirement
- `orientation`: Filter by orientation (supports wildcards)
- `socketId`: Filter by socket ID pattern

At least one filter property is required.

### Filter: slotType

Match slots that require a specific part type:

```json
{
  "matchesAll": {
    "slotType": "leg"
  },
  "partType": "spider_leg"
}
```

Matches all slots with `requirements.partType === "leg"`.

**How It Works**:
- Checks each slot's `requirements.partType` property
- Matches only slots where `partType === "leg"`
- Exact match only (no wildcards)

**Example Slots Matched**:
```json
{
  "leg_1": {
    "socket": "leg_1",
    "requirements": {
      "partType": "limb"  // ✅ Matches if slotType is "limb"
    }
  },
  "wing_left": {
    "socket": "wing_left",
    "requirements": {
      "partType": "wing"  // ❌ No match
    }
  }
}
```

### Filter: orientation

Match slots by orientation, with wildcard support:

**Exact Match**:
```json
{
  "matchesAll": {
    "orientation": "left"
  },
  "partType": "left_arm"
}
```

Matches slots with `left` orientation.

**Wildcard Match**:
```json
{
  "matchesAll": {
    "orientation": "left_*"
  },
  "partType": "left_side_leg"
}
```

Matches: `left_front`, `left_rear`, `left_middle`, etc.

**Pattern Matching**:
- `leg_*` matches: `leg_front_left`, `leg_back_right`, `leg_middle`, etc.
- `*_left` matches: `arm_left`, `wing_left`, `leg_front_left`, etc.
- `*front*` matches: `leg_front_left`, `arm_frontal`, etc.

**Example Slots**:
```json
{
  "leg_1": {
    "orientation": "leg_front_left"  // ✅ Matches "leg_*"
  },
  "leg_2": {
    "orientation": "leg_back_right"  // ✅ Matches "leg_*"
  },
  "wing_left": {
    "orientation": "wing_left"  // ❌ No match
  }
}
```

### Filter: socketId

Match slots by socket ID pattern:

```json
{
  "matchesAll": {
    "socketId": "leg_*"
  },
  "partType": "spider_leg"
}
```

Matches slots with socket IDs like `leg_1`, `leg_2`, etc.

**Example Slots**:
```json
{
  "leg_1": {
    "socket": "leg_socket_1"  // ✅ Matches "leg_socket_*"
  },
  "leg_2": {
    "socket": "leg_socket_2"  // ✅ Matches "leg_socket_*"
  },
  "abdomen": {
    "socket": "abdomen_socket"  // ❌ No match
  }
}
```

### Combined Filters

Use multiple filters for precise matching:

```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "left_*"
  },
  "partType": "front_left_leg",
  "tags": ["anatomy:part", "anatomy:scaled"]
}
```

Matches left-side legs only. All specified filters must match (AND logic).

### Complete matchesAll Example: Dragon Recipe

```json
{
  "recipeId": "anatomy:dragon_warrior",
  "blueprintId": "anatomy:dragon_v2",
  "slots": {
    "head": {
      "partType": "dragon_head",
      "preferId": "anatomy:dragon_head_elder",
      "tags": ["anatomy:part", "anatomy:horned"]
    }
  },
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "left_*"
      },
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson",
          "pattern": "striped"
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "right_*"
      },
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson",
          "pattern": "striped"
        }
      }
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:spiked"]
    }
  ]
}
```

### Wildcard Patterns

Wildcard patterns use `*` to match zero or more characters.

| Pattern | Matches | Example Slots |
|---------|---------|---------------|
| `leg_*` | Starts with "leg_" | `leg_1`, `leg_front_left`, `leg_back_right` |
| `*_left` | Ends with "_left" | `arm_left`, `wing_left`, `leg_front_left` |
| `*front*` | Contains "front" | `leg_front_left`, `arm_frontal`, `front_claw` |
| `leg_front_*` | Starts with "leg_front_" | `leg_front_left`, `leg_front_right` |
| `*` | Matches everything | All slots (rarely useful) |

**Pattern Conversion**:

Internally, wildcards are converted to regex:
- `leg_*` → `/^leg_.*$/`
- `*_left` → `/^.*_left$/`
- `*front*` → `/^.*front.*$/`

**Escaping Special Characters**:

If your socket IDs contain regex special characters, they're automatically escaped:
- `leg_[1]` is treated as literal `leg_[1]`, not a character class
- Use `leg_*` for pattern matching, not `leg_[1-8]`

## Pattern Exclusions

Use the `exclude` property to filter out slots from a pattern match.

### Exclude Slot Groups

Exclude specific slot groups from matching:

```json
{
  "matchesPattern": "leg_*",
  "partType": "normal_leg",
  "exclude": {
    "slotGroups": ["limbSet:special_leg"]
  }
}
```

### Exclude by Properties

Exclude slots with specific properties:

```json
{
  "matchesAll": {
    "slotType": "leg"
  },
  "partType": "standard_leg",
  "exclude": {
    "properties": {
      "orientation": "mid"
    }
  }
}
```

Matches all legs except middle legs.

### Combined Exclusions

```json
{
  "matchesAll": {
    "slotType": "limb",
    "orientation": "leg_*"
  },
  "partType": "standard_leg",
  "tags": ["anatomy:part"],
  "exclude": {
    "slotGroups": ["limbSet:wing"],
    "properties": {
      "socketId": "special_*"
    }
  }
}
```

**Effect**: Matches limbs with `leg_*` orientation, excluding wings and special sockets.

## Pattern Conflicts

Patterns must be mutually exclusive within each pattern definition. You **cannot** use multiple matcher types in one pattern:

```json
// ❌ INVALID: Cannot use both matchesGroup and matchesPattern
{
  "matchesGroup": "limbSet:leg",
  "matchesPattern": "leg_*",  // ERROR: Only one matcher allowed
  "partType": "spider_leg"
}
```

```json
// ✅ VALID: Use separate patterns
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg"
    },
    {
      "matchesPattern": "tentacle_*",
      "partType": "octopus_tentacle"
    }
  ]
}
```

---

# Part 3: Best Practices

## When to Use Each Pattern Type

### Explicit slots

**Best For**:
- Single unique slots (head, tail)
- Asymmetric features (damaged wing, prosthetic limb)
- Override a pattern for specific slot
- Slots with unique properties

**Characteristics**:
- Highest priority (overrides all patterns)
- Most explicit and readable
- No ambiguity

**Example**:
```json
{
  "slots": {
    "head": {
      "partType": "dragon_head",
      "preferId": "anatomy:dragon_head_elder",
      "tags": ["anatomy:part", "anatomy:horned"]
    }
  }
}
```

**When NOT to Use**:
- Many repeating limbs (legs, tentacles)
- Template-generated slots
- High maintenance overhead

### matchesGroup

**Best For**:
- Template-generated limb sets
- All slots from one appendage type
- Simple, broad matching

**Characteristics**:
- Works with Structure Templates
- Clean and concise
- Auto-adapts to template changes

**Example**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**When NOT to Use**:
- Non-template blueprints
- Need to differentiate within limb set
- Requires property-based filtering

### matchesPattern

**Best For**:
- Slots with consistent naming
- Wildcard matching on slot keys
- Blueprint-agnostic patterns

**Characteristics**:
- Flexible wildcard patterns
- Works with any blueprint structure
- Pattern-based, not template-dependent

**Example**:
```json
{
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "quadruped_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**When NOT to Use**:
- Inconsistent slot naming
- Need type or orientation filtering
- Template groups available

### matchesAll

**Best For**:
- Fine-grained property filtering
- Combining multiple criteria
- Orientation or socket-based selection
- Complex filtering requirements

**Characteristics**:
- Most powerful and flexible
- Supports wildcards on orientation/socketId
- Multiple filters with AND logic

**Example**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_left"
      },
      "partType": "left_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**When NOT to Use**:
- Simple cases (use matchesGroup)
- Performance-critical situations (though impact is minimal)
- When simpler patterns suffice

## Complexity Levels

### Level 1: Simple (Explicit Slots Only)

**Use Case**: 1-5 unique slots, no patterns needed.

```json
{
  "slots": {
    "head": { "partType": "human_head", "tags": ["anatomy:part"] },
    "torso": { "partType": "human_torso", "tags": ["anatomy:part"] }
  },
  "patterns": []
}
```

**Pros**: Crystal clear, no ambiguity
**Cons**: Verbose for many slots

### Level 2: Moderate (Single Pattern Type)

**Use Case**: Homogeneous limb sets, consistent structure.

```json
{
  "slots": {},
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    },
    {
      "matchesGroup": "appendage:abdomen",
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Pros**: Maintainable, scales well
**Cons**: Less control over individual slots

### Level 3: Advanced (Multiple Pattern Types)

**Use Case**: Complex creatures with varied limb requirements.

```json
{
  "slots": {
    "head": {
      "partType": "dragon_head_elder",
      "tags": ["anatomy:part", "anatomy:horned"]
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_front"
      },
      "partType": "front_leg",
      "tags": ["anatomy:part"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_rear"
      },
      "partType": "rear_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Pros**: Maximum flexibility and control
**Cons**: Higher complexity, more testing needed

### Level 4: Expert (Patterns + Exclusions)

**Use Case**: Complex filtering with exceptions.

```json
{
  "slots": {
    "leg_1": {
      "partType": "golden_leg",
      "tags": ["anatomy:part", "anatomy:golden"]
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "normal_leg",
      "tags": ["anatomy:part"],
      "exclude": {
        "slotGroups": ["limbSet:special_leg"]
      }
    }
  ]
}
```

**Pros**: Surgical precision, handles edge cases
**Cons**: Most complex, hardest to debug

## Performance Considerations

### Pattern Performance (Best to Worst)

1. **Explicit slots**: O(1) lookup
2. **matchesGroup**: O(n) where n = slots in limb set
3. **matchesPattern**: O(n) where n = all blueprint slots
4. **matchesAll**: O(n × m) where m = number of filter criteria

### Performance Tips

**Optimize For**:
- Use matchesGroup for template-generated slots (fastest pattern type)
- Combine filters in single matchesAll (vs multiple patterns)
- Cache-friendly: patterns evaluated once during blueprint processing

**Avoid**:
- Excessive pattern count (>10 patterns)
- Overlapping patterns (causes unnecessary re-evaluation)
- Too-broad wildcards (match more slots than needed)

### Real-World Performance

For typical creatures (10-50 slots):
- All pattern types: <2ms processing time
- Negligible impact on load times
- No runtime performance cost (evaluated once)

**Conclusion**: Choose patterns for maintainability, not performance.

### Filter Efficiency

**Most Efficient** (exact match):
```json
{ "slotType": "leg" }
```

**Moderately Efficient** (single wildcard):
```json
{ "orientation": "*_front" }
```

**Less Efficient** (multiple wildcards):
```json
{ "socketId": "*_combat_*" }
```

**Recommendation**: Use the most specific filter possible. Combine `slotType` (exact) with wildcard filters for best performance.

### Pattern Order Optimization

Patterns are evaluated in order. Put most specific patterns first:

```json
{
  "patterns": [
    {
      "matches": ["special_limb"],
      "partType": "unique_part"
    },
    {
      "matchesAll": {
        "slotType": "limb",
        "socketId": "combat_*"
      },
      "partType": "combat_limb"
    },
    {
      "matchesGroup": "limbSet:limb",
      "partType": "standard_limb"
    }
  ]
}
```

Order: Explicit slots → Property filters → Group matches → Pattern wildcards

## Maintainability Guidelines

### Rule 1: Prefer Patterns Over Explicit Slots

```json
// ❌ BAD: Repetitive explicit slots
"slots": {
  "leg_1": { "partType": "leg" },
  "leg_2": { "partType": "leg" },
  "leg_3": { "partType": "leg" },
  "leg_4": { "partType": "leg" }
}

// ✅ GOOD: Single pattern
"patterns": [
  {
    "matchesPattern": "leg_*",
    "partType": "leg"
  }
]
```

### Rule 2: Use Most Specific Pattern That Works

```json
// ❌ BAD: Overly broad
"matchesPattern": "*"

// ✅ BETTER: More specific
"matchesPattern": "leg_*"

// ✅ BEST: Most specific (if applicable)
"matchesGroup": "limbSet:leg"
```

### Rule 3: Document Complex Patterns

```json
{
  "recipeId": "anatomy:spider_complex",
  "description": "Spider with golden front legs (1-2) and standard rear legs (3-8). Uses explicit slots for special variants.",
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg"
    }
  ]
}
```

### Rule 4: Keep Patterns Mutually Exclusive

```json
// ❌ BAD: Overlapping patterns
"patterns": [
  {
    "matchesPattern": "leg_*",
    "partType": "normal_leg"
  },
  {
    "matchesPattern": "leg_front_*",
    "partType": "front_leg"  // Overlaps with above
  }
]

// ✅ GOOD: Use specificity or exclusions
"patterns": [
  {
    "matchesPattern": "leg_front_*",
    "partType": "front_leg"  // More specific, evaluated first
  },
  {
    "matchesPattern": "leg_*",
    "partType": "normal_leg",
    "exclude": {
      "properties": {
        "orientation": "leg_front_*"
      }
    }
  }
]
```

### Rule 5: Test Pattern Changes

```bash
# Always test after modifying patterns
1. Create test entity
2. Verify slot population
3. Check part properties
4. Validate anatomy visualization
```

### Rule 6: Group Related Patterns

Keep similar patterns together for readability:

```json
"patterns": [
  // All leg patterns
  {
    "matchesAll": { "slotType": "leg", "orientation": "left_*" },
    "partType": "left_leg"
  },
  {
    "matchesAll": { "slotType": "leg", "orientation": "right_*" },
    "partType": "right_leg"
  },
  // All wing patterns
  {
    "matchesGroup": "limbSet:wing",
    "partType": "dragon_wing"
  }
]
```

## Anti-Patterns to Avoid

### Anti-Pattern 1: Overlapping Patterns Without Priority

```json
// ❌ BAD: Which pattern wins for leg_front_left?
"patterns": [
  {
    "matchesPattern": "leg_*",
    "partType": "normal_leg"
  },
  {
    "matchesPattern": "*_left",
    "partType": "left_leg"
  }
]
```

**Fix**: Use property-based filtering or explicit slots.

### Anti-Pattern 2: Too Many Explicit Slots

```json
// ❌ BAD: Verbose and error-prone
"slots": {
  "tentacle_1": { "partType": "tentacle" },
  "tentacle_2": { "partType": "tentacle" },
  // ... 6 more
}
```

**Fix**: Use matchesGroup or matchesPattern.

### Anti-Pattern 3: Wildcard Everything

```json
// ❌ BAD: Matches way too much
"matchesPattern": "*"
```

**Fix**: Be specific with patterns.

### Anti-Pattern 4: Ignoring Structure Templates

```json
// ❌ BAD: Manual pattern when template available
"matchesPattern": "leg_1|leg_2|leg_3|leg_4|leg_5|leg_6|leg_7|leg_8"
```

**Fix**: Use matchesGroup: "limbSet:leg"

### Anti-Pattern 5: Property Filters When Not Needed

```json
// ❌ OVERCOMPLICATED: matchesAll not needed
"matchesAll": {
  "slotType": "leg"
}

// ✅ SIMPLER: Use matchesGroup
"matchesGroup": "limbSet:leg"
```

**Fix**: Use simplest pattern that works.

### Anti-Pattern 6: Over-Specifying Filters

❌ **Wrong**:
```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "leg_front_left"
  }
}
```

✅ **Right**:
```json
{
  "matches": ["leg_front_left"]
}
```

**Reason**: Use explicit slots for single specific slots. Property filters are for matching multiple slots.

### Anti-Pattern 7: Forgetting Wildcard Patterns

❌ **Wrong**:
```json
{
  "matchesAll": {
    "orientation": "front"
  }
}
```

✅ **Right**:
```json
{
  "matchesAll": {
    "orientation": "*_front"
  }
}
```

**Reason**: Orientation is typically "leg_front_left", not just "front". Use wildcards to match the full value.

## Testing Strategies

### Unit Testing Patterns

```javascript
describe('Spider Recipe Pattern', () => {
  it('should populate all 8 leg slots', () => {
    const entity = createEntity('spider', recipe);
    expect(entity.slots).toHaveLength(8);
    expect(entity.slots.every(s => s.partType === 'spider_leg')).toBe(true);
  });
});
```

### Integration Testing

```javascript
describe('Dragon Recipe Integration', () => {
  it('should correctly differentiate wings from legs', () => {
    const entity = createEntity('dragon', recipe);
    const wings = entity.slots.filter(s => s.partType === 'dragon_wing');
    const legs = entity.slots.filter(s => s.partType === 'dragon_leg');

    expect(wings).toHaveLength(2);
    expect(legs).toHaveLength(4);
  });
});
```

### Manual Testing Checklist

- [ ] All slots populated (no empty slots)
- [ ] Correct part types in each slot
- [ ] Properties applied correctly
- [ ] No unexpected parts
- [ ] Anatomy visualization looks correct
- [ ] Recipe validates against schema

### Validation Checklist

1. **Blueprint generates expected slots**
   - Check structure template count/orientation
   - Verify socket naming matches your filters

2. **Filters match intended slots**
   - Test with different slot configurations
   - Verify exclude lists work correctly

3. **Properties are valid**
   - All referenced components/tags exist
   - Property schemas validate

4. **No conflicts between patterns**
   - Each slot matched by exactly one pattern
   - Or intentionally multiple patterns (later wins)

## Debugging Techniques

### Technique 1: Temporary Explicit Slots

```json
{
  "slots": {
    // Add explicit slots to see what pattern SHOULD match
    "leg_1": { "partType": "debug_leg" }
  },
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "spider_leg"
    }
  ]
}
```

**Purpose**: Verify slot keys and structure.

### Technique 2: Pattern Elimination

```json
{
  "patterns": [
    // Comment out patterns one by one
    // {
    //   "matchesGroup": "limbSet:leg",
    //   "partType": "spider_leg"
    // },
    {
      "matchesGroup": "appendage:abdomen",
      "partType": "spider_abdomen"
    }
  ]
}
```

**Purpose**: Isolate which pattern is causing issues.

### Technique 3: Enable Debug Logging

The RecipePatternResolver includes built-in debug logging that shows pattern resolution details. Debug messages include:
- Pattern validation progress
- Number of slots matched by each pattern type (e.g., `matchesGroup 'limbSet:leg' resolved to 4 slots`)
- Exclusion filtering results

To see these messages, ensure your logger is configured to show debug-level output.

**Purpose**: See pattern resolution progress and matched slot counts.

### Technique 4: Schema Validation

```bash
# Validate recipe against schema
npx ajv validate -s data/schemas/anatomy.recipe.schema.json -d data/mods/*/recipes/*.recipe.json
```

**Purpose**: Catch structural issues early.

### Debugging Common Issues

**Validation Strategy**: Test patterns against the actual implementation to ensure matches work correctly:

1. **Verify Slot Generation**: Check that structure template generates expected slot IDs
2. **Test Filter Patterns**: Use test fixtures to validate `matchesAll` filters
3. **Schema Validation**: Ensure all recipe patterns pass schema validation

**Common Debugging Steps**:
1. Review the generated slot structure from your blueprint
2. Verify wildcard patterns match the actual slot naming convention
3. Check that `slotType`, `orientation`, and `socketId` values align with structure template output
4. Use integration tests to validate recipe pattern resolution

Common issues:
- **No matches**: Check wildcard syntax (e.g., `*_front` not `_front`), verify slot names match structure template output
- **Wrong slots matched**: Review filter specificity - add more conditions to `matchesAll` to narrow matches
- **Missing slots**: Ensure structure template `count` and `arrangement` generate expected slots

---

# Part 4: Common Creature Patterns

## Understanding Structure Template Properties

Before diving into patterns, it's important to understand two key properties that work together in structure templates:

### `arrangement` (Spatial Layout)
Defines how limbs are spatially positioned on the body:
- **`bilateral`**: Mirrored left/right pairs (arms, legs, wings)
- **`radial`**: Evenly distributed around a center point (spider legs, octopus tentacles)
- **`quadrupedal`**: Four-legged arrangement with front/rear differentiation
- **`linear`**: Sequential arrangement along a line (spine segments)
- **`custom`**: User-defined positioning (hybrid creatures, unique anatomies)

### `orientationScheme` (Orientation Computation)
Defines how orientation values are computed for slot IDs:
- **`bilateral`**: Generates `left`/`right` orientations for paired limbs
- **`indexed`**: Generates numeric indices (e.g., `tentacle_1`, `tentacle_2`, ..., `tentacle_8`)
- **`radial`**: Generates compass-like orientations for radial arrangements (e.g., for 8 items: `anterior`, `anterior_right`, `right`, `posterior_right`, `posterior`, `posterior_left`, `left`, `anterior_left`)
- **`custom`**: User-defined orientation values from explicit positions array

### Typical Combinations

| Creature Type | arrangement | orientationScheme | Result |
|--------------|-------------|-------------------|---------|
| Human/Humanoid | `bilateral` | `bilateral` | `arm_left`, `arm_right` |
| Spider/Octopus | `radial` | `indexed` | `leg_1`, `leg_2`, ..., `leg_8` |
| Quadruped | `quadrupedal` | `bilateral` | `leg_front_left`, `leg_rear_right` |
| Hybrid/Custom | `custom` | `indexed` | Custom orientation values |

**Important**: The examples in this guide use the validated combinations found in actual structure template files. Always refer to the schema at `data/schemas/anatomy.structure-template.schema.json` for the definitive list of valid values.

## Pattern Categories Decision Tree

```
What anatomy are you creating?
├─ Radially symmetric (spider, octopus)
│  ├─ All identical → Use matchesGroup on limbSet
│  └─ Some specialized → Use matchesAll with socketId patterns
│
├─ Quadrupedal (horse, dog, cat)
│  ├─ Front/rear different → Use matchesAll with orientation: "*_front" / "*_rear"
│  └─ All legs identical → Use matchesGroup on limbSet
│
├─ Flying (dragon, pegasus)
│  ├─ Wings separate → Use matchesGroup for wings
│  ├─ Legs differentiated → Use matchesAll with orientation
│  └─ Unique parts → Use explicit slots
│
├─ Hybrid (centaur, drider)
│  ├─ Human/animal parts → Use matchesAll with orientation filters
│  ├─ Upper/lower body split → Use orientation: "arm_*" vs "leg_*"
│  └─ Merged features → Combine multiple pattern types
│
└─ Unique creature
   └─ Start with structure template → Add patterns by complexity level
```

## Radial Symmetry Creatures

### Eight-Legged Spider

**Use Case**: Arachnids, mechanical walkers, alien creatures

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 8,
        "arrangement": "radial",
        "orientationScheme": "indexed",
        "requirements": {
          "partType": "spider_leg"
        }
      }
    ]
  }
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"],
      "properties": {
        "anatomy:segmented": {
          "segmentCount": 7,
          "flexibility": "high"
        }
      }
    }
  ]
}
```

**Why This Works**:
- `matchesGroup` targets all 8 legs generated by structure template
- Single pattern definition scales automatically with count changes
- Radial orientation scheme ensures even spacing

**Recommended Approach**:
1. Use `limbSets` with `radial` orientation for legs
2. Use `matchesGroup` for uniform legs
3. Use `matchesAll` with `socketId` for specialized legs (if needed)
4. Add appendages for unique parts (pedipalps, tail)

**Example Structure**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 8,
        "orientationScheme": "radial"
      }
    ],
    "appendages": [
      { "id": "cephalothorax" },
      { "id": "abdomen" },
      { "id": "pedipalp_left" },
      { "id": "pedipalp_right" }
    ]
  }
}
```

### Octopus/Tentacled Creatures

**Use Case**: Cephalopods, tentacle monsters, hydras

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "tentacle",
        "count": 8,
        "arrangement": "radial",
        "orientationScheme": "indexed",
        "requirements": {
          "partType": "tentacle"
        }
      }
    ],
    "appendages": [
      {
        "id": "head"
      }
    ]
  }
}
```

**Recipe Pattern - All Identical**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:tentacle",
      "partType": "octopus_tentacle",
      "tags": ["anatomy:part", "anatomy:prehensile"]
    }
  ]
}
```

**Why**: Homogeneous tentacle set from template.

**Recipe Pattern - Specialized Tentacles**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "tentacle",
        "socketId": "tentacle_[1-4]"
      },
      "partType": "feeding_tentacle",
      "tags": ["anatomy:part", "anatomy:prehensile"],
      "properties": {
        "anatomy:prehensile": {
          "gripStrength": "strong",
          "suckerCount": 200
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "tentacle",
        "socketId": "tentacle_[5-8]"
      },
      "partType": "locomotion_tentacle",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "flexibility": "high",
          "strength": "moderate"
        }
      }
    }
  ]
}
```

**Advanced Pattern**: Different tentacle types using socketId patterns

## Quadrupedal Creatures

### Standard Quadruped

**Use Case**: Horses, dogs, cats, most four-legged animals

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 4,
        "orientationScheme": "quadrupedal",
        "requirements": {
          "partType": "leg"
        }
      }
    ],
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern with Front/Rear Differentiation**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_front"
      },
      "partType": "front_leg",
      "tags": ["anatomy:part", "anatomy:clawed"],
      "properties": {
        "anatomy:clawed": {
          "clawCount": 4,
          "retractable": true
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_rear"
      },
      "partType": "rear_leg",
      "tags": ["anatomy:part", "anatomy:powerful"],
      "properties": {
        "anatomy:powerful": {
          "strength": "high",
          "jumpPower": "exceptional"
        }
      }
    }
  ]
}
```

**Why Orientation Filters Work**:
- `*_front` matches `leg_front_left` and `leg_front_right`
- `*_rear` matches `leg_rear_left` and `leg_rear_right`
- Enables different anatomy for front vs rear legs

## Flying Creatures

### Dragon (Wings + Quadrupedal)

**Use Case**: Dragons, wyverns, griffins, pegasus

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 4,
        "orientationScheme": "quadrupedal",
        "requirements": {
          "partType": "leg"
        }
      },
      {
        "id": "wing",
        "count": 2,
        "orientationScheme": "bilateral",
        "requirements": {
          "partType": "wing"
        }
      }
    ],
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern - Recommended Approach**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "dragon_leg"
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing"
    }
  ]
}
```

**Why**: Clear separation between limb types.

**Recipe Pattern - Advanced Differentiation**:
```json
{
  "patterns": [
    {
      "matches": ["head"],
      "partType": "dragon_head",
      "tags": ["anatomy:part", "anatomy:fire_breathing"]
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "scaled_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_front"
      },
      "partType": "dragon_front_leg",
      "tags": ["anatomy:part", "anatomy:clawed"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_rear"
      },
      "partType": "dragon_rear_leg",
      "tags": ["anatomy:part", "anatomy:powerful"]
    },
    {
      "matchesPattern": "tail*",
      "partType": "spiked_tail",
      "tags": ["anatomy:part", "anatomy:weaponized"]
    }
  ]
}
```

**Pattern Strategy**:
- Explicit slots for unique parts (head)
- `matchesGroup` for symmetric pairs (wings)
- `matchesAll` for differentiated sets (front/rear legs)
- `matchesPattern` for wildcards (tail variants)

### Avians (Birds, Winged Creatures)

**Recommended Approach**:
1. Use bilateral limb sets for wings
2. Use explicit slots or bilateral for legs (usually 2)
3. Differentiate flight wings from display wings if needed

**Example Structure**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "wing",
        "count": 2,
        "orientationScheme": "bilateral",
        "requirements": {
          "partType": "flight_wing"
        }
      },
      {
        "id": "leg",
        "count": 2,
        "orientationScheme": "bilateral",
        "requirements": {
          "partType": "talon"
        }
      }
    ]
  }
}
```

## Hybrid Creatures

### Centaur (Human Upper + Horse Lower)

**Use Case**: Centaurs, merfolk, lamia, driders

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "limb",
        "count": 6,
        "arrangement": "custom",
        "orientationScheme": "indexed",
        "requirements": {
          "partType": "limb"
        }
      }
    ],
    "appendages": [
      { "id": "head" },
      { "id": "tail" }
    ]
  }
}
```

**Recipe Pattern with Orientation-Based Separation**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "arm_*"
      },
      "partType": "human_arm",
      "tags": ["anatomy:part", "anatomy:dexterous"],
      "properties": {
        "anatomy:dexterous": {
          "fingerCount": 5,
          "thumbOpposable": true
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "leg_*"
      },
      "partType": "horse_leg",
      "tags": ["anatomy:part", "anatomy:hooved"],
      "properties": {
        "anatomy:hooved": {
          "hoofType": "solid",
          "hoofColor": "black"
        }
      }
    },
    {
      "matchesGroup": "appendage:head",
      "partType": "human_head",
      "tags": ["anatomy:part"]
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "horse_tail",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Why This Pattern Works**:
- Single limb set with mixed orientations
- `orientation: "arm_*"` filters human arms from horse legs
- Properties make each limb type functionally distinct

**Recommended Pattern**: matchesAll or matchesPattern

```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "arm_*"
      },
      "partType": "human_arm"
    },
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "leg_*"
      },
      "partType": "horse_leg"
    }
  ]
}
```

**Why**: Need to differentiate arms from legs in hybrid anatomy.

## Best Practices by Creature Type

### Spiders (8 Radial Legs)

**Recommended**: matchesGroup

```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

**Why**: Structure template generates all 8 legs consistently.

### Dragons (Wings + Legs)

**Recommended**: matchesGroup for each limb set

```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "dragon_leg"
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing"
    }
  ]
}
```

**Why**: Clear separation between limb types.

### Octopi (8 Tentacles)

**Recommended**: matchesGroup

```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:tentacle",
      "partType": "octopus_tentacle",
      "tags": ["anatomy:part", "anatomy:prehensile"]
    }
  ]
}
```

**Why**: Homogeneous tentacle set from template.

### Humanoids (Complex Asymmetry)

**Recommended**: Explicit slots

```json
{
  "slots": {
    "left_arm": { "partType": "human_arm", "tags": ["anatomy:part"] },
    "right_arm": { "partType": "human_arm", "tags": ["anatomy:part"] },
    "left_leg": { "partType": "human_leg", "tags": ["anatomy:part"] },
    "right_leg": { "partType": "human_leg", "tags": ["anatomy:part"] }
  }
}
```

**Why**: Humanoids often have unique per-limb requirements.

### Serpentine (Snakes, Worms)

**Recommended Approach**:
1. Use appendages for head/tail only
2. Body segments as properties rather than slots
3. No limb sets needed

**Example Structure**:
```json
{
  "structureTemplate": {
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "appendage:head",
      "partType": "snake_head",
      "tags": ["anatomy:part", "anatomy:venomous"],
      "properties": {
        "anatomy:venomous": {
          "venomType": "hemotoxic",
          "potency": "high"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "segmentCount": 200,
    "flexibility": "extreme",
    "scales": "overlapping"
  }
}
```

---

# Part 5: Migration from V1 to V2

## Why Migrate to V2?

### V1 Limitations

- **Verbose**: Must list every slot key explicitly
- **Error-Prone**: Easy to miss slots or make typos
- **Hard to Maintain**: Changes to blueprint require recipe updates
- **Not Scalable**: Cumbersome for creatures with many limbs

### V2 Benefits

- **Concise**: Match multiple slots with single patterns
- **Maintainable**: Patterns adapt to blueprint changes
- **Powerful**: Fine-grained filtering with `matchesAll`
- **Template-Aware**: Works seamlessly with Structure Templates

## Pattern Type Comparison

| Feature | V1 (matches) | V2 (matchesGroup) | V2 (matchesPattern) | V2 (matchesAll) |
|---------|--------------|-------------------|---------------------|-----------------|
| **Syntax** | Explicit slot array | Group reference | Wildcard pattern | Property filters |
| **Verbosity** | High | Low | Low | Low |
| **Flexibility** | None | Low | Medium | High |
| **Template Integration** | Manual | Automatic | Manual | Manual |
| **Best For** | Simple creatures | Template-generated slots | Named patterns | Fine-grained control |

## Migration Strategies

### Strategy 1: Direct Replacement

Best for: Simple patterns with all slots from one limb set.

**Before (V1)**:
```json
{
  "patterns": [
    {
      "matches": ["leg_1", "leg_2", "leg_3", "leg_4", "leg_5", "leg_6", "leg_7", "leg_8"],
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

**After (V2 - matchesGroup)**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

**Savings**: 8 explicit slots → 1 pattern line

### Strategy 2: Wildcard Conversion

Best for: Patterns following naming conventions.

**Before (V1)**:
```json
{
  "patterns": [
    {
      "matches": ["leg_front_left", "leg_front_right", "leg_back_left", "leg_back_right"],
      "partType": "quadruped_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**After (V2 - matchesPattern)**:
```json
{
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "quadruped_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Benefit**: Pattern adapts automatically if blueprint adds more legs.

### Strategy 3: Property-Based Filtering

Best for: Complex filtering requirements.

**Before (V1)**:
```json
{
  "patterns": [
    {
      "matches": ["leg_front_left", "leg_back_left"],
      "partType": "left_leg",
      "tags": ["anatomy:part"]
    },
    {
      "matches": ["leg_front_right", "leg_back_right"],
      "partType": "right_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**After (V2 - matchesAll)**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_left"
      },
      "partType": "left_leg",
      "tags": ["anatomy:part"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_right"
      },
      "partType": "right_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Benefit**: More maintainable, clearer intent.

## Step-by-Step Migration Process

### Step 1: Analyze Your V1 Recipe

Identify patterns in your explicit slot lists:

```json
{
  "patterns": [
    {
      "matches": [
        "leg_1", "leg_2", "leg_3", "leg_4",
        "leg_5", "leg_6", "leg_7", "leg_8"
      ],
      "partType": "spider_leg"
    },
    {
      "matches": ["posterior_torso"],
      "partType": "spider_abdomen"
    }
  ]
}
```

**Analysis**:
- Pattern 1: 8 legs → likely from `limbSet:leg`
- Pattern 2: 1 posterior_torso → likely from `appendage:torso`

### Step 2: Choose V2 Pattern Type

Decision matrix:

```
Are slots from structure template limb set/appendage?
├─ YES → Use matchesGroup
└─ NO → Does naming follow consistent pattern?
    ├─ YES → Use matchesPattern
    └─ NO → Need property filtering?
        ├─ YES → Use matchesAll
        └─ NO → Keep explicit slots
```

### Step 3: Convert Patterns

**Conversion Example**:

```json
// V1 Original
{
  "patterns": [
    {
      "matches": ["leg_1", "leg_2", "leg_3", "leg_4", "leg_5", "leg_6", "leg_7", "leg_8"],
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}

// V2 Converted
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

### Step 4: Test Migration

1. **Backup original recipe**
2. **Apply V2 pattern**
3. **Create test entity**
4. **Verify all slots populated correctly**
5. **Check for missing/extra parts**

### Step 5: Handle Edge Cases

If test reveals issues:
- Slots not matched → Add explicit `slots` for exceptions
- Wrong parts → Refine pattern specificity
- Extra matches → Add exclusions

## Common Migration Patterns

These examples show the most common migration scenarios. Note that these are canonical examples - you'll see complete, detailed examples in Part 6.

### Simple Pattern Migration

**V1**:
```json
{
  "patterns": [
    {
      "matches": ["leg_1", "leg_2", "leg_3", "leg_4", "leg_5", "leg_6", "leg_7", "leg_8"],
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

**V2**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

**Line Reduction**: ~50% fewer lines

### Multi-Limb Pattern Migration

**V1**:
```json
{
  "patterns": [
    {
      "matches": ["leg_left_front", "leg_right_front", "leg_left_rear", "leg_right_rear"],
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"]
    },
    {
      "matches": ["wing_left", "wing_right"],
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    }
  ]
}
```

**V2**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"]
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    }
  ]
}
```

**Benefit**: More maintainable, adapts to blueprint changes.

### Asymmetric Pattern Migration

**Scenario**: Creature with unique left/right differences.

**V1**:
```json
{
  "patterns": [
    {
      "matches": ["arm_left"],
      "partType": "mechanical_arm",
      "tags": ["anatomy:part", "anatomy:cybernetic"]
    },
    {
      "matches": ["arm_right"],
      "partType": "organic_arm",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**V2 Option 1 (explicit slots - recommended for asymmetry)**:
```json
{
  "slots": {
    "arm_left": {
      "partType": "mechanical_arm",
      "tags": ["anatomy:part", "anatomy:cybernetic"]
    },
    "arm_right": {
      "partType": "organic_arm",
      "tags": ["anatomy:part"]
    }
  }
}
```

**V2 Option 2 (property filtering)**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "arm",
        "orientation": "left"
      },
      "partType": "mechanical_arm",
      "tags": ["anatomy:part", "anatomy:cybernetic"]
    },
    {
      "matchesAll": {
        "slotType": "arm",
        "orientation": "right"
      },
      "partType": "organic_arm",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Recommendation**: Use explicit `slots` for unique asymmetric cases.

## Hybrid Approach: Patterns + Explicit Slots

Sometimes the best approach combines V2 patterns with explicit slots for exceptions.

**Example: Spider with Golden Front Legs**

```json
{
  "recipeId": "anatomy:spider_golden",
  "blueprintId": "anatomy:giant_spider",
  "slots": {
    "leg_1": {
      "partType": "spider_leg_golden",
      "preferId": "anatomy:spider_leg_golden_front",
      "tags": ["anatomy:part", "anatomy:golden", "anatomy:segmented"]
    },
    "leg_2": {
      "partType": "spider_leg_golden",
      "preferId": "anatomy:spider_leg_golden_front",
      "tags": ["anatomy:part", "anatomy:golden", "anatomy:segmented"]
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

**How It Works**:
- Explicit `slots` take priority → `leg_1`, `leg_2` get golden legs
- Pattern matches remaining → `leg_3` through `leg_8` get normal legs

## When NOT to Migrate

Keep V1 patterns when:

1. **Very few slots** (1-2 slots)
   ```json
   {
     "matches": ["head", "tail"]  // Simple enough
   }
   ```

2. **No clear pattern** in slot naming
   ```json
   {
     "matches": ["primary_processor", "secondary_processor", "backup_unit"]
   }
   ```

3. **Highly custom anatomy** not using structure templates
   ```json
   {
     "matches": ["main_body", "left_appendage_alpha", "right_sensor_array"]
   }
   ```

## Migration Checklist

### Pre-Migration

- [ ] Backup original recipe file
- [ ] Understand blueprint structure (V1 or V2)
- [ ] Identify structure template (if V2 blueprint)
- [ ] Document slot naming patterns
- [ ] List any unique/asymmetric slots

### During Migration

- [ ] Choose appropriate V2 pattern type
- [ ] Convert each V1 pattern
- [ ] Handle exceptions with explicit slots
- [ ] Add exclusions if needed
- [ ] Preserve all component properties

### Post-Migration

- [ ] Validate recipe against schema
- [ ] Create test entity instance
- [ ] Verify all slots populated correctly
- [ ] Check part properties match expectations
- [ ] Test anatomy visualization
- [ ] Update documentation references

## Troubleshooting Migration Issues

### Pattern Doesn't Match Any Slots

**Cause**: Pattern doesn't align with actual slot structure.

**Solution**:
1. Inspect blueprint slot keys with test entity
2. Verify `matchesGroup` references exist in structure template
3. Check wildcard patterns match slot naming
4. Ensure property filters match slot properties

### Pattern Matches Wrong Slots

**Cause**: Pattern too broad or filter properties incorrect.

**Solution**:
1. Use more specific pattern type (`matchesAll` vs `matchesPattern`)
2. Add additional filters to narrow matches
3. Use exclusions to filter out unwanted matches
4. Consider explicit slots for edge cases

### Some Slots Not Populated

**Cause**: Pattern doesn't cover all slots.

**Solution**:
1. Check for typos in pattern syntax
2. Verify all required slots have matching patterns
3. Add additional patterns for uncovered slots
4. Use wildcard patterns for flexibility

### Migration Breaks Existing Functionality

**Cause**: Subtle differences in slot matching.

**Solution**:
1. Revert to V1 pattern temporarily
2. Compare matched slots between V1 and V2
3. Adjust V2 pattern to match V1 behavior exactly
4. Test incrementally (one pattern at a time)

## Performance Comparison

V2 patterns have negligible performance impact:

| Recipe Type | V1 Processing | V2 Processing | Difference |
|-------------|---------------|---------------|------------|
| Small (1-10 slots) | <1ms | <1ms | None |
| Medium (10-50 slots) | 1-2ms | 1-2ms | None |
| Large (50-100 slots) | 2-5ms | 2-5ms | None |

**Conclusion**: V2 patterns are equally performant while being more maintainable.

## Best Migration Practices

### 1. Migrate Incrementally

```bash
# Migrate one recipe at a time
1. Choose simplest recipe first
2. Test thoroughly
3. Apply learnings to next recipe
4. Build confidence before complex recipes
```

### 2. Keep Backup Files

```bash
# Version your recipes
spider_common.recipe.json.v1.backup
spider_common.recipe.json
```

### 3. Document Migration Decisions

```json
{
  "recipeId": "anatomy:spider_v2",
  "description": "Migrated from V1 explicit matches to matchesGroup patterns. Front legs (1-2) remain explicit for golden variant support."
}
```

### 4. Test with Multiple Entities

```bash
# Create test instances
test_spider_1 (basic)
test_spider_2 (variant)
test_spider_3 (edge case)
```

### 5. Update Related Documentation

- Recipe documentation files
- Mod guides
- Species guides
- Architecture diagrams

---

# Part 6: Complete Examples

This section provides one canonical version of each common creature pattern, consolidating all examples from the previous documents.

## Example 1: Spider (8 Radial Legs)

Complete recipe for an eight-legged spider with radial symmetry.

**Structure Template** (`anatomy:spider_template`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.structure-template.schema.json",
  "structureTemplateId": "anatomy:spider_template",
  "topology": {
    "limbSets": [
      {
        "type": "leg",
        "count": 8,
        "socketPattern": {
          "idTemplate": "leg_{{index}}",
          "orientationScheme": "indexed",
          "attachment": "cephalothorax"
        },
        "requirements": {
          "partType": "spider_leg"
        }
      }
    ],
    "appendages": [
      {
        "type": "cephalothorax",
        "socketPattern": {
          "idTemplate": "cephalothorax",
          "orientationScheme": "singular"
        }
      },
      {
        "type": "abdomen",
        "socketPattern": {
          "idTemplate": "abdomen",
          "orientationScheme": "singular",
          "attachment": "posterior"
        }
      }
    ]
  }
}
```

**Blueprint** (`anatomy:spider_common`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.blueprint.schema.json",
  "blueprintId": "anatomy:spider_common",
  "version": "2.0",
  "structureTemplateId": "anatomy:spider_template",
  "bodyDescriptors": {
    "build": "slim",
    "composition": "chitinous"
  }
}
```

**Recipe** (`anatomy:spider_garden`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.recipe.schema.json",
  "recipeId": "anatomy:spider_garden",
  "blueprintId": "anatomy:spider_common",
  "slots": {
    "cephalothorax": {
      "partType": "spider_cephalothorax",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "eyeCount": 8
        }
      }
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"],
      "properties": {
        "anatomy:segmented": {
          "segments": 7,
          "hairDensity": "moderate"
        }
      }
    },
    {
      "matchesGroup": "appendage:abdomen",
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "size": "medium",
          "pattern": "striped"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "build": "slim",
    "skinColor": "brown",
    "height": "small"
  }
}
```

**Generated Slots**:
- `leg_1` through `leg_8`: Use pattern → `spider_leg` with segmented properties
- `cephalothorax`: Uses explicit slot → `spider_cephalothorax` with 8 eyes
- `abdomen`: Uses pattern → `spider_abdomen` with striped pattern

**Key Features**:
- **matchesGroup**: Efficiently targets all 8 legs from the structure template
- **Explicit slot**: Cephalothorax has unique eye configuration
- **Properties**: Each part type has customized properties
- **Body Descriptors**: Overall appearance settings

**Variant: Spider with Specialized Front Legs**

```json
{
  "recipeId": "anatomy:spider_hunter",
  "blueprintId": "anatomy:spider_common",
  "slots": {
    "leg_1": {
      "partType": "spider_leg_sensory",
      "tags": ["anatomy:part", "anatomy:segmented", "anatomy:sensory"],
      "properties": {
        "anatomy:sensory": {
          "sensitivity": "high",
          "range": "close"
        }
      }
    },
    "leg_2": {
      "partType": "spider_leg_sensory",
      "tags": ["anatomy:part", "anatomy:segmented", "anatomy:sensory"],
      "properties": {
        "anatomy:sensory": {
          "sensitivity": "high",
          "range": "close"
        }
      }
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    },
    {
      "matchesGroup": "appendage:abdomen",
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**How It Works**:
- Explicit slots for `leg_1` and `leg_2` override the pattern
- Remaining legs (`leg_3`-`leg_8`) use the standard pattern
- Demonstrates precedence: explicit slots > patterns

## Example 2: Dragon (Wings + Quadrupedal Legs)

Complete recipe for a dragon with wings, four legs, head, and tail.

**Structure Template** (`anatomy:dragon_template`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.structure-template.schema.json",
  "structureTemplateId": "anatomy:dragon_template",
  "topology": {
    "limbSets": [
      {
        "type": "leg",
        "count": 4,
        "socketPattern": {
          "idTemplate": "leg_{{orientation}}",
          "orientationScheme": "quadrupedal",
          "attachment": "torso"
        },
        "requirements": {
          "partType": "leg"
        }
      },
      {
        "type": "wing",
        "count": 2,
        "socketPattern": {
          "idTemplate": "wing_{{orientation}}",
          "orientationScheme": "bilateral",
          "attachment": "shoulders"
        },
        "requirements": {
          "partType": "wing"
        }
      }
    ],
    "appendages": [
      {
        "type": "head",
        "socketPattern": {
          "idTemplate": "head",
          "orientationScheme": "singular"
        }
      },
      {
        "type": "tail",
        "socketPattern": {
          "idTemplate": "tail",
          "orientationScheme": "singular",
          "attachment": "posterior"
        }
      }
    ]
  }
}
```

**Blueprint** (`anatomy:dragon_v2`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.blueprint.schema.json",
  "blueprintId": "anatomy:dragon_v2",
  "version": "2.0",
  "structureTemplateId": "anatomy:dragon_template",
  "bodyDescriptors": {
    "build": "muscular",
    "composition": "scaled",
    "height": "gigantic"
  }
}
```

**Recipe** (`anatomy:dragon_red`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.recipe.schema.json",
  "recipeId": "anatomy:dragon_red",
  "blueprintId": "anatomy:dragon_v2",
  "slots": {
    "head": {
      "partType": "dragon_head",
      "preferId": "anatomy:dragon_head_ancient",
      "tags": ["anatomy:part", "anatomy:horned", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson",
          "texture": "rough"
        },
        "anatomy:horned": {
          "hornCount": 6,
          "hornSize": "large"
        }
      }
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled", "anatomy:clawed"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson"
        },
        "anatomy:clawed": {
          "clawCount": 4,
          "clawSharpness": "razor"
        }
      }
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"],
      "properties": {
        "anatomy:membranous": {
          "color": "dark_red",
          "texture": "leathery",
          "wingspan": "massive"
        }
      }
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:spiked", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson"
        },
        "anatomy:spiked": {
          "spikeCount": 12,
          "spikeSize": "large"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "build": "muscular",
    "skinColor": "crimson",
    "height": "gigantic"
  },
  "constraints": {
    "requires": [
      {
        "components": ["anatomy:scaled", "anatomy:fire_breathing"]
      }
    ]
  }
}
```

**Generated Slots**:
- `head`: Explicit slot → `dragon_head` with 6 horns
- `leg_front_left`, `leg_front_right`, `leg_rear_left`, `leg_rear_right`: Pattern → `dragon_leg` with claws
- `wing_left`, `wing_right`: Pattern → `dragon_wing` with leathery membranes
- `tail`: Pattern → `dragon_tail` with 12 spikes

**Key Features**:
- **Multiple matchesGroup patterns**: Each limb type targeted separately
- **Explicit head slot**: Unique configuration with ancient variant
- **Consistent coloring**: Crimson scales across legs, head, and tail
- **Constraints**: Requires fire-breathing component for gameplay integration

**Variant: Dragon with Differentiated Front/Rear Legs**

```json
{
  "recipeId": "anatomy:dragon_warrior",
  "blueprintId": "anatomy:dragon_v2",
  "slots": {
    "head": {
      "partType": "dragon_head",
      "tags": ["anatomy:part", "anatomy:horned"]
    }
  },
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_front"
      },
      "partType": "dragon_leg_front",
      "tags": ["anatomy:part", "anatomy:scaled", "anatomy:grasping"],
      "properties": {
        "anatomy:grasping": {
          "dexterity": "high"
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_rear"
      },
      "partType": "dragon_leg_rear",
      "tags": ["anatomy:part", "anatomy:scaled", "anatomy:powerful"],
      "properties": {
        "anatomy:powerful": {
          "strength": "exceptional",
          "jumpPower": "high"
        }
      }
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:weaponized"]
    }
  ]
}
```

**How It Works**:
- **matchesAll with orientation wildcards**: Differentiates front legs (grasping) from rear legs (powerful)
- Front legs optimized for grabbing prey
- Rear legs optimized for propulsion and jumping
- Demonstrates advanced property-based filtering

## Example 3: Centaur (Hybrid Human/Horse)

Complete recipe for a centaur with human upper body and horse lower body.

**Structure Template** (`anatomy:centaur_template`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.structure-template.schema.json",
  "structureTemplateId": "anatomy:centaur_template",
  "topology": {
    "limbSets": [
      {
        "type": "arm",
        "count": 2,
        "socketPattern": {
          "idTemplate": "arm_{{orientation}}",
          "orientationScheme": "bilateral",
          "attachment": "humanoid_torso"
        },
        "requirements": {
          "partType": "limb"
        }
      },
      {
        "type": "leg",
        "count": 4,
        "socketPattern": {
          "idTemplate": "leg_{{orientation}}",
          "orientationScheme": "quadrupedal",
          "attachment": "equine_torso"
        },
        "requirements": {
          "partType": "limb"
        }
      }
    ],
    "appendages": [
      {
        "type": "head",
        "socketPattern": {
          "idTemplate": "head",
          "orientationScheme": "singular"
        }
      },
      {
        "type": "tail",
        "socketPattern": {
          "idTemplate": "tail",
          "orientationScheme": "singular",
          "attachment": "posterior"
        }
      }
    ]
  }
}
```

**Blueprint** (`anatomy:centaur_v2`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.blueprint.schema.json",
  "blueprintId": "anatomy:centaur_v2",
  "version": "2.0",
  "structureTemplateId": "anatomy:centaur_template",
  "bodyDescriptors": {
    "build": "athletic",
    "composition": "mixed",
    "height": "tall"
  }
}
```

**Recipe** (`anatomy:centaur_warrior`):
```json
{
  "$schema": "schema://living-narrative-engine/anatomy.recipe.schema.json",
  "recipeId": "anatomy:centaur_warrior",
  "blueprintId": "anatomy:centaur_v2",
  "slots": {
    "head": {
      "partType": "human_head",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "hairColor": "chestnut",
          "eyeColor": "green"
        }
      }
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:arm",
      "partType": "human_arm",
      "tags": ["anatomy:part", "anatomy:dexterous"],
      "properties": {
        "anatomy:dexterous": {
          "fingerCount": 5,
          "thumbOpposable": true,
          "gripStrength": "strong"
        }
      }
    },
    {
      "matchesGroup": "limbSet:leg",
      "partType": "horse_leg",
      "tags": ["anatomy:part", "anatomy:hooved"],
      "properties": {
        "anatomy:hooved": {
          "hoofType": "solid",
          "hoofColor": "black",
          "gait": "quadrupedal"
        }
      }
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "horse_tail",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "hairColor": "chestnut",
          "length": "long"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "build": "athletic",
    "skinColor": "tanned",
    "height": "tall"
  }
}
```

**Generated Slots**:
- `head`: Explicit slot → `human_head` with green eyes
- `arm_left`, `arm_right`: Pattern → `human_arm` with dexterous properties
- `leg_front_left`, `leg_front_right`, `leg_rear_left`, `leg_rear_right`: Pattern → `horse_leg` with hooves
- `tail`: Pattern → `horse_tail` with chestnut hair

**Key Features**:
- **Two distinct limb sets**: Arms (human) and legs (horse)
- **matchesGroup for each**: Clear separation of human vs equine anatomy
- **Hybrid body descriptors**: Combines humanoid and equine characteristics
- **Coordinated coloring**: Matching hair color on head and tail

**Variant: Centaur with Property-Based Filtering**

```json
{
  "recipeId": "anatomy:centaur_ranger",
  "blueprintId": "anatomy:centaur_v2",
  "patterns": [
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "arm_*"
      },
      "partType": "human_arm",
      "tags": ["anatomy:part", "anatomy:dexterous"],
      "properties": {
        "anatomy:dexterous": {
          "archerySkill": "expert",
          "bowDrawStrength": "high"
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "leg_*"
      },
      "partType": "horse_leg",
      "tags": ["anatomy:part", "anatomy:hooved"],
      "properties": {
        "anatomy:hooved": {
          "speed": "fast",
          "endurance": "high"
        }
      }
    },
    {
      "matchesGroup": "appendage:head",
      "partType": "human_head",
      "tags": ["anatomy:part"]
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "horse_tail",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**How It Works**:
- **matchesAll with orientation**: Differentiates arms (`arm_*`) from legs (`leg_*`)
- Ranger specialization with archery skills on arms
- Fast, enduring legs for long-range mobility
- Demonstrates hybrid anatomy with property-based filtering

## Example 4: Advanced Filtering Scenarios

### Scenario 1: Octopus with Specialized Tentacles

**Use Case**: Octopus where first two tentacles are modified for fine manipulation, remaining six for locomotion.

**Recipe** (`anatomy:octopus_intelligent`):
```json
{
  "recipeId": "anatomy:octopus_intelligent",
  "blueprintId": "anatomy:octopus_common",
  "patterns": [
    {
      "matchesAll": {
        "slotType": "tentacle",
        "socketId": "tentacle_[1-2]"
      },
      "partType": "octopus_tentacle_manipulation",
      "tags": ["anatomy:part", "anatomy:prehensile", "anatomy:dexterous"],
      "properties": {
        "anatomy:prehensile": {
          "strength": 10,
          "dexterity": 8,
          "suckerCount": 100
        },
        "anatomy:dexterous": {
          "finePrecision": "high",
          "toolUse": true
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "tentacle"
      },
      "partType": "octopus_tentacle",
      "tags": ["anatomy:part", "anatomy:prehensile"],
      "properties": {
        "anatomy:prehensile": {
          "strength": 8,
          "suckerCount": 200
        }
      },
      "exclude": {
        "properties": {
          "socketId": "tentacle_[1-2]"
        }
      }
    }
  ]
}
```

**How It Works**:
- First pattern targets `tentacle_1` and `tentacle_2` with enhanced manipulation
- Second pattern targets all remaining tentacles, excluding the first two
- Demonstrates combining filters with exclusions

### Scenario 2: Dragon with Asymmetric Wings

**Use Case**: Dragon with damaged right wing requiring different part entity.

**Recipe** (`anatomy:dragon_wounded`):
```json
{
  "recipeId": "anatomy:dragon_wounded",
  "blueprintId": "anatomy:dragon_v2",
  "slots": {
    "wing_right": {
      "partType": "dragon_wing_damaged",
      "preferId": "anatomy:dragon_wing_torn",
      "tags": ["anatomy:part", "anatomy:damaged", "anatomy:membranous"],
      "properties": {
        "anatomy:damaged": {
          "severity": "moderate",
          "healable": true,
          "flightPenalty": "high"
        }
      }
    }
  },
  "patterns": [
    {
      "matchesAll": {
        "slotType": "wing",
        "orientation": "left"
      },
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"],
      "properties": {
        "anatomy:membranous": {
          "condition": "pristine",
          "wingspan": "full"
        }
      }
    },
    {
      "matchesGroup": "limbSet:leg",
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"]
    }
  ]
}
```

**How It Works**:
- Explicit slot overrides pattern for damaged right wing
- Left wing uses property filter pattern
- Demonstrates asymmetric anatomy for gameplay purposes

### Scenario 3: Multi-Socket Specialization

**Use Case**: Mechanical creature with different socket systems for combat vs utility limbs.

**Recipe** (`anatomy:golem_combat`):
```json
{
  "recipeId": "anatomy:golem_combat",
  "blueprintId": "anatomy:golem_modular",
  "patterns": [
    {
      "matchesAll": {
        "socketId": "combat_socket_*"
      },
      "partType": "golem_combat_limb",
      "tags": ["anatomy:part", "anatomy:weaponized"],
      "properties": {
        "anatomy:weaponized": {
          "damageType": "bludgeoning",
          "power": "high"
        }
      }
    },
    {
      "matchesAll": {
        "socketId": "utility_socket_*"
      },
      "partType": "golem_utility_limb",
      "tags": ["anatomy:part", "anatomy:tool"],
      "properties": {
        "anatomy:tool": {
          "toolType": "gripper",
          "precision": "moderate"
        }
      }
    },
    {
      "matchesAll": {
        "socketId": "mobility_socket_*"
      },
      "partType": "golem_leg",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "speed": "moderate",
          "stability": "high"
        }
      }
    }
  ]
}
```

**How It Works**:
- Three different socket patterns for different limb functions
- Socket ID filtering allows modular limb system
- Demonstrates advanced socket-based specialization

## Pattern Validation & Load-Time Checks

### Load-Time Validation

Recipe patterns are validated when mods are loaded:
- **Schema Validation**: Against `data/schemas/anatomy.recipe.schema.json` via AJV
- **Pattern Syntax**: Ensures exactly one matcher type per pattern
- **Blueprint Consistency**: Verifies referenced blueprintId exists

**Validation Process** (`src/anatomy/recipePatternResolver/patternResolver.js`):
```javascript
// Pattern resolution happens during recipe processing
// Zero-match patterns (V2 patterns) fail validation with detailed error messages
if (!usesExplicitMatches && matchedSlotKeys.length === 0) {
  this.#raiseZeroMatchError({
    pattern,
    blueprint,
    patternIndex: index,
    slotGroupRef: matchesGroupRef,
  });
}
```

**Important**: V2 patterns (matchesGroup, matchesPattern, matchesAll) that match zero slots will **fail validation** with a ValidationError. The error message includes helpful hints about available slots, orientations, and socket IDs to aid in debugging. V1 patterns (explicit `matches` array) allow empty arrays for backward compatibility.

### Pattern-Blueprint Synchronization

**Critical Requirement**: Recipe patterns depend on blueprint slot structure generated from structure templates. Changes to templates require corresponding recipe updates.

**Synchronization Flow**:
```
Structure Template → SlotGenerator → Blueprint Slots → Recipe Patterns
         (defines)      (generates)       (contains)       (matches)
```

**Example Synchronization Issue**:
```json
// Structure template generates: leg_1, leg_2, leg_3, leg_4
{
  "socketPattern": {
    "idTemplate": "leg_{{index}}",
    "orientationScheme": "indexed"
  }
}

// Recipe pattern must match generated format
{
  "matchesPattern": "leg_*"  // ✅ Matches leg_1, leg_2, etc.
}

// If template changes to bilateral orientation:
{
  "idTemplate": "leg_{{orientation}}",
  "orientationScheme": "bilateral"  // Now generates: leg_left, leg_right
}

// Recipe pattern needs update:
{
  "matchesPattern": "leg_*"  // ⚠️ Still matches, but pattern is less specific
  // or
  "matchesGroup": "limbSet:leg"  // ✅ Better - independent of naming
}
```

## Troubleshooting

### Pattern Doesn't Match Expected Slots

**Cause**: Pattern matcher doesn't align with actual slot structure.
**Fix**:
1. Inspect blueprint to see generated slot keys
2. Adjust pattern to match actual slot naming
3. Use explicit `slots` for debugging
4. Check structure template's socket pattern configuration

### Pattern Matches Too Many Slots

**Cause**: Pattern is too broad (e.g., `matchesPattern: "*"`).
**Fix**: Use more specific matcher or add exclusions.

### Pattern Doesn't Match Any Slots

**Cause**: Pattern syntax error or slot keys don't follow expected pattern.
**Fix**:
1. Verify slot keys exist in blueprint
2. Check pattern syntax (case-sensitive)
3. Use debugging recipe with explicit `slots` to verify slot keys
4. Enable debug logging to see pattern resolution details
5. Verify structure template's `orientationScheme` matches expected slot naming

### Multiple Patterns Match Same Slot

**Cause**: Overlapping patterns without precedence rules.
**Fix**: Use more specific patterns or explicit slots to override.

### Pattern Validation Error

**Cause**: Using multiple matcher types in one pattern or missing required fields.
**Fix**: Ensure each pattern has exactly one of `matches`, `matchesGroup`, `matchesPattern`, or `matchesAll`.

### Zero-Match Pattern Errors

**Cause**: V2 pattern (matchesGroup, matchesPattern, matchesAll) matches zero slots, causing validation to fail.
**Fix**:
1. Check the error message for available slot keys, orientations, and socket IDs
2. Verify the pattern syntax matches the actual blueprint slot structure
3. For `matchesGroup`: Ensure the structure template has the referenced limb set or appendage type
4. For `matchesPattern`: Verify wildcard pattern matches actual slot key naming
5. For `matchesAll`: Check that filter properties match actual slot definitions
6. Consider using `matchesGroup` for resilience against template naming changes

**Note**: V1 patterns (explicit `matches` arrays) allow empty arrays for backward compatibility and will not fail validation.

## Related Documentation

- **Structure Templates**: [structure-templates.md](./structure-templates.md) - Generating slots
- **Blueprint V2**: [blueprints-v2.md](./blueprints-v2.md) - Blueprint slot structure
- **Quick Start**: [non-human-quickstart.md](./non-human-quickstart.md) - Complete workflow

## Reference

**Schema File**: `data/schemas/anatomy.recipe.schema.json`

**Implementation**:
- Main resolver: `/src/anatomy/recipePatternResolver/patternResolver.js` (lines 285-522 for pattern resolution)
- Property matcher: `/src/anatomy/recipePatternResolver/matchers/propertyMatcher.js` (lines 24-73 for `resolvePropertyFilter`, lines 85-114 for `validateMatchesAll`)

**Tests**: `/tests/unit/anatomy/recipePatternResolver.test.js` (lines 635-801 for `matchesAll Resolution` test suite)

**Example Recipes**:
- `data/mods/anatomy/recipes/human_*.recipe.json` (V1 examples)
- `data/mods/core/recipes/examples/` (V2 examples)

**Pattern Documentation**: This file
