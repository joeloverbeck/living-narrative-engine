# Recipe Pattern Matching

## Overview

Anatomy recipes define what body parts a creature should have by matching blueprint slots to entity parts. The pattern matching system allows you to efficiently configure multiple slots at once, which is especially powerful for creatures with many repeating limbs generated by Structure Templates.

**Schema Location**: `data/schemas/anatomy.recipe.schema.json`

**Related Guides**:
- [Property-Based Filtering Examples](./property-based-filtering-examples.md) - Comprehensive `matchesAll` usage examples
- [V1 to V2 Pattern Migration](./v1-to-v2-pattern-migration.md) - Upgrade guide from explicit patterns
- [Pattern Matching Best Practices](./pattern-matching-best-practices.md) - Decision trees and optimization
- [Common Non-Human Patterns](./common-non-human-patterns.md) - Battle-tested creature patterns

## Pattern Types

The recipe system supports two pattern definition formats:

### V1 Patterns (Explicit Slot Lists)

V1 patterns use an explicit `matches` array listing slot keys:

```json
{
  "patterns": [
    {
      "matches": ["leg_1", "leg_2", "leg_3", "leg_4"],
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

### V2 Patterns (Enhanced Matchers)

V2 patterns use one of three advanced matchers:
- **matchesGroup**: Slot group selector
- **matchesPattern**: Wildcard pattern
- **matchesAll**: Property-based filter

```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Important**: Each pattern must use **exactly one** of `matches` (V1), `matchesGroup`, `matchesPattern`, or `matchesAll` (V2). Using multiple or none will fail validation.

## Pattern Matching Overview

Patterns complement individual slot definitions:

```json
{
  "recipeId": "anatomy:spider_recipe",
  "blueprintId": "anatomy:spider_common",
  "slots": {
    "abdomen": {
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"]
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Priority**: Individual `slots` take precedence over `patterns`. If a slot appears in both, the explicit slot definition wins.

## matchesGroup: Slot Group Selector

The `matchesGroup` matcher targets all slots generated from a specific limb set or appendage group in the structure template.

### Syntax

**Format**: `"limbSet:{type}"` or `"appendage:{type}"`

Where `{type}` matches the `type` property from the structure template's `limbSets` or `appendages`.

### Examples

#### Matching All Legs

**Structure Template**:
```json
{
  "topology": {
    "limbSets": [
      {
        "type": "leg",
        "count": 8,
        "socketPattern": { /* ... */ }
      }
    ]
  }
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"]
    }
  ]
}
```

This matches all 8 leg slots generated by the "leg" limb set.

#### Matching All Wings

**Structure Template**:
```json
{
  "limbSets": [
    {
      "type": "wing",
      "count": 2,
      "socketPattern": { /* ... */ }
    }
  ]
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "red"
        }
      }
    }
  ]
}
```

#### Matching Appendages

**Structure Template**:
```json
{
  "appendages": [
    {
      "type": "tail",
      "count": 1,
      "attachment": "posterior",
      "socketPattern": { /* ... */ }
    }
  ]
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:prehensile"]
    }
  ]
}
```

### Multiple Limb Sets

If your template has multiple limb sets with the same type, `matchesGroup` matches **all** of them:

**Structure Template**:
```json
{
  "limbSets": [
    {
      "type": "leg",
      "count": 4,  // Front legs
      "socketPattern": { /* ... */ }
    },
    {
      "type": "leg",
      "count": 4,  // Rear legs
      "socketPattern": { /* ... */ }
    }
  ]
}
```

**Recipe Pattern**:
```json
{
  "matchesGroup": "limbSet:leg"  // Matches all 8 legs from both sets
}
```

To target specific legs, use `matchesPattern` or `matchesAll` with additional filters.

## matchesPattern: Wildcard Matching

The `matchesPattern` matcher uses wildcard patterns to match slot keys by name.

### Syntax

**Format**: `"prefix*"`, `"*suffix"`, or `"*middle*"`

The `*` wildcard matches any characters (including none).

**Pattern Rules**:
- Pattern must match the slot key (not socket ID)
- Case-sensitive matching
- `*` matches zero or more characters
- Anchor pattern at start, end, or both

### Examples

#### Prefix Matching

Match all legs regardless of numbering:

```json
{
  "matchesPattern": "leg_*",
  "partType": "spider_leg"
}
```

Matches: `leg_1`, `leg_2`, `leg_left`, `leg_right_front`, etc.

#### Suffix Matching

Match all left-side parts:

```json
{
  "matchesPattern": "*_left",
  "partType": "left_sided_part"
}
```

Matches: `arm_left`, `wing_left`, `eye_left`, etc.

#### Contains Matching

Match all tentacles:

```json
{
  "matchesPattern": "*tentacle*",
  "partType": "octopus_tentacle"
}
```

Matches: `tentacle_1`, `front_tentacle_left`, `tentacle_tip_2`, etc.

#### Exact Match (No Wildcard)

```json
{
  "matchesPattern": "head",
  "partType": "dragon_head"
}
```

Matches only: `head`

### Complex Wildcard Example

**Spider with Tagged Patterns**:

```json
{
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"],
      "properties": {
        "anatomy:segmented": {
          "segments": 7
        }
      }
    },
    {
      "matchesPattern": "abdomen",
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"],
      "preferId": "anatomy:spider_abdomen_female"
    }
  ]
}
```

## matchesAll: Property-Based Filtering

The `matchesAll` matcher filters slots based on their properties. This provides fine-grained control when `matchesGroup` or `matchesPattern` are too broad.

### Syntax

**Object with optional filters**:
- `slotType`: Filter by part type requirement
- `orientation`: Filter by orientation (supports wildcards)
- `socketId`: Filter by socket ID pattern

At least one filter property is required.

### Filter: slotType

Match slots that require a specific part type:

```json
{
  "matchesAll": {
    "slotType": "leg"
  },
  "partType": "spider_leg"
}
```

Matches all slots with `requirements.partType === "leg"`.

### Filter: orientation

Match slots by orientation, with wildcard support:

**Exact Match**:
```json
{
  "matchesAll": {
    "orientation": "left"
  },
  "partType": "left_arm"
}
```

Matches slots with `left` orientation.

**Wildcard Match**:
```json
{
  "matchesAll": {
    "orientation": "left_*"
  },
  "partType": "left_side_leg"
}
```

Matches: `left_front`, `left_rear`, `left_middle`, etc.

### Filter: socketId

Match slots by socket ID pattern:

```json
{
  "matchesAll": {
    "socketId": "leg_*"
  },
  "partType": "spider_leg"
}
```

Matches slots with socket IDs like `leg_1`, `leg_2`, etc.

### Combined Filters

Use multiple filters for precise matching:

```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "left_*"
  },
  "partType": "front_left_leg",
  "tags": ["anatomy:part", "anatomy:scaled"]
}
```

Matches left-side legs only.

### Complete Example: Dragon Recipe

```json
{
  "recipeId": "anatomy:dragon_warrior",
  "blueprintId": "anatomy:dragon_v2",
  "slots": {
    "head": {
      "partType": "dragon_head",
      "preferId": "anatomy:dragon_head_elder",
      "tags": ["anatomy:part", "anatomy:horned"]
    }
  },
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "left_*"
      },
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson",
          "pattern": "striped"
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "right_*"
      },
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson",
          "pattern": "striped"
        }
      }
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:spiked"]
    }
  ]
}
```

## Pattern Exclusions

Use the `exclude` property to filter out slots from a pattern match.

### Exclude Slot Groups

Exclude specific slot groups from matching:

```json
{
  "matchesPattern": "leg_*",
  "partType": "normal_leg",
  "exclude": {
    "slotGroups": ["limbSet:special_leg"]
  }
}
```

### Exclude by Properties

Exclude slots with specific properties:

```json
{
  "matchesAll": {
    "slotType": "leg"
  },
  "partType": "standard_leg",
  "exclude": {
    "properties": {
      "orientation": "mid"
    }
  }
}
```

Matches all legs except middle legs.

## Choosing the Right Pattern Type

### Use matchesGroup When:

- Targeting all limbs from a structure template limb set
- Targeting all appendages of a specific type
- Template-generated slots with consistent type
- Simple, broad matching needs

**Example**: All spider legs, all dragon wings

### Use matchesPattern When:

- Matching by slot key naming convention
- Targeting slots with common prefix/suffix
- Blueprint uses consistent naming patterns
- Need flexibility without knowing exact slot structure

**Example**: All legs (`leg_*`), all left-side parts (`*_left`)

### Use matchesAll When:

- Need fine-grained filtering by multiple properties
- Slots don't follow simple naming patterns
- Orientation-specific matching
- Complex blueprints with mixed slot types

**Example**: Only left legs, specific orientations, socket ID filters

### Use Explicit slots When:

- Single unique slot
- Slot needs different configuration than pattern matches
- Overriding a pattern for one specific slot

**Example**: Unique head, tail with special properties

## Pattern Precedence

When multiple patterns or slots match the same slot key, priority is:

1. **Explicit `slots` definition** (highest priority)
2. **Most specific pattern** (matchesAll > matchesPattern > matchesGroup)
3. **First matching pattern** (if specificity is equal)

### Example: Override Pattern for One Slot

```json
{
  "slots": {
    "leg_1": {
      "partType": "special_leg",
      "tags": ["anatomy:part", "anatomy:golden"]
    }
  },
  "patterns": [
    {
      "matchesPattern": "leg_*",
      "partType": "normal_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

Result:
- `leg_1`: Uses explicit slot definition → `special_leg` with golden tag
- `leg_2`, `leg_3`, etc.: Use pattern → `normal_leg`

## Pattern Conflicts

Patterns must be mutually exclusive within each pattern definition. You **cannot** use multiple matcher types in one pattern:

```json
// ❌ INVALID: Cannot use both matchesGroup and matchesPattern
{
  "matchesGroup": "limbSet:leg",
  "matchesPattern": "leg_*",  // ERROR: Only one matcher allowed
  "partType": "spider_leg"
}
```

```json
// ✅ VALID: Use separate patterns
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg"
    },
    {
      "matchesPattern": "tentacle_*",
      "partType": "octopus_tentacle"
    }
  ]
}
```

## Common Pattern Examples

### All Spider Legs (8 legs)

```json
{
  "matchesGroup": "limbSet:leg",
  "partType": "spider_leg",
  "tags": ["anatomy:part", "anatomy:segmented"]
}
```

### Dragon Wings (Left and Right)

```json
{
  "matchesGroup": "limbSet:wing",
  "partType": "dragon_wing",
  "tags": ["anatomy:part", "anatomy:scaled"]
}
```

### Centaur Arms (Humanoid Upper Body)

```json
{
  "matchesPattern": "arm_*",
  "partType": "human_arm",
  "tags": ["anatomy:part"]
}
```

### Centaur Horse Legs (Quadruped Lower Body)

```json
{
  "matchesPattern": "leg_*",
  "partType": "horse_leg",
  "tags": ["anatomy:part"]
}
```

### All Left-Side Parts

```json
{
  "matchesAll": {
    "orientation": "left_*"
  },
  "partType": "left_limb",
  "tags": ["anatomy:part"],
  "properties": {
    "anatomy:part": {
      "side": "left"
    }
  }
}
```

### All Right-Side Parts

```json
{
  "matchesAll": {
    "orientation": "right_*"
  },
  "partType": "right_limb",
  "tags": ["anatomy:part"],
  "properties": {
    "anatomy:part": {
      "side": "right"
    }
  }
}
```

### Octopus Tentacles (Numbered)

```json
{
  "matchesPattern": "tentacle_*",
  "partType": "octopus_tentacle",
  "tags": ["anatomy:part", "anatomy:prehensile"],
  "properties": {
    "anatomy:prehensile": {
      "strength": 8
    }
  }
}
```

### Front Legs Only (Quadruped)

```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "*_front"
  },
  "partType": "front_leg",
  "tags": ["anatomy:part"]
}
```

### Rear Legs Only (Quadruped)

```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "*_rear"
  },
  "partType": "rear_leg",
  "tags": ["anatomy:part"]
}
```

## Complete Recipe Example: Spider

```json
{
  "$schema": "schema://living-narrative-engine/anatomy.recipe.schema.json",
  "recipeId": "anatomy:spider_garden",
  "blueprintId": "anatomy:spider_common",
  "slots": {
    "eyes": {
      "partType": "spider_eyes",
      "preferId": "anatomy:spider_eyes_octet",
      "tags": ["anatomy:part"]
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"],
      "properties": {
        "anatomy:segmented": {
          "segments": 7,
          "hairDensity": "moderate"
        }
      }
    },
    {
      "matchesGroup": "appendage:abdomen",
      "partType": "spider_abdomen",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "size": "medium",
          "pattern": "striped"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "build": "slim",
    "skinColor": "brown"
  }
}
```

**Generated slots**:
- `leg_1` through `leg_8`: Use pattern → `spider_leg`
- `abdomen`: Uses pattern → `spider_abdomen`
- `eyes`: Uses explicit slot → `spider_eyes`

## Complete Recipe Example: Dragon

```json
{
  "$schema": "schema://living-narrative-engine/anatomy.recipe.schema.json",
  "recipeId": "anatomy:dragon_red",
  "blueprintId": "anatomy:dragon_v2",
  "slots": {
    "head": {
      "partType": "dragon_head",
      "preferId": "anatomy:dragon_head_ancient",
      "tags": ["anatomy:part", "anatomy:horned", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson",
          "texture": "rough"
        }
      }
    }
  },
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "dragon_leg",
      "tags": ["anatomy:part", "anatomy:scaled", "anatomy:clawed"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson"
        },
        "anatomy:clawed": {
          "clawCount": 4
        }
      }
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "dragon_wing",
      "tags": ["anatomy:part", "anatomy:membranous"],
      "properties": {
        "anatomy:membranous": {
          "color": "dark_red",
          "texture": "leathery"
        }
      }
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "dragon_tail",
      "tags": ["anatomy:part", "anatomy:spiked", "anatomy:scaled"],
      "properties": {
        "anatomy:scaled": {
          "color": "crimson"
        },
        "anatomy:spiked": {
          "spikeCount": 12,
          "spikeSize": "large"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "build": "muscular",
    "skinColor": "crimson",
    "height": "gigantic"
  },
  "constraints": {
    "requires": [
      {
        "components": ["anatomy:scaled", "anatomy:fire_breathing"]
      }
    ]
  }
}
```

## Best Practices

### 1. Prefer Patterns Over Explicit Slots

For repeating limbs, use patterns instead of explicit slots:

```json
// ❌ BAD: Repetitive explicit slots
"slots": {
  "leg_1": { "partType": "leg" },
  "leg_2": { "partType": "leg" },
  "leg_3": { "partType": "leg" },
  "leg_4": { "partType": "leg" }
}

// ✅ GOOD: Single pattern
"patterns": [
  {
    "matchesPattern": "leg_*",
    "partType": "leg"
  }
]
```

### 2. Use Specific Patterns

Choose the most specific pattern type that works:

```json
// ❌ OVERLY BROAD: Matches more than intended
"matchesPattern": "*",

// ✅ GOOD: Specific to limb set
"matchesGroup": "limbSet:leg"
```

### 3. Document Pattern Intent

Add comments explaining complex patterns:

```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "left_*"
      },
      "partType": "front_left_leg",
      "tags": ["anatomy:part"]
    }
  ]
}
```

Add a recipe-level `description` property when available.

### 4. Test Pattern Matching

Create test entities to verify patterns match expected slots.

### 5. Avoid Pattern Overlap

Don't create patterns that match the same slots with different configurations:

```json
// ❌ BAD: Overlapping patterns (conflict)
"patterns": [
  {
    "matchesPattern": "leg_*",
    "partType": "spider_leg"
  },
  {
    "matchesPattern": "leg_1",
    "partType": "special_leg"  // Conflicts with above
  }
]

// ✅ GOOD: Use explicit slot to override
"slots": {
  "leg_1": {
    "partType": "special_leg"
  }
},
"patterns": [
  {
    "matchesPattern": "leg_*",
    "partType": "spider_leg"
  }
]
```

### 6. Group Related Patterns

Keep similar patterns together for readability:

```json
"patterns": [
  // All leg patterns
  {
    "matchesAll": { "slotType": "leg", "orientation": "left_*" },
    "partType": "left_leg"
  },
  {
    "matchesAll": { "slotType": "leg", "orientation": "right_*" },
    "partType": "right_leg"
  },
  // All wing patterns
  {
    "matchesGroup": "limbSet:wing",
    "partType": "dragon_wing"
  }
]
```

## Troubleshooting

### Pattern Doesn't Match Expected Slots

**Cause**: Pattern matcher doesn't align with actual slot structure.
**Fix**:
1. Inspect blueprint to see generated slot keys
2. Adjust pattern to match actual slot naming
3. Use explicit `slots` for debugging

### Pattern Matches Too Many Slots

**Cause**: Pattern is too broad (e.g., `matchesPattern: "*"`).
**Fix**: Use more specific matcher or add exclusions.

### Pattern Doesn't Match Any Slots

**Cause**: Pattern syntax error or slot keys don't follow expected pattern.
**Fix**:
1. Verify slot keys exist in blueprint
2. Check pattern syntax (case-sensitive)
3. Use debugging recipe with explicit `slots` to verify slot keys

### Multiple Patterns Match Same Slot

**Cause**: Overlapping patterns without precedence rules.
**Fix**: Use more specific patterns or explicit slots to override.

### Pattern Validation Error

**Cause**: Using multiple matcher types in one pattern or missing required fields.
**Fix**: Ensure each pattern has exactly one of `matches`, `matchesGroup`, `matchesPattern`, or `matchesAll`.

## Related Documentation

- **Structure Templates**: [structure-templates.md](./structure-templates.md) - Generating slots
- **Blueprint V2**: [blueprints-v2.md](./blueprints-v2.md) - Blueprint slot structure
- **Quick Start**: [non-human-quickstart.md](./non-human-quickstart.md) - Complete workflow

## Next Steps

1. Create blueprint (with structure template for V2)
2. Design recipe patterns to populate slots
3. Test with entity instantiation
4. Refine patterns based on results

## Reference

**Schema File**: `data/schemas/anatomy.recipe.schema.json`
**Example Recipes**: `data/mods/anatomy/recipes/human_*.recipe.json` (V1 examples)
**Pattern Documentation**: This file
