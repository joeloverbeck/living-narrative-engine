# Common Non-Human Anatomy Patterns

Guide to frequently-used anatomy patterns for non-human creatures using property-based filtering (`matchesAll`) and V2 blueprint features.

## Overview

This guide provides battle-tested patterns for common non-human anatomies. Each pattern includes:

- Structure template recommendations
- Blueprint configuration
- Recipe pattern strategies
- Complete working examples

## Pattern Categories

### Radial Symmetry Creatures

#### Eight-Legged Spider

**Use Case**: Arachnids, mechanical walkers, alien creatures

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 8,
        "orientationScheme": "radial",
        "requirements": {
          "partType": "spider_leg"
        }
      }
    ]
  }
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "limbSet:leg",
      "partType": "spider_leg",
      "tags": ["anatomy:part", "anatomy:segmented"],
      "properties": {
        "anatomy:segmented": {
          "segmentCount": 7,
          "flexibility": "high"
        }
      }
    }
  ]
}
```

**Why This Works**:
- `matchesGroup` targets all 8 legs generated by structure template
- Single pattern definition scales automatically with count changes
- Radial orientation scheme ensures even spacing

**Complete Example**: See `data/mods/core/recipes/examples/spider-property-filtering.recipe.json`

#### Octopus/Tentacled Creatures

**Use Case**: Cephalopods, tentacle monsters, hydras

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "tentacle",
        "count": 8,
        "orientationScheme": "radial",
        "requirements": {
          "partType": "tentacle"
        }
      }
    ],
    "appendages": [
      {
        "id": "head",
        "orientationScheme": "singular"
      }
    ]
  }
}
```

**Recipe Pattern with Specialized Tentacles**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "tentacle",
        "socketId": "tentacle_[1-4]"
      },
      "partType": "feeding_tentacle",
      "tags": ["anatomy:part", "anatomy:prehensile"],
      "properties": {
        "anatomy:prehensile": {
          "gripStrength": "strong",
          "suckerCount": 200
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "tentacle",
        "socketId": "tentacle_[5-8]"
      },
      "partType": "locomotion_tentacle",
      "tags": ["anatomy:part"],
      "properties": {
        "anatomy:part": {
          "flexibility": "high",
          "strength": "moderate"
        }
      }
    }
  ]
}
```

**Advanced Pattern**: Different tentacle types using socketId patterns

### Quadrupedal Creatures

#### Standard Quadruped

**Use Case**: Horses, dogs, cats, most four-legged animals

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 4,
        "orientationScheme": "quadrupedal",
        "requirements": {
          "partType": "leg"
        }
      }
    ],
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern with Front/Rear Differentiation**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_front"
      },
      "partType": "front_leg",
      "tags": ["anatomy:part", "anatomy:clawed"],
      "properties": {
        "anatomy:clawed": {
          "clawCount": 4,
          "retractable": true
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_rear"
      },
      "partType": "rear_leg",
      "tags": ["anatomy:part", "anatomy:powerful"],
      "properties": {
        "anatomy:powerful": {
          "strength": "high",
          "jumpPower": "exceptional"
        }
      }
    }
  ]
}
```

**Why Orientation Filters Work**:
- `*_front` matches `leg_front_left` and `leg_front_right`
- `*_rear` matches `leg_rear_left` and `leg_rear_right`
- Enables different anatomy for front vs rear legs

**Complete Example**: See `data/mods/core/recipes/examples/property-filters/filter-by-orientation.recipe.json`

### Flying Creatures

#### Dragon (Wings + Quadrupedal)

**Use Case**: Dragons, wyverns, griffins, pegasus

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 4,
        "orientationScheme": "quadrupedal",
        "requirements": {
          "partType": "leg"
        }
      },
      {
        "id": "wing",
        "count": 2,
        "orientationScheme": "bilateral",
        "requirements": {
          "partType": "wing"
        }
      }
    ],
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern Combining Multiple Approaches**:
```json
{
  "patterns": [
    {
      "matches": ["head"],
      "partType": "dragon_head",
      "tags": ["anatomy:part", "anatomy:fire_breathing"]
    },
    {
      "matchesGroup": "limbSet:wing",
      "partType": "scaled_wing",
      "tags": ["anatomy:part", "anatomy:membranous"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_front"
      },
      "partType": "dragon_front_leg",
      "tags": ["anatomy:part", "anatomy:clawed"]
    },
    {
      "matchesAll": {
        "slotType": "leg",
        "orientation": "*_rear"
      },
      "partType": "dragon_rear_leg",
      "tags": ["anatomy:part", "anatomy:powerful"]
    },
    {
      "matchesPattern": "tail*",
      "partType": "spiked_tail",
      "tags": ["anatomy:part", "anatomy:weaponized"]
    }
  ]
}
```

**Pattern Strategy**:
- Explicit slots for unique parts (head)
- `matchesGroup` for symmetric pairs (wings)
- `matchesAll` for differentiated sets (front/rear legs)
- `matchesPattern` for wildcards (tail variants)

**Complete Example**: See `data/mods/core/recipes/examples/dragon-mixed-patterns.recipe.json`

### Hybrid Creatures

#### Centaur (Human Upper + Horse Lower)

**Use Case**: Centaurs, merfolk, lamia, driders

**Structure Template**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "limb",
        "count": 6,
        "orientationScheme": "mixed",
        "requirements": {
          "partType": "limb"
        }
      }
    ],
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern with Orientation-Based Separation**:
```json
{
  "patterns": [
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "arm_*"
      },
      "partType": "human_arm",
      "tags": ["anatomy:part", "anatomy:dexterous"],
      "properties": {
        "anatomy:dexterous": {
          "fingerCount": 5,
          "thumbOpposable": true
        }
      }
    },
    {
      "matchesAll": {
        "slotType": "limb",
        "orientation": "leg_*"
      },
      "partType": "horse_leg",
      "tags": ["anatomy:part", "anatomy:hooved"],
      "properties": {
        "anatomy:hooved": {
          "hoofType": "solid",
          "hoofColor": "black"
        }
      }
    },
    {
      "matchesGroup": "appendage:head",
      "partType": "human_head",
      "tags": ["anatomy:part"]
    },
    {
      "matchesGroup": "appendage:tail",
      "partType": "horse_tail",
      "tags": ["anatomy:part"]
    }
  ]
}
```

**Why This Pattern Works**:
- Single limb set with mixed orientations
- `orientation: "arm_*"` filters human arms from horse legs
- Properties make each limb type functionally distinct

**Complete Example**: See `data/mods/core/recipes/examples/centaur-hybrid.recipe.json`

## Pattern Selection Decision Tree

```
What anatomy are you creating?
├─ Radially symmetric (spider, octopus)
│  ├─ All identical → Use matchesGroup on limbSet
│  └─ Some specialized → Use matchesAll with socketId patterns
│
├─ Quadrupedal (horse, dog, cat)
│  ├─ Front/rear different → Use matchesAll with orientation: "*_front" / "*_rear"
│  └─ All legs identical → Use matchesGroup on limbSet
│
├─ Flying (dragon, pegasus)
│  ├─ Wings separate → Use matchesGroup for wings
│  ├─ Legs differentiated → Use matchesAll with orientation
│  └─ Unique parts → Use explicit slots
│
├─ Hybrid (centaur, drider)
│  ├─ Human/animal parts → Use matchesAll with orientation filters
│  ├─ Upper/lower body split → Use orientation: "arm_*" vs "leg_*"
│  └─ Merged features → Combine multiple pattern types
│
└─ Unique creature
   └─ Start with structure template → Add patterns by complexity level
```

## Best Practices by Creature Type

### Arachnids (Spiders, Scorpions)

**Recommended Approach**:
1. Use `limbSets` with `radial` orientation for legs
2. Use `matchesGroup` for uniform legs
3. Use `matchesAll` with `socketId` for specialized legs (if needed)
4. Add appendages for unique parts (pedipalps, tail)

**Example Structure**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 8,
        "orientationScheme": "radial"
      }
    ],
    "appendages": [
      { "id": "cephalothorax" },
      { "id": "abdomen" },
      { "id": "pedipalp_left" },
      { "id": "pedipalp_right" }
    ]
  }
}
```

### Avians (Birds, Winged Creatures)

**Recommended Approach**:
1. Use bilateral limb sets for wings
2. Use explicit slots or bilateral for legs (usually 2)
3. Differentiate flight wings from display wings if needed

**Example Structure**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "wing",
        "count": 2,
        "orientationScheme": "bilateral",
        "requirements": {
          "partType": "flight_wing"
        }
      },
      {
        "id": "leg",
        "count": 2,
        "orientationScheme": "bilateral",
        "requirements": {
          "partType": "talon"
        }
      }
    ]
  }
}
```

### Serpentine (Snakes, Worms)

**Recommended Approach**:
1. Use appendages for head/tail only
2. Body segments as properties rather than slots
3. No limb sets needed

**Example Structure**:
```json
{
  "structureTemplate": {
    "appendages": [
      { "id": "head", "orientationScheme": "singular" },
      { "id": "tail", "orientationScheme": "singular" }
    ]
  }
}
```

**Recipe Pattern**:
```json
{
  "patterns": [
    {
      "matchesGroup": "appendage:head",
      "partType": "snake_head",
      "tags": ["anatomy:part", "anatomy:venomous"],
      "properties": {
        "anatomy:venomous": {
          "venomType": "hemotoxic",
          "potency": "high"
        }
      }
    }
  ],
  "bodyDescriptors": {
    "segmentCount": 200,
    "flexibility": "extreme",
    "scales": "overlapping"
  }
}
```

## Advanced Filtering Techniques

### Combining Multiple Filters

**Pattern**: Apply multiple filters with AND logic
```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "*_front",
    "socketId": "quadruped_*"
  }
}
```

**Effect**: Only matches slots that satisfy ALL three conditions
- Must be type "leg"
- Must have front orientation
- Must use quadruped socket system

**Complete Example**: See `data/mods/core/recipes/examples/property-filters/combined-filters.recipe.json`

### Excluding Specific Slots

**Pattern**: Filter by property but exclude specific slots
```json
{
  "matchesAll": {
    "slotType": "tentacle"
  },
  "exclude": ["tentacle_specialized"],
  "partType": "standard_tentacle"
}
```

**Use Case**: Most tentacles are standard, but one is specialized

### Socket-Based Specialization

**Pattern**: Different anatomy per socket system
```json
{
  "patterns": [
    {
      "matchesAll": {
        "socketId": "combat_socket_*"
      },
      "partType": "combat_limb"
    },
    {
      "matchesAll": {
        "socketId": "utility_socket_*"
      },
      "partType": "utility_limb"
    }
  ]
}
```

**Use Case**: Mechanical creatures with different socket systems

## Common Mistakes and Solutions

### Mistake: Over-Specifying Filters

❌ **Wrong**:
```json
{
  "matchesAll": {
    "slotType": "leg",
    "orientation": "leg_front_left"
  }
}
```

✅ **Right**:
```json
{
  "matches": ["leg_front_left"]
}
```

**Reason**: Use explicit slots for single specific slots. Property filters are for matching multiple slots.

### Mistake: Forgetting Wildcard Patterns

❌ **Wrong**:
```json
{
  "matchesAll": {
    "orientation": "front"
  }
}
```

✅ **Right**:
```json
{
  "matchesAll": {
    "orientation": "*_front"
  }
}
```

**Reason**: Orientation is typically "leg_front_left", not just "front". Use wildcards to match the full value.

### Mistake: Not Using Structure Templates

❌ **Wrong**:
```json
{
  "slots": {
    "leg_1": { "requirements": { "partType": "leg" } },
    "leg_2": { "requirements": { "partType": "leg" } },
    "leg_3": { "requirements": { "partType": "leg" } },
    "leg_4": { "requirements": { "partType": "leg" } }
  }
}
```

✅ **Right**:
```json
{
  "structureTemplate": {
    "limbSets": [
      {
        "id": "leg",
        "count": 4,
        "orientationScheme": "quadrupedal",
        "requirements": { "partType": "leg" }
      }
    ]
  }
}
```

**Reason**: Structure templates generate slots automatically and integrate perfectly with property-based filtering.

## Performance Considerations

### Filter Efficiency

**Most Efficient** (exact match):
```json
{ "slotType": "leg" }
```

**Moderately Efficient** (single wildcard):
```json
{ "orientation": "*_front" }
```

**Less Efficient** (multiple wildcards):
```json
{ "socketId": "*_combat_*" }
```

**Recommendation**: Use the most specific filter possible. Combine `slotType` (exact) with wildcard filters for best performance.

### Pattern Order Optimization

Patterns are evaluated in order. Put most specific patterns first:

```json
{
  "patterns": [
    {
      "matches": ["special_limb"],
      "partType": "unique_part"
    },
    {
      "matchesAll": {
        "slotType": "limb",
        "socketId": "combat_*"
      },
      "partType": "combat_limb"
    },
    {
      "matchesGroup": "limbSet:limb",
      "partType": "standard_limb"
    }
  ]
}
```

Order: Explicit slots → Property filters → Group matches → Pattern wildcards

## Testing Your Patterns

### Validation Checklist

1. **Blueprint generates expected slots**
   - Check structure template count/orientation
   - Verify socket naming matches your filters

2. **Filters match intended slots**
   - Test with different slot configurations
   - Verify exclude lists work correctly

3. **Properties are valid**
   - All referenced components/tags exist
   - Property schemas validate

4. **No conflicts between patterns**
   - Each slot matched by exactly one pattern
   - Or intentionally multiple patterns (later wins)

### Debugging Filters

Enable recipe resolution logging to see which slots match:

```javascript
// In RecipePatternResolver
console.log('Matched slots for pattern:', matchedKeys);
```

Common issues:
- **No matches**: Check wildcard syntax, verify slot names
- **Wrong slots matched**: Review filter specificity
- **Missing slots**: Ensure structure template generates them

## References

- **Implementation**: `src/anatomy/recipePatternResolver.js` (lines 346-395)
- **Schema**: `data/schemas/anatomy.recipe.schema.json` (lines 299-318)
- **Examples Directory**: `data/mods/core/recipes/examples/`
- **Structure Templates**: `docs/anatomy/structure-templates.md`
- **Blueprint V2**: `docs/anatomy/blueprints-v2.md`
- **Recipe Patterns**: `docs/anatomy/recipe-patterns.md`

## Next Steps

1. **Start Simple**: Begin with basic `slotType` filters
2. **Add Orientation**: Use wildcards for front/rear differentiation
3. **Specialize with SocketId**: Create socket-based limb systems
4. **Combine Approaches**: Mix pattern types for complex creatures
5. **Test Thoroughly**: Validate with various slot configurations

For more detailed information:
- Property-based filtering examples: `docs/anatomy/property-based-filtering-examples.md`
- Migration from V1 patterns: `docs/anatomy/v1-to-v2-pattern-migration.md`
- Best practices: `docs/anatomy/pattern-matching-best-practices.md`
