// src/ai/thoughtPersistenceHook.js

/**
 * @file Persist the "thoughts" generated by an LLM turn.
 * @see src/ai/thoughtPersistenceHook.js
 */

import ShortTermMemoryService from './shortTermMemoryService.js';
import { SHORT_TERM_MEMORY_COMPONENT_ID } from '../constants/componentIds.js';
import ComponentAccessService from '../entities/componentAccessService.js';
import { safeDispatchError } from '../utils/safeDispatchErrorUtils.js';
import { isNonBlankString } from '../utils/textUtils.js';

/**
 * Persist the “thoughts” produced during an LLM turn into the actor’s
 * short-term-memory component.
 *
 * Works with a full Entity instance *or* a plain-object pseudo-entity.
 *
 * @param {object} action       – The structured action returned by the LLM.
 * @param {object} actorEntity  – Entity instance (or test double) that generated the action.
 * @param {object} logger       – Application-wide logger (expects .warn()).
 * @param {import('../interfaces/ISafeEventDispatcher.js').ISafeEventDispatcher} [dispatcher]
 *   – Optional dispatcher for error events.
 * @param {ShortTermMemoryService} [stmService] – Optional STM service instance.
 * @param {Date} [now] – Date provider for timestamping.
 * @param componentAccess
 */
export function persistThoughts(
  action,
  actorEntity,
  logger,
  dispatcher,
  stmService = new ShortTermMemoryService(),
  now = new Date(),
  componentAccess = new ComponentAccessService()
) {
  /* ── 1. Validate thoughts ───────────────────────────────────────────── */
  const rawThoughts = action?.thoughts;
  if (!isNonBlankString(rawThoughts)) {
    logger.warn('STM-001 Missing thoughts');
    if (dispatcher) {
      safeDispatchError(
        dispatcher,
        "ThoughtPersistenceHook: 'thoughts' field is missing or blank; skipping persist",
        { actorId: actorEntity?.id ?? 'UNKNOWN_ACTOR' }
      );
    }
    return;
  }
  const thoughtText = String(rawThoughts).trim();

  /* ── 2. Retrieve STM component via the public API ───────────────────── */
  const memoryComp = componentAccess.fetchComponent(
    actorEntity,
    SHORT_TERM_MEMORY_COMPONENT_ID
  );

  if (!memoryComp) {
    logger.warn('STM-002 Missing component');
    return; // nothing to persist
  }

  /* ── 3. Mutate in place using the service ───────────────────────────── */
  const { mem: updatedMem } = stmService.addThought(
    memoryComp,
    thoughtText,
    now
  );

  /* ── 4. Push the mutation back to the entity ────────────────────────── */
  componentAccess.applyComponent(
    actorEntity,
    SHORT_TERM_MEMORY_COMPONENT_ID,
    updatedMem
  );
}
