/**
 * @file SlotGenerator - Generates slot definitions from structure template patterns
 * @see docs/anatomy/structure-templates.md
 * @see workflows/ANABLUNONHUM-008-slot-generator.md
 */

import { validateDependency } from '../utils/dependencyUtils.js';

/**
 * Service to generate slot definitions from structure template limbSet/appendage patterns.
 * Applies template variables and orientation schemes to create slot configurations.
 *
 * CRITICAL: Slot keys must exactly match socket IDs generated by SocketGenerator.
 * This service uses identical template variable resolution logic to ensure synchronization.
 *
 * @example
 * const slots = slotGenerator.generateBlueprintSlots(structureTemplate);
 * // Returns: { leg_left: { socket: 'leg_left', requirements: {...}, optional: false }, ... }
 */
class SlotGenerator {
  #logger;

  /**
   * Creates a new SlotGenerator instance.
   *
   * @param {object} dependencies - Service dependencies
   * @param {object} dependencies.logger - Logger instance
   */
  constructor({ logger }) {
    validateDependency(logger, 'ILogger', logger, {
      requiredMethods: ['debug', 'info', 'warn', 'error'],
    });

    this.#logger = logger;
  }

  /**
   * Generates blueprint slot definitions from a structure template.
   * Processes both limbSets and appendages to create complete slot object.
   *
   * @param {object} structureTemplate - Structure template with topology definition
   * @param {object} structureTemplate.topology - Topology configuration
   * @param {Array<object>} [structureTemplate.topology.limbSets] - Limb set definitions
   * @param {Array<object>} [structureTemplate.topology.appendages] - Appendage definitions
   * @returns {object} Object mapping slot keys to slot definitions
   * @throws {Error} If template structure is invalid
   */
  generateBlueprintSlots(structureTemplate) {
    if (!structureTemplate || !structureTemplate.topology) {
      throw new Error(
        'Invalid structure template: missing topology definition'
      );
    }

    const slots = {};
    const generatedSlotKeys = [];
    const { limbSets = [], appendages = [] } = structureTemplate.topology;

    this.#logger.debug(
      `SlotGenerator: Generating slots from template with ${limbSets.length} limb sets and ${appendages.length} appendages`
    );

    // Process each limbSet
    for (const limbSet of limbSets) {
      const limbSlots = this.#generateSlotsFromLimbSet(limbSet);

      for (const [slotKey, slotDefinition] of Object.entries(limbSlots)) {
        generatedSlotKeys.push(slotKey);
        slots[slotKey] = slotDefinition;
      }
    }

    // Process each appendage
    for (const appendage of appendages) {
      const appendageSlots = this.#generateSlotsFromAppendage(appendage);

      for (const [slotKey, slotDefinition] of Object.entries(appendageSlots)) {
        generatedSlotKeys.push(slotKey);
        slots[slotKey] = slotDefinition;
      }
    }

    // Validate uniqueness
    this.#validateSlotUniqueness(generatedSlotKeys);

    this.#logger.info(
      `SlotGenerator: Generated ${Object.keys(slots).length} slots successfully`
    );

    return slots;
  }

  /**
   * Extracts slot keys from a limb set (for pattern resolution)
   * @param {object} limbSet - Limb set definition
   * @returns {string[]} Array of slot keys
   */
  extractSlotKeysFromLimbSet(limbSet) {
    const { count, socketPattern, arrangement } = limbSet;
    const keys = [];

    for (let index = 1; index <= count; index++) {
      const slotKey = this.#generateSlotKey(
        socketPattern,
        index,
        count,
        arrangement
      );
      keys.push(slotKey);
    }

    return keys;
  }

  /**
   * Extracts slot keys from an appendage (for pattern resolution)
   * @param {object} appendage - Appendage definition
   * @returns {string[]} Array of slot keys
   */
  extractSlotKeysFromAppendage(appendage) {
    const { count, socketPattern } = appendage;
    const keys = [];

    for (let index = 1; index <= count; index++) {
      const slotKey = this.#generateSlotKey(socketPattern, index, count);
      keys.push(slotKey);
    }

    return keys;
  }

  /**
   * Generates slots from a limb set definition
   *
   * @param {object} limbSet - Limb set configuration
   * @param {string} limbSet.type - Type of limb (e.g., 'leg', 'arm')
   * @param {number} limbSet.count - Number of limbs to generate
   * @param {object} limbSet.socketPattern - Socket generation pattern
   * @param {boolean} [limbSet.optional] - Whether limbs are optional
   * @param {string} [limbSet.arrangement] - Spatial arrangement type
   * @returns {object} Object mapping slot keys to slot definitions
   * @private
   */
  generateSlotsFromLimbSet(limbSet) {
    const slots = {};
    const { type, count, socketPattern, optional = false, arrangement } = limbSet;

    for (let index = 1; index <= count; index++) {
      const slotKey = this.#generateSlotKey(
        socketPattern,
        index,
        count,
        arrangement
      );
      slots[slotKey] = this.#createSlotDefinition(
        type,
        slotKey,
        optional
      );
    }

    return slots;
  }

  /**
   * Generates slots from an appendage definition
   *
   * @param {object} appendage - Appendage configuration
   * @param {string} appendage.type - Type of appendage (e.g., 'head', 'tail')
   * @param {number} appendage.count - Number of appendages to generate
   * @param {object} appendage.socketPattern - Socket generation pattern
   * @param {boolean} [appendage.optional] - Whether appendage is optional
   * @returns {object} Object mapping slot keys to slot definitions
   * @private
   */
  generateSlotsFromAppendage(appendage) {
    const slots = {};
    const { type, count, socketPattern, optional = false } = appendage;

    for (let index = 1; index <= count; index++) {
      const slotKey = this.#generateSlotKey(socketPattern, index, count);
      slots[slotKey] = this.#createSlotDefinition(
        type,
        slotKey,
        optional
      );
    }

    return slots;
  }

  /**
   * Creates a slot definition
   *
   * @param {string} partType - The type of part required for this slot
   * @param {string} slotKey - The slot key (must match socket ID)
   * @param {boolean} optional - Whether this slot is optional
   * @returns {object} Slot definition with socket, requirements, and optional flag
   * @private
   */
  #createSlotDefinition(partType, slotKey, optional) {
    return {
      socket: slotKey, // Slot key must match socket ID from SocketGenerator
      requirements: {
        partType,
        components: ['anatomy:part'],
      },
      optional,
    };
  }

  /**
   * Generates slot key by applying template variables.
   * MUST use same logic as SocketGenerator.#applyTemplate to ensure matching IDs.
   *
   * @param {object} socketPattern - Socket generation pattern
   * @param {string} socketPattern.idTemplate - Template for socket ID
   * @param {string} [socketPattern.orientationScheme] - Orientation scheme to use
   * @param {Array<string>} socketPattern.allowedTypes - Allowed part types
   * @param {Array<string>} [socketPattern.positions] - Explicit positions for custom/radial schemes
   * @param {number} index - Current index (1-based)
   * @param {number} totalCount - Total count of items in set
   * @param {string} [arrangement] - Arrangement type for context
   * @returns {string} Generated slot key
   * @private
   */
  #generateSlotKey(
    socketPattern,
    index,
    totalCount,
    arrangement = null
  ) {
    const { idTemplate, orientationScheme, allowedTypes, positions } =
      socketPattern;

    // Resolve orientation using same logic as SocketGenerator
    const orientation = this.#resolveOrientation(
      orientationScheme,
      index,
      totalCount,
      positions,
      arrangement
    );

    // Build variable context
    const variables = {
      index,
      orientation,
      position: orientation, // position is alias for orientation
      type: allowedTypes && allowedTypes[0] ? allowedTypes[0] : 'part',
    };

    // Apply template (must match SocketGenerator's logic exactly)
    return this.#applyTemplate(idTemplate, variables);
  }

  /**
   * Resolves orientation based on orientation scheme.
   * MUST match SocketGenerator's orientation resolution logic exactly.
   *
   * @param {string} scheme - Orientation scheme (bilateral, radial, indexed, custom)
   * @param {number} index - Current index (1-based)
   * @param {number} totalCount - Total count of items in set
   * @param {Array<string>} [positions] - Explicit positions for custom/radial schemes
   * @param {string} [arrangement] - Arrangement type for context
   * @returns {string} Resolved orientation string
   * @private
   */
  #resolveOrientation(
    scheme = 'indexed',
    index,
    totalCount,
    positions = null,
    arrangement = null
  ) {
    switch (scheme) {
      case 'bilateral':
        return this.#resolveBilateralOrientation(
          index,
          totalCount,
          arrangement
        );

      case 'radial':
        return this.#resolveRadialOrientation(index, totalCount, positions);

      case 'custom':
        return this.#resolveCustomOrientation(index, positions);

      case 'indexed':
      default:
        return String(index);
    }
  }

  /**
   * Resolves bilateral orientation (left/right pairs).
   * For quadrupedal arrangements, produces left_front, right_front, left_rear, right_rear.
   * MUST match SocketGenerator's bilateral logic.
   *
   * @param {number} index - Current index (1-based)
   * @param {number} totalCount - Total count of items
   * @param {string} [arrangement] - Arrangement type
   * @returns {string} Bilateral orientation
   * @private
   */
  #resolveBilateralOrientation(index, totalCount, arrangement = null) {
    // For quadrupedal arrangement (4 legs)
    if (arrangement === 'quadrupedal' && totalCount === 4) {
      const positions = ['left_front', 'right_front', 'left_rear', 'right_rear'];
      return positions[index - 1] || 'mid';
    }

    // Standard bilateral: alternate left/right
    // Odd indices = left, even indices = right
    const side = index % 2 === 1 ? 'left' : 'right';

    // For pairs, just return left/right
    if (totalCount === 2) {
      return side;
    }

    // For larger sets, we might need position qualifiers
    // But for now, just alternate left/right
    return side;
  }

  /**
   * Resolves radial orientation (circular arrangement).
   * Uses positions array if provided, otherwise generates position names.
   * MUST match SocketGenerator's radial logic.
   *
   * @param {number} index - Current index (1-based)
   * @param {number} totalCount - Total count of items
   * @param {Array<string>} [positions] - Explicit position names
   * @returns {string} Radial position name
   * @private
   */
  #resolveRadialOrientation(index, totalCount, positions = null) {
    if (positions && positions.length > 0) {
      // Use explicit positions array (0-based indexing)
      return positions[index - 1] || `position_${index}`;
    }

    // Generate default radial positions based on count
    // For common counts, use named positions
    if (totalCount === 8) {
      const octagonalPositions = [
        'anterior',
        'anterior_right',
        'right',
        'posterior_right',
        'posterior',
        'posterior_left',
        'left',
        'anterior_left',
      ];
      return octagonalPositions[index - 1] || `position_${index}`;
    }

    // Default: use generic position naming
    return `position_${index}`;
  }

  /**
   * Resolves custom orientation using explicit positions array.
   * MUST match SocketGenerator's custom logic.
   *
   * @param {number} index - Current index (1-based)
   * @param {Array<string>} [positions] - Explicit position names
   * @returns {string} Position name from array
   * @private
   */
  #resolveCustomOrientation(index, positions = null) {
    if (!positions || positions.length === 0) {
      this.#logger.warn(
        `SlotGenerator: Custom orientation scheme used without positions array, falling back to index ${index}`
      );
      return `position_${index}`;
    }

    return positions[index - 1] || `position_${index}`;
  }

  /**
   * Applies template variables to a template string.
   * Replaces {{variable}} placeholders with actual values.
   * MUST match SocketGenerator's template application logic exactly.
   *
   * @param {string} template - Template string with {{variable}} placeholders
   * @param {object} variables - Variable values to substitute
   * @param {number} [variables.index] - Index variable
   * @param {string} [variables.orientation] - Orientation variable
   * @param {string} [variables.position] - Position variable
   * @param {string} [variables.type] - Type variable
   * @returns {string} Template with variables replaced
   * @private
   */
  #applyTemplate(template, variables) {
    let result = template;

    // Replace each variable
    for (const [key, value] of Object.entries(variables)) {
      const placeholder = `{{${key}}}`;
      result = result.replace(new RegExp(placeholder, 'g'), String(value));
    }

    return result;
  }

  /**
   * Validates that all slot keys are unique
   *
   * @param {Array<string>} slotKeys - Array of slot keys generated during processing
   * @throws {Error} If duplicate slot keys are found
   * @private
   */
  #validateSlotUniqueness(slotKeys) {
    const seen = new Set();
    const duplicates = [];

    for (const key of slotKeys) {
      if (seen.has(key)) {
        duplicates.push(key);
      } else {
        seen.add(key);
      }
    }

    if (duplicates.length > 0) {
      throw new Error(
        `SlotGenerator: Duplicate slot keys detected: ${duplicates.join(', ')}`
      );
    }
  }
}

export default SlotGenerator;
