/**
 * @file SlotGenerator - Generates slot definitions from structure template patterns
 * @see docs/anatomy/structure-templates.md
 * @see workflows/ANABLUNONHUM-008-slot-generator.md
 */

import { validateDependency } from '../utils/dependencyUtils.js';
import { OrientationResolver } from './shared/orientationResolver.js';

/**
 * Service to generate slot definitions from structure template limbSet/appendage patterns.
 * Applies template variables and orientation schemes to create slot configurations.
 *
 * CRITICAL: Slot keys must exactly match socket IDs generated by SocketGenerator.
 * This service uses identical template variable resolution logic to ensure synchronization.
 *
 * @example
 * const slots = slotGenerator.generateBlueprintSlots(structureTemplate);
 * // Returns: { leg_left: { socket: 'leg_left', requirements: {...}, optional: false }, ... }
 */
class SlotGenerator {
  #logger;

  /**
   * Creates a new SlotGenerator instance.
   *
   * @param {object} dependencies - Service dependencies
   * @param {object} dependencies.logger - Logger instance
   */
  constructor({ logger }) {
    validateDependency(logger, 'ILogger', logger, {
      requiredMethods: ['debug', 'info', 'warn', 'error'],
    });

    this.#logger = logger;
  }

  /**
   * Generates blueprint slot definitions from a structure template.
   * Processes both limbSets and appendages to create complete slot object.
   *
   * @param {object} structureTemplate - Structure template with topology definition
   * @param {object} structureTemplate.topology - Topology configuration
   * @param {Array<object>} [structureTemplate.topology.limbSets] - Limb set definitions
   * @param {Array<object>} [structureTemplate.topology.appendages] - Appendage definitions
   * @returns {object} Object mapping slot keys to slot definitions
   * @throws {Error} If template structure is invalid
   */
  generateBlueprintSlots(structureTemplate) {
    if (!structureTemplate || !structureTemplate.topology) {
      throw new Error(
        'Invalid structure template: missing topology definition'
      );
    }

    const slots = {};
    const generatedSlotKeys = [];
    const { limbSets = [], appendages = [] } = structureTemplate.topology;

    this.#logger.debug(
      `SlotGenerator: Generating slots from template with ${limbSets.length} limb sets and ${appendages.length} appendages`
    );

    // Process each limbSet
    for (const limbSet of limbSets) {
      const limbSlots = this.#generateSlotsFromLimbSet(limbSet);

      for (const [slotKey, slotDefinition] of Object.entries(limbSlots)) {
        generatedSlotKeys.push(slotKey);
        slots[slotKey] = slotDefinition;
      }
    }

    // Process each appendage
    for (const appendage of appendages) {
      const appendageSlots = this.#generateSlotsFromAppendage(appendage);

      for (const [slotKey, slotDefinition] of Object.entries(appendageSlots)) {
        generatedSlotKeys.push(slotKey);
        slots[slotKey] = slotDefinition;
      }
    }

    // Validate uniqueness
    this.#validateSlotUniqueness(generatedSlotKeys);

    this.#logger.info(
      `SlotGenerator: Generated ${Object.keys(slots).length} slots successfully`
    );

    return slots;
  }

  /**
   * Extracts slot keys from a limb set (for pattern resolution)
   *
   * @param {object} limbSet - Limb set definition
   * @returns {string[]} Array of slot keys
   */
  extractSlotKeysFromLimbSet(limbSet) {
    const { count, socketPattern, arrangement } = limbSet;
    const keys = [];

    for (let index = 1; index <= count; index++) {
      const slotKey = this.#generateSlotKey(
        socketPattern,
        index,
        count,
        arrangement
      );
      keys.push(slotKey);
    }

    return keys;
  }

  /**
   * Extracts slot keys from an appendage (for pattern resolution)
   *
   * @param {object} appendage - Appendage definition
   * @returns {string[]} Array of slot keys
   */
  extractSlotKeysFromAppendage(appendage) {
    const { count, socketPattern } = appendage;
    const keys = [];

    for (let index = 1; index <= count; index++) {
      const slotKey = this.#generateSlotKey(socketPattern, index, count);
      keys.push(slotKey);
    }

    return keys;
  }

  /**
   * Generates slots from a limb set definition
   *
   * @param {object} limbSet - Limb set configuration
   * @param {string} limbSet.type - Type of limb (e.g., 'leg', 'arm')
   * @param {number} limbSet.count - Number of limbs to generate
   * @param {object} limbSet.socketPattern - Socket generation pattern
   * @param {boolean} [limbSet.optional] - Whether limbs are optional
   * @param {string} [limbSet.arrangement] - Spatial arrangement type
   * @returns {object} Object mapping slot keys to slot definitions
   * @private
   */
  #generateSlotsFromLimbSet(limbSet) {
    const slots = {};
    const {
      type,
      count,
      socketPattern,
      optional = false,
      arrangement,
    } = limbSet;

    for (let index = 1; index <= count; index++) {
      // Generate slot key (also determines orientation)
      const slotKey = this.#generateSlotKey(
        socketPattern,
        index,
        count,
        arrangement
      );

      // Calculate orientation for this slot using shared resolver
      const orientation = OrientationResolver.resolveOrientation(
        socketPattern.orientationScheme,
        index,
        count,
        socketPattern.positions,
        arrangement
      );

      slots[slotKey] = this.#createSlotDefinition(
        type,
        slotKey,
        optional,
        orientation
      );
    }

    return slots;
  }

  /**
   * Generates slots from an appendage definition
   *
   * @param {object} appendage - Appendage configuration
   * @param {string} appendage.type - Type of appendage (e.g., 'head', 'tail')
   * @param {number} appendage.count - Number of appendages to generate
   * @param {object} appendage.socketPattern - Socket generation pattern
   * @param {boolean} [appendage.optional] - Whether appendage is optional
   * @returns {object} Object mapping slot keys to slot definitions
   * @private
   */
  #generateSlotsFromAppendage(appendage) {
    const slots = {};
    const { type, count, socketPattern, optional = false } = appendage;

    for (let index = 1; index <= count; index++) {
      // Generate slot key (also determines orientation)
      const slotKey = this.#generateSlotKey(socketPattern, index, count);

      // Calculate orientation for this slot using shared resolver
      const orientation = OrientationResolver.resolveOrientation(
        socketPattern.orientationScheme,
        index,
        count,
        socketPattern.positions
      );

      slots[slotKey] = this.#createSlotDefinition(
        type,
        slotKey,
        optional,
        orientation
      );
    }

    return slots;
  }

  /**
   * Creates a slot definition
   *
   * @param {string} partType - The type of part required for this slot
   * @param {string} slotKey - The slot key (must match socket ID)
   * @param {boolean} optional - Whether this slot is optional
   * @param {string|null} [orientation] - The orientation of this slot (for pattern matching), defaults to null
   * @returns {object} Slot definition with socket, requirements, optional flag, and orientation
   * @private
   */
  #createSlotDefinition(partType, slotKey, optional, orientation = null) {
    const slotDef = {
      socket: slotKey, // Slot key must match socket ID from SocketGenerator
      requirements: {
        partType,
        components: ['anatomy:part'],
      },
      optional,
    };

    // Include orientation if provided (for pattern matching)
    if (orientation !== null) {
      slotDef.orientation = orientation;
    }

    return slotDef;
  }

  /**
   * Generates slot key by applying template variables.
   * MUST use same logic as SocketGenerator.#applyTemplate to ensure matching IDs.
   *
   * @param {object} socketPattern - Socket generation pattern
   * @param {string} socketPattern.idTemplate - Template for socket ID
   * @param {string} [socketPattern.orientationScheme] - Orientation scheme to use
   * @param {Array<string>} socketPattern.allowedTypes - Allowed part types
   * @param {Array<string>} [socketPattern.positions] - Explicit positions for custom/radial schemes
   * @param {number} index - Current index (1-based)
   * @param {number} totalCount - Total count of items in set
   * @param {string} [arrangement] - Arrangement type for context
   * @returns {string} Generated slot key
   * @private
   */
  #generateSlotKey(socketPattern, index, totalCount, arrangement = null) {
    const { idTemplate, orientationScheme, allowedTypes, positions } =
      socketPattern;

    // Resolve orientation using shared OrientationResolver
    const orientation = OrientationResolver.resolveOrientation(
      orientationScheme,
      index,
      totalCount,
      positions,
      arrangement
    );

    // Warn about custom scheme without positions (helpful for mod developers)
    if (
      orientationScheme === 'custom' &&
      (!positions || positions.length === 0)
    ) {
      this.#logger.warn(
        'SlotGenerator: Custom orientation scheme used without positions array. ' +
          'Falling back to indexed positions. Provide positions array for proper naming.'
      );
    }

    // Build variable context
    const variables = {
      index,
      orientation,
      position: orientation, // position is alias for orientation
      type: allowedTypes && allowedTypes[0] ? allowedTypes[0] : 'part',
    };

    // Apply template (must match SocketGenerator's logic exactly)
    return this.#applyTemplate(idTemplate, variables);
  }

  /**
   * Applies template variables to a template string.
   * Replaces {{variable}} placeholders with actual values.
   * MUST match SocketGenerator's template application logic exactly.
   *
   * @param {string} template - Template string with {{variable}} placeholders
   * @param {object} variables - Variable values to substitute
   * @param {number} [variables.index] - Index variable
   * @param {string} [variables.orientation] - Orientation variable
   * @param {string} [variables.position] - Position variable
   * @param {string} [variables.type] - Type variable
   * @returns {string} Template with variables replaced
   * @private
   */
  #applyTemplate(template, variables) {
    let result = template;

    // Replace each variable
    for (const [key, value] of Object.entries(variables)) {
      const placeholder = `{{${key}}}`;
      result = result.replace(new RegExp(placeholder, 'g'), String(value));
    }

    return result;
  }

  /**
   * Validates that all slot keys are unique
   *
   * @param {Array<string>} slotKeys - Array of slot keys generated during processing
   * @throws {Error} If duplicate slot keys are found
   * @private
   */
  #validateSlotUniqueness(slotKeys) {
    const seen = new Set();
    const duplicates = [];

    for (const key of slotKeys) {
      if (seen.has(key)) {
        duplicates.push(key);
      } else {
        seen.add(key);
      }
    }

    if (duplicates.length > 0) {
      throw new Error(
        `SlotGenerator: Duplicate slot keys detected: ${duplicates.join(', ')}`
      );
    }
  }
}

export default SlotGenerator;
