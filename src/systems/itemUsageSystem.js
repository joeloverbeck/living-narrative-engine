// src/systems/itemUsageSystem.js

// Component Imports (Ensure all necessary components are imported)
import {InventoryComponent} from '../components/inventoryComponent.js';
import {HealthComponent} from '../components/healthComponent.js';
import {PositionComponent} from '../components/positionComponent.js';
// Import ConnectionsComponent to retrieve connection object
import {ConnectionsComponent} from '../components/connectionsComponent.js';

// Utilities
import {findTarget} from '../utils/targetFinder.js'; // Potentially needed for contextual search if implemented
import {TARGET_MESSAGES, getDisplayName} from '../utils/messages.js';

// Type Imports for JSDoc
/** @typedef {import('../../eventBus.js').default} EventBus */
/** @typedef {import('../entities/entityManager.js').default} EntityManager */
/** @typedef {import('../../dataManager.js').default} DataManager */
/** @typedef {import('../entities/entity.js').default} Entity */
/** @typedef {import('../components/connectionsComponent.js').Connection} Connection */ // Added Connection type
/** @typedef {import('../events/eventTypes.js').ItemUseAttemptedEventPayload} ItemUseAttemptedEventPayload */
/** @typedef {import('../actions/actionTypes.js').ActionMessage} ActionMessage */
/** @typedef {import('../../data/schemas/item.schema.json').definitions.UsableComponent} UsableComponentData */
/** @typedef {import('../../data/schemas/item.schema.json').definitions.ConditionObject} ConditionObjectData */
/** @typedef {import('../../data/schemas/item.schema.json').definitions.EffectObject} EffectObjectData */


/**
 * Context object passed to effect handlers.
 * @typedef {object} EffectContext
 * @property {Entity} userEntity - The entity using the item.
 * @property {Entity | Connection | null} target - The validated target (Entity or Connection object, null if not applicable).
 * @property {EntityManager} entityManager - For accessing/modifying components.
 * @property {EventBus} eventBus - For dispatching events and UI messages.
 * @property {DataManager} dataManager - For accessing entity definitions if needed.
 * @property {UsableComponentData} usableComponentData - The full data of the UsableComponent being processed.
 * @property {string} itemName - The display name of the item being used.
 */

/**
 * Result object returned by effect handlers.
 * @typedef {object} EffectResult
 * @property {boolean} success - Did the effect apply successfully according to its own logic?
 * @property {ActionMessage[]} [messages] - Optional messages generated by the handler (for logging or specific feedback).
 * @property {boolean} [stopPropagation=false] - If true, indicates this effect failure should prevent subsequent effects in the array from processing.
 */

/**
 * Type definition for an effect handler function.
 * @typedef {(params: object, context: EffectContext) => EffectResult} EffectHandlerFunction
 */


/**
 * ECS System responsible for handling the logic of using items.
 * Reads item behavior from UsableComponent data in item definitions.
 * Listens for event:item_use_attempted to trigger logic.
 */
class ItemUsageSystem {
    #eventBus;
    #entityManager;
    #dataManager;
    // #gameStateManager; // Future

    /** @type {Map<string, EffectHandlerFunction>} */
    #effectHandlers = new Map();

    /**
     * @param {object} options
     * @param {EventBus} options.eventBus
     * @param {EntityManager} options.entityManager
     * @param {DataManager} options.dataManager
     * // @param {GameStateManager} options.gameStateManager
     */
    constructor({eventBus, entityManager, dataManager}) {
        if (!eventBus) throw new Error("ItemUsageSystem requires options.eventBus.");
        if (!entityManager) throw new Error("ItemUsageSystem requires options.entityManager.");
        if (!dataManager) throw new Error("ItemUsageSystem requires options.dataManager.");

        this.#eventBus = eventBus;
        this.#entityManager = entityManager;
        this.#dataManager = dataManager;

        this.#registerEffectHandlers(); // Populate the effect handler registry

        this.#eventBus.subscribe(
            'event:item_use_attempted',
            this._handleItemUseAttempt.bind(this) // Use bind to maintain 'this' context
        );

        console.log("ItemUsageSystem: Instance created and subscribed to event:item_use_attempted.");
    }

    /**
     * Registers handlers for known effect types.
     * @private
     */
    #registerEffectHandlers() {
        // Register REAL handlers using arrow functions bound to the instance
        // Ensure these handlers use context.eventBus for UI messages.
        this.#effectHandlers.set('heal', this.#handleHealEffect);
        this.#effectHandlers.set('trigger_event', this.#handleTriggerEventEffect);
        this.#effectHandlers.set('apply_status_effect', this.#handleApplyStatusEffectStub);
        this.#effectHandlers.set('damage', this.#handleDamageEffectStub);
        this.#effectHandlers.set('spawn_entity', this.#handleSpawnEntityEffectStub);
        this.#effectHandlers.set('remove_status_effect', this.#handleRemoveStatusEffectStub);

        console.log(`ItemUsageSystem: Registered ${this.#effectHandlers.size} effect handlers.`);
    }

    // ========================================================================
    // == EVENT HANDLER =======================================================
    // ========================================================================

    /**
     * Handles the event:item_use_attempted event, implementing core usage logic.
     * Retrieves entities/connections, validates conditions, handles targeting, executes effects,
     * consumes the item, and provides feedback via the EventBus.
     *
     * @param {ItemUseAttemptedEventPayload} payload - The event data.
     * @private
     */
    _handleItemUseAttempt(payload) {
        console.log(`ItemUsageSystem: Received event:item_use_attempted`, payload);

        const {
            userEntityId,
            itemInstanceId,
            itemDefinitionId,
            explicitTargetEntityId,
            explicitTargetConnectionId // Added connection ID
        } = payload;
        /** @type {ActionMessage[]} */
        const internalMessages = []; // For logging the process of this handler

        // --- 1. Retrieve Entities & Definitions ---
        const userEntity = this.#entityManager.getEntityInstance(userEntityId);
        const itemInstance = this.#entityManager.getEntityInstance(itemInstanceId); // The specific instance
        const itemDefinition = this.#dataManager.getEntityDefinition(itemDefinitionId); // The template data

        // --- 2. Basic Validation (Entities exist?) ---
        // (Validation remains the same)
        if (!userEntity) {
            console.error(`ItemUsageSystem: User entity ${userEntityId} not found. Cannot process use attempt.`);
            return;
        }
        if (!itemInstance) {
            console.error(`ItemUsageSystem: Item instance ${itemInstanceId} not found. Cannot process use attempt.`);
            return;
        }
        if (!itemDefinition) {
            console.error(`ItemUsageSystem: Item definition ${itemDefinitionId} not found. Cannot process use attempt.`);
            this.#eventBus.dispatch('ui:message_display', {text: "Error: Item definition is missing.", type: 'error'});
            return;
        }

        // Use item instance for name, fallback to definition if needed
        const itemName = getDisplayName(itemInstance) ?? itemDefinition?.components?.Name?.value ?? "the item";

        // --- 3. Check if the item has a Usable component ---
        /** @type {UsableComponentData | undefined} */
        const usableComponentData = itemDefinition.components?.Usable;
        if (!usableComponentData) {
            console.warn(`ItemUsageSystem: Item ${itemDefinitionId} (${itemName}) definition lacks Usable component.`);
            this.#eventBus.dispatch('ui:message_display', {text: `You cannot use ${itemName}.`, type: 'info'});
            return;
        }

        // --- 4. Check Usability Conditions (User) ---
        const usabilityCheckResult = this._checkConditions(
            userEntity, // Entity to check conditions against
            userEntity, // User entity context (might be same as entityToCheck)
            null,       // Target context (null for usability checks)
            usableComponentData.usability_conditions,
            usableComponentData,
            itemName,
            this.#eventBus, // Pass the whole event bus
            'Usability'
        );
        internalMessages.push(...usabilityCheckResult.messages);
        if (!usabilityCheckResult.success) {
            console.log(`ItemUsageSystem: Usability conditions failed for ${itemName}.`);
            return; // Stop processing, feedback already sent
        }

        // --- 5. Handle Targeting ---
        let validatedTarget = null; // Can be Entity or Connection object
        let targetType = 'none'; // 'entity', 'connection', or 'none'

        if (usableComponentData.target_required) {
            internalMessages.push({
                text: `Target required for ${itemName}. Explicit Entity ID: ${explicitTargetEntityId}, Connection ID: ${explicitTargetConnectionId}`,
                type: 'internal'
            });

            let potentialTarget = null; // Can be Entity or Connection object

            // --- 5a. Prioritize Explicit Connection Target ---
            if (explicitTargetConnectionId) {
                const userPos = userEntity.getComponent(PositionComponent);
                const currentLocation = userPos ? this.#entityManager.getEntityInstance(userPos.locationId) : null;
                const connectionsComp = currentLocation?.getComponent(ConnectionsComponent);
                potentialTarget = connectionsComp?.getConnectionById(explicitTargetConnectionId);

                if (!potentialTarget) {
                    console.warn(`ItemUsageSystem: Explicit target connection ${explicitTargetConnectionId} not found in location ${currentLocation?.id}.`);
                    this.#eventBus.dispatch('ui:message_display', {
                        text: "The targeted connection is no longer valid.", // More specific message
                        type: 'warning'
                    });
                    return;
                }
                targetType = 'connection';
                internalMessages.push({
                    text: `Found potential explicit target: CONNECTION ${potentialTarget.name || potentialTarget.direction} (${potentialTarget.connectionId})`,
                    type: 'internal'
                });

                // --- 5b. Use Explicit Entity Target if No Connection Target ---
            } else if (explicitTargetEntityId) {
                potentialTarget = this.#entityManager.getEntityInstance(explicitTargetEntityId);
                if (!potentialTarget) {
                    console.warn(`ItemUsageSystem: Explicit target entity ${explicitTargetEntityId} not found.`);
                    this.#eventBus.dispatch('ui:message_display', {
                        text: "The target you specified is no longer valid.", // Generic message
                        type: 'warning'
                    });
                    return;
                }
                targetType = 'entity';
                internalMessages.push({
                    text: `Found potential explicit target: ENTITY ${getDisplayName(potentialTarget)} (${potentialTarget.id})`,
                    type: 'internal'
                });
            } else {
                // --- 5c. No Explicit Target Provided ---
                // TODO: Implement contextual search if needed (e.g., "use potion" might target self or nearest enemy).
                // For now, strictly require an explicit target if target_required is true.
                internalMessages.push({
                    text: `Target required, but no explicit target entity OR connection ID was provided.`,
                    type: 'internal'
                });
                this.#eventBus.dispatch('ui:message_display', {
                    // Use the item's specific requirement message if available
                    text: usableComponentData.failure_message_default || TARGET_MESSAGES.USE_REQUIRES_TARGET(itemName),
                    type: 'warning'
                });
                return;
            }

            // --- 5d. Validate the Found Potential Target ---
            if (potentialTarget) {
                // Prepare context for condition checking
                const targetCheckContext = targetType === 'entity' ? potentialTarget : null; // Pass entity context only if target is entity
                const connectionCheckContext = targetType === 'connection' ? potentialTarget : null; // Pass connection context only if target is connection

                const targetCheckResult = this._checkConditions(
                    potentialTarget,       // The object conditions are checked against (Entity or Connection)
                    userEntity,            // User entity context
                    targetCheckContext,    // Entity target context
                    connectionCheckContext,// Connection target context
                    usableComponentData.target_conditions,
                    usableComponentData,
                    itemName,
                    this.#eventBus,
                    'Target'
                );
                internalMessages.push(...targetCheckResult.messages);

                if (!targetCheckResult.success) {
                    // _checkConditions dispatched UI failure message
                    const targetName = targetType === 'entity' ? getDisplayName(potentialTarget) : (potentialTarget.name || potentialTarget.direction);
                    console.log(`ItemUsageSystem: Target conditions failed for ${targetType} '${targetName}'.`);
                    return; // Stop processing
                }

                // Target is valid!
                validatedTarget = potentialTarget;
                const validatedTargetName = targetType === 'entity' ? getDisplayName(validatedTarget) : (validatedTarget.name || validatedTarget.direction);
                internalMessages.push({
                    text: `Target ${targetType} '${validatedTargetName}' validated successfully.`,
                    type: 'internal'
                });

            } else {
                // This case should ideally not be reached if logic above is correct.
                // It means target required, explicit target specified, but resolution failed earlier.
                internalMessages.push({
                    text: `Failed validation step, required target not found/resolved.`,
                    type: 'internal'
                });
                // Assume appropriate feedback was given by resolver. If not, add fallback.
                const defaultFailMsg = usableComponentData.failure_message_default || TARGET_MESSAGES.USE_INVALID_TARGET(itemName);
                // Avoid double-messaging if resolver already sent one.
                if (!internalMessages.some(m => m.type === 'error' || m.type === 'warning')) { // Basic check
                    this.#eventBus.dispatch('ui:message_display', {text: defaultFailMsg, type: 'warning'});
                }
                return;
            }
        } else {
            internalMessages.push({text: `No target required for ${itemName}.`, type: 'internal'});
            // No target required, validatedTarget remains null, targetType remains 'none'
        }


        // --- 6. Execute the Effects Loop ---
        let overallEffectsSuccess = true;
        let effectsProcessed = false;

        if (usableComponentData.effects && usableComponentData.effects.length > 0) {
            // --- 6a. Create EffectContext ---
            /** @type {EffectContext} */
            const effectContext = {
                userEntity: userEntity,
                target: validatedTarget, // Pass the validated target (Entity or Connection)
                entityManager: this.#entityManager,
                eventBus: this.#eventBus,
                dataManager: this.#dataManager,
                usableComponentData: usableComponentData,
                itemName: itemName
            };
            internalMessages.push({text: `Executing effects loop for ${itemName}...`, type: 'internal'});

            // --- 6b. Iterate through effects ---
            for (const effect of usableComponentData.effects) {
                effectsProcessed = true;
                /** @type {EffectObjectData} */
                const effectData = effect;
                const handler = this.#effectHandlers.get(effectData.effect_type);

                if (handler) {
                    try {
                        internalMessages.push({text: `Executing effect: ${effectData.effect_type}`, type: 'internal'});
                        const result = handler(effectData.effect_params, effectContext);
                        internalMessages.push(...(result.messages || []));

                        if (!result.success) {
                            internalMessages.push({
                                text: `Effect ${effectData.effect_type} reported failure. StopPropagation: ${result.stopPropagation}`,
                                type: 'internal'
                            });
                            // Check if failure message was provided by effect handler, otherwise use default
                            if (!result.messages?.some(m => m.type === 'error' || m.type === 'warning')) {
                                const defaultFailMsg = usableComponentData.failure_message_default || `Using ${itemName} failed.`;
                                // Only dispatch if effect didn't provide its own user-facing message.
                                this.#eventBus.dispatch('ui:message_display', {text: defaultFailMsg, type: 'warning'});
                            }

                            if (result.stopPropagation) {
                                overallEffectsSuccess = false;
                                break; // Stop processing further effects
                            }
                            // If stopPropagation is false, consider action partially successful, continue effects
                        } else {
                            internalMessages.push({
                                text: `Effect ${effectData.effect_type} reported success.`,
                                type: 'internal'
                            });
                        }
                    } catch (error) {
                        console.error(`ItemUsageSystem: Error executing effect handler '${effectData.effect_type}' for ${itemName}:`, error);
                        internalMessages.push({
                            text: `CRITICAL ERROR executing effect ${effectData.effect_type}. ${error.message}`,
                            type: 'error'
                        });
                        overallEffectsSuccess = false;
                        this.#eventBus.dispatch('ui:message_display', {
                            text: `An error occurred while using ${itemName}.`,
                            type: 'error'
                        });
                        break;
                    }
                } else {
                    console.warn(`ItemUsageSystem: No registered effect handler found for type: ${effectData.effect_type} in item ${itemName}. Skipping effect.`);
                    internalMessages.push({
                        text: `Unknown effect type '${effectData.effect_type}'. Skipping.`,
                        type: 'warning'
                    });
                }
            }
            internalMessages.push({
                text: `Effects loop finished. Overall Success: ${overallEffectsSuccess}`,
                type: 'internal'
            });

        } else {
            internalMessages.push({text: `No effects defined for ${itemName}.`, type: 'internal'});
            // If no effects, the action is still considered "successful" if conditions passed
        }

        // --- 7. Handle Item Consumption ---
        if (overallEffectsSuccess && usableComponentData.consume_on_use) {
            const inventoryComponent = userEntity.getComponent(InventoryComponent);
            if (inventoryComponent) {
                const removed = inventoryComponent.removeItem(itemInstanceId);
                if (removed) {
                    internalMessages.push({
                        text: `Consumed item instance ${itemInstanceId} (${itemName}).`,
                        type: 'internal'
                    });
                    console.log(`ItemUsageSystem: Consumed item instance ${itemInstanceId} (${itemName}) from ${userEntityId}'s inventory.`);
                } else {
                    console.warn(`ItemUsageSystem: Failed to remove item instance ${itemInstanceId} (${itemName}) during consumption for user ${userEntityId}. Item might have already been removed.`);
                    internalMessages.push({
                        text: `Attempted to consume instance ${itemInstanceId}, but it was not found in inventory.`,
                        type: 'warning'
                    });
                }
            } else {
                console.error(`ItemUsageSystem: User ${userEntityId} lacks InventoryComponent. Cannot consume item ${itemInstanceId}.`);
                internalMessages.push({text: `User missing inventory component, cannot consume item.`, type: 'error'});
            }
        } else {
            internalMessages.push({
                text: `Item consumption skipped. EffectsSuccess=${overallEffectsSuccess}, ConsumeFlag=${usableComponentData.consume_on_use}`,
                type: 'internal'
            });
        }

        // --- 8. Provide Final Feedback ---
        // (Feedback logic remains largely the same, relies on overallEffectsSuccess)
        if (overallEffectsSuccess) {
            const successMsg = usableComponentData.success_message;
            if (successMsg) {
                this.#eventBus.dispatch('ui:message_display', {text: successMsg, type: 'info'});
                internalMessages.push({text: `Dispatched custom success message: "${successMsg}"`, type: 'internal'});
            } else if (effectsProcessed) {
                const targetName = validatedTarget
                    ? (targetType === 'entity' ? `the ${getDisplayName(validatedTarget)}` : `the ${validatedTarget.name || validatedTarget.direction}`)
                    : '';
                const fallbackMsg = targetName ? `You use the ${itemName} on ${targetName}.` : `You use the ${itemName}.`;
                this.#eventBus.dispatch('ui:message_display', {text: fallbackMsg, type: 'info'});
                internalMessages.push({text: `Dispatched generic success message: "${fallbackMsg}"`, type: 'internal'});
            } else {
                internalMessages.push({
                    text: `Overall success, but no effects processed and no success message defined.`,
                    type: 'internal'
                });
            }
        } else {
            internalMessages.push({
                text: `Overall action failed or was stopped. Final success feedback skipped.`,
                type: 'internal'
            });
            // Failure feedback should ideally be handled by condition checks or failing effect handlers.
            // Avoid dispatching a default failure message here if a specific one was likely sent.
        }

        // --- Log Internal Messages ---
        console.log("ItemUsageSystem: _handleItemUseAttempt processing complete.");
        internalMessages.forEach(msg => console.debug(`  [${msg.type}] ${msg.text}`));
    }

    // ========================================================================
    // == EFFECT HANDLERS =====================================================
    // ========================================================================

    /**
     * Handles the 'heal' effect type.
     * Updated to correctly identify target from context.target which might be non-Entity.
     * @type {EffectHandlerFunction}
     */
    #handleHealEffect = (params, context) => {
        const messages = [];
        const {userEntity, target, entityManager, eventBus, itemName} = context; // Use generic 'target'
        const {
            amount,
            target: targetSpecifier = 'user', // 'user' or 'target'
            fail_if_already_max = false
        } = params ?? {};

        // 1. Validate Parameters
        if (typeof amount !== 'number' || amount <= 0) {
            const errorMsg = `Invalid 'amount' parameter (${amount}) for 'heal' effect in item ${itemName}.`;
            console.error(`ItemUsageSystem: ${errorMsg}`);
            messages.push({text: `Internal Error: ${itemName} heal effect misconfigured.`, type: 'error'});
            // Dispatch error via eventBus? Maybe too noisy for config errors.
            // eventBus.dispatch('ui:message_display', { text: `Error: ${itemName} is configured incorrectly.`, type: 'error' });
            return {success: false, messages: messages, stopPropagation: true};
        }

        // 2. Identify Target Entity for Healing
        let actualTargetEntity = null;
        if (targetSpecifier === 'target') {
            // Check if the context target is an entity
            // Need a way to distinguish Entity from Connection, e.g., check for 'id' vs 'connectionId'? Or instanceof?
            // Assuming Entity has an 'id' property and Connection does not directly, or use a type guard if available.
            if (target && typeof target.getComponent === 'function') { // Basic check for Entity-like object
                actualTargetEntity = /** @type {Entity} */ (target);
            } else {
                console.warn(`ItemUsageSystem: Heal effect specified 'target', but context target is not an entity. Item: ${itemName}, Target:`, target);
                eventBus.dispatch('ui:message_display', {text: `The ${itemName} cannot heal that.`, type: 'info'});
                return {
                    success: false,
                    messages: [{text: 'Heal target is not an entity.', type: 'internal'}],
                    stopPropagation: false
                }; // Non-critical failure usually
            }
        } else { // targetSpecifier === 'user'
            actualTargetEntity = userEntity;
        }

        if (!actualTargetEntity) {
            const errorMsg = `Could not determine target ('${targetSpecifier}') for 'heal' effect in item ${itemName}. Context Target: ${targetEntity?.id}`;
            console.error(`ItemUsageSystem: ${errorMsg}`);
            messages.push({text: `Internal Error: Could not apply heal from ${itemName}.`, type: 'error'});
            // Use eventBus for generic failure
            eventBus.dispatch('ui:message_display', {text: `Couldn't apply healing from ${itemName}.`, type: 'error'});
            return {success: false, messages: messages, stopPropagation: true}; // Stop if target invalid
        }

        const targetName = getDisplayName(actualTargetEntity);

        // 3. Access Target's HealthComponent
        const healthComponent = actualTargetEntity.getComponent(HealthComponent);
        if (!healthComponent) {
            const errorMsg = `Target ${targetName} (${actualTargetEntity.id}) lacks HealthComponent for 'heal' effect from ${itemName}.`;
            console.warn(`ItemUsageSystem: ${errorMsg}`);
            messages.push({text: `${itemName} has no effect on ${targetName}.`, type: 'internal'});
            // Use eventBus for user feedback
            eventBus.dispatch('ui:message_display', {
                text: `${targetName} cannot be healed by the ${itemName}.`,
                type: 'info'
            });
            return {success: false, messages: messages}; // Cannot heal non-health target
        }

        // 4. Check Health Status & Apply Healing
        const currentHealth = healthComponent.current;
        const maxHealth = healthComponent.max;
        const isFullHealth = currentHealth >= maxHealth;

        if (isFullHealth) {
            const feedbackMsg = `${targetName}'s health is already full.`;
            messages.push({text: feedbackMsg, type: 'internal'});

            // Use eventBus for user feedback
            eventBus.dispatch('ui:message_display', {text: feedbackMsg, type: 'info'});

            if (fail_if_already_max) {
                return {success: false, messages: messages, stopPropagation: true}; // Fail and stop
            } else {
                return {success: true, messages: messages}; // Succeed (no effect) and continue
            }
        }

        // Apply healing
        const oldHealth = currentHealth;
        healthComponent.current = Math.min(maxHealth, oldHealth + amount);
        const actualHeal = healthComponent.current - oldHealth;

        // 7. Provide Feedback via EventBus
        const healMsg = `${targetName} recovered ${actualHeal} health.`;
        messages.push({text: healMsg, type: 'success'});
        eventBus.dispatch('ui:message_display', {text: healMsg, type: 'success'});

        // 8. Return Success
        return {success: true, messages: messages};
    };

    /**
     * Handles the 'trigger_event' effect type.
     * Updated to correctly identify targetId based on context.target type.
     * @type {EffectHandlerFunction}
     */
    #handleTriggerEventEffect = (params, context) => {
        const messages = [];
        const {eventBus, userEntity, target, itemName, entityManager} = context; // Use generic 'target'
        const {
            event_name,
            event_payload = {},
            feedback_message
        } = params ?? {};

        // 1. Validate Parameters
        if (typeof event_name !== 'string' || event_name.trim() === '') {
            return {success: false, messages: messages, stopPropagation: true};
        }
        if (typeof event_payload !== 'object' || event_payload === null) {
            return {success: false, messages: messages, stopPropagation: true};
        }

        // 2. Construct Final Event Payload
        let targetId = null;
        let targetType = 'none';
        if (target && typeof target.getComponent === 'function') { // Entity check
            targetId = target.id;
            targetType = 'entity';
        } else if (target && target.connectionId) { // Connection check
            targetId = target.connectionId; // Use connectionId as the ID
            targetType = 'connection';
        }

        const finalEventPayload = {
            ...event_payload, // Include properties from the item's effect_payload
            userId: userEntity.id,
            // Include target info based on type, adjust if downstream systems expect specific fields
            targetId: targetId, // Could be entity ID or connection ID
            targetType: targetType, // Explicitly pass type
            sourceItemId: itemDefinitionId, // Pass definition ID for consistency? Or instance ID? Or name? Using definitionId for now.
            // Note: The original key item definition passed keyId: "demo:item_key" which is definition ID.
        };

        // Specifically for connection_unlock_attempt, ensure locationId is present
        if (event_name === 'event:connection_unlock_attempt') {
            const positionComponent = userEntity.getComponent(PositionComponent);
            if (positionComponent?.locationId) {
                finalEventPayload.locationId = positionComponent.locationId;
                messages.push({
                    text: `Added locationId (${finalEventPayload.locationId}) for event:connection_unlock_attempt.`,
                    type: 'internal'
                });
            } else {
                console.warn(`ItemUsageSystem: User ${userEntity.id} lacks PositionComponent or locationId when triggering ${event_name}. LocationId will be missing from payload.`);
                messages.push({text: `User ${userEntity.id} missing locationId for ${event_name}.`, type: 'warning'});
                finalEventPayload.locationId = null;
            }

            // Ensure connectionId is correctly populated from target if not already in event_payload
            if (!finalEventPayload.connectionId && targetType === 'connection' && targetId) {
                finalEventPayload.connectionId = targetId;
                messages.push({text: `Added connectionId (${targetId}) from context target.`, type: 'internal'});
            }

            // Verify required fields from event_payload defined in the item are present
            if (!finalEventPayload.connectionId) {
                console.error(`ItemUsageSystem: Missing 'connectionId' in payload for ${event_name} triggered by ${itemName}. Context Target:`, target);
                messages.push({text: `CRITICAL: Missing connectionId for ${event_name}.`, type: 'error'});
                // Consider failing the effect
                // return {success: false, messages: messages, stopPropagation: true};
            }
            if (!finalEventPayload.keyId) {
                // keyId should be the ID of the item being used
                finalEventPayload.keyId = itemInstanceId; // Use instance ID of the key
                messages.push({text: `Added keyId (${itemInstanceId}) from item context.`, type: 'internal'});
            }
        }


        // 3. Dispatch Event via context.eventBus
        try {
            console.debug(`ItemUsageSystem: Dispatching event '${event_name}' via EventBus for item ${itemName}. Payload:`, finalEventPayload);
            eventBus.dispatch(event_name, finalEventPayload);
            messages.push({text: `Dispatched event '${event_name}' for ${itemName}.`, type: 'internal'});
        } catch (error) {
            const errorMsg = `Error dispatching event '${event_name}' for item ${itemName}: ${error.message}`;
            console.error(`ItemUsageSystem: ${errorMsg}`, error);
            messages.push({text: `Internal Error: Failed to dispatch event for ${itemName}.`, type: 'error'});
            // Dispatch UI error via eventBus
            eventBus.dispatch('ui:message_display', {
                text: `An error occurred triggering an effect from ${itemName}.`,
                type: 'error'
            });
            return {success: false, messages: messages, stopPropagation: true};
        }

        // 4. Optional Feedback via context.eventBus (feedback logic remains the same) [cite: 283]
        if (typeof feedback_message === 'string' && feedback_message.trim() !== '') {
            console.debug(`ItemUsageSystem: Triggering feedback message for ${itemName}: "${feedback_message}"`);
            eventBus.dispatch('ui:message_display', {text: feedback_message, type: 'info'}); // Use eventBus for UI feedback
            messages.push({text: `Dispatched feedback message: "${feedback_message}"`, type: 'internal'});
        }

        // 5. Return Success
        return {success: true, messages: messages};
    };

    // --- Stub Handlers ---
    /** @type {EffectHandlerFunction} */
    #handleApplyStatusEffectStub = (params, context) => { /* ... */
        return {
            success: true,
            messages: [{text: `Apply_status_effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }
    /** @type {EffectHandlerFunction} */
    #handleDamageEffectStub = (params, context) => { /* ... */
        return {
            success: true,
            messages: [{text: `Damage effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }
    /** @type {EffectHandlerFunction} */
    #handleSpawnEntityEffectStub = (params, context) => { /* ... */
        return {
            success: true,
            messages: [{text: `Spawn_entity effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }
    /** @type {EffectHandlerFunction} */
    #handleRemoveStatusEffectStub = (params, context) => { /* ... */
        return {
            success: true,
            messages: [{text: `Remove_status_effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }


    // ========================================================================
    // == CONDITION CHECKING HELPER ===========================================
    // ========================================================================

    /**
     * Checks if the conditions (usability or target) are met.
     * Dispatches UI messages on failure using the provided EventBus instance.
     * Updated to receive potential connection context.
     *
     * @param {Entity | Connection} objectToCheck - The entity or connection object the conditions are evaluated against.
     * @param {Entity} userEntity - The entity initiating the action.
     * @param {Entity | null} targetEntityContext - The target if it's an entity.
     * @param {Connection | null} targetConnectionContext - The target if it's a connection.
     * @param {ConditionObjectData[] | undefined} conditions - The array of conditions to check.
     * @param {UsableComponentData} usableData - The Usable component data for fallback messages.
     * @param {string} itemName - The display name of the item being used.
     * @param {EventBus} eventBus - The event bus instance for dispatching UI messages.
     * @param {'Usability' | 'Target'} checkType - Context for logging/errors.
     * @returns {{success: boolean, messages: ActionMessage[]}} - Result indicating if conditions passed.
     * @private
     */
    _checkConditions(objectToCheck, userEntity, targetEntityContext, targetConnectionContext, conditions, usableData, itemName, eventBus, checkType) {
        /** @type {ActionMessage[]} */
        const messages = [];

        if (!conditions || conditions.length === 0) {
            return {
                success: true,
                messages: [{text: `No ${checkType} conditions to check for ${itemName}.`, type: "internal"}]
            };
        }

        // Determine name of the object being checked for logging
        let objectName = 'unknown object';
        if (typeof objectToCheck?.getComponent === 'function') { // Is Entity?
            objectName = getDisplayName(objectToCheck);
        } else if (objectToCheck?.connectionId) { // Is Connection?
            objectName = objectToCheck.name || objectToCheck.direction || objectToCheck.connectionId;
        }

        messages.push({
            text: `Checking ${checkType} conditions for ${itemName} against ${objectName}...`,
            type: 'internal'
        })

        for (const condition of conditions) {
            // Evaluate the core condition logic
            let conditionMet = this._evaluateCondition(objectToCheck, userEntity, targetEntityContext, targetConnectionContext, condition);
            const negate = condition.negate ?? false;
            let finalConditionMet = negate ? !conditionMet : conditionMet;

            if (!finalConditionMet) {
                // Determine appropriate failure message
                let failureMsg = condition.failure_message;
                if (!failureMsg) {
                    const defaultUsabilityFail = usableData.failure_message_default || TARGET_MESSAGES.USE_CONDITION_FAILED(itemName);
                    const defaultTargetFail = usableData.failure_message_default || TARGET_MESSAGES.USE_INVALID_TARGET(itemName);
                    failureMsg = (checkType === 'Target') ? defaultTargetFail : defaultUsabilityFail;
                }

                // Use the EventBus for immediate condition failure feedback
                eventBus.dispatch('ui:message_display', {text: failureMsg, type: 'warning'});
                messages.push({
                    text: `${checkType} Condition Check Failed for ${itemName}: Type='${condition.condition_type}', Negated=${negate}, Reason='${failureMsg}'`,
                    type: 'internal'
                });
                return {success: false, messages}; // Stop checking on the first failure
            } else {
                messages.push({
                    text: `${checkType} Condition Check Passed for ${itemName}: Type='${condition.condition_type}', Negated=${negate}`,
                    type: 'internal'
                });
            }
        }

        // If loop completes, all conditions passed
        messages.push({text: `All ${checkType} conditions passed for ${itemName}.`, type: 'internal'})
        return {success: true, messages};
    }

    /**
     * Evaluates a single condition object against the target object (Entity or Connection), user entity, and context.
     * Handles property access carefully for different object types.
     *
     * @param {Entity | Connection} objectToCheck - The object the condition applies to.
     * @param {Entity} userEntity - The entity initiating the action.
     * @param {Entity | null} targetEntityContext - The target if it's an entity.
     * @param {Connection | null} targetConnectionContext - The target if it's a connection.
     * @param {ConditionObjectData} condition - The condition data object.
     * @returns {boolean} - True if the condition is met, false otherwise.
     * @private
     */
    _evaluateCondition(objectToCheck, userEntity, targetEntityContext, targetConnectionContext, condition) {
        const conditionType = condition.condition_type;

        // Helper to safely get properties from either Entity (via components) or Connection (direct access)
        const getProperty = (obj, path) => {
            if (!obj || !path) return undefined;
            const parts = path.split('.');
            let current = obj;
            for (const part of parts) {
                if (current === null || typeof current === 'undefined') return undefined;

                // Check if current object is an Entity to access components
                if (typeof current.getComponent === 'function') {
                    // Special case for direct entity properties like 'id' maybe?
                    if (part === 'id') {
                        current = current.id;
                        continue; // Move to next part if path is deeper e.g., id.something (unlikely)
                    }
                    // Assume the part is a Component name
                    const component = current.getComponent(part); // This needs mapping from name string to class
                    // Problem: componentRegistry is needed here, or pass ComponentClass directly?
                    // Let's assume for now path refers to direct properties or simple component values
                    // A better approach might be needed for deep component paths e.g., 'HealthComponent.max'
                    console.warn(`ItemUsageSystem: Accessing component '${part}' by name in condition property path is not robustly implemented. Assuming direct property access.`);
                    current = undefined; // Fail for now if component access needed this way

                } else {
                    // Assume direct property access for Connection objects or nested properties
                    current = current[part];
                }
            }
            return current;
        };

        // Helper for nested property access using a path string (e.g., "HealthComponent.current")
        // NOTE: This simple version only handles direct properties or top-level component existence.
        // A more robust version would need access to Component classes/registry.
        // For the specific case of target_has_property with connection target, direct access is fine.
        const getNestedProperty = (obj, propertyPath) => {
            if (!obj || !propertyPath) return undefined;
            const pathParts = propertyPath.split('.');
            let current = obj;
            for (const part of pathParts) {
                if (current === null || typeof current === 'undefined') return undefined;

                // If 'current' is an Entity, try getting component if part matches a known component pattern
                if (typeof current.getComponent === 'function') {
                    // Very basic check: if part ends with 'Component'
                    if (part.endsWith('Component')) {
                        // Need component registry access here... For now, we can't reliably get component by string name.
                        // Let's handle the simple 'connectionId' and 'state' cases expected for connections.
                        console.warn(`ItemUsageSystem: Accessing component '${part}' in property path is not fully supported.`);
                        return undefined; // Cannot resolve component by string name here
                    }
                    // Fallback to direct property access (like 'id')
                    current = current[part];

                } else {
                    // If not an entity, assume direct property access
                    current = current[part];
                }
            }
            return current;
        };


        // Parameter getter functions (remain the same logic)
        const getNumberParam = (paramName, defaultValue = null) => { /* ... */
        };
        const getStringParam = (paramName, defaultValue = null) => { /* ... */
        };
        const getValueParam = (paramName) => { /* ... */
        };


        switch (conditionType) {
            // --- Conditions primarily about the USER ---
            case 'player_in_location': { // Renamed from player_state for clarity
                const requiredLocationId = getStringParam('locationId');
                if (requiredLocationId === null) return false;
                const userPosComp = userEntity.getComponent(PositionComponent);
                return userPosComp?.locationId === requiredLocationId;
            }
            case 'player_state': { // Kept for other player states if needed
                const requiredState = getStringParam('state');
                if (requiredState === null) return false;
                // TODO: Implement check against player state flags/components
                console.warn(`ItemUsageSystem: Condition type 'player_state' ('${requiredState}') not implemented. Assuming false.`);
                return false;
            }

            // --- Conditions about the TARGET (Entity or Connection) ---
            case 'target_has_component': { // Primarily for Entity targets
                const componentName = getStringParam('component_name');
                if (componentName === null) return false;
                // Only check if objectToCheck is likely an Entity
                if (typeof objectToCheck?.hasComponent !== 'function') {
                    console.warn(`ItemUsageSystem: Condition 'target_has_component' used on non-entity target. Condition fails.`);
                    return false;
                }
                // Need component registry access here
                // const ComponentClass = this.#entityManager.componentRegistry.get(componentName);
                // if (!ComponentClass) { ... return false; }
                // return objectToCheck.hasComponent(ComponentClass);
                console.warn(`ItemUsageSystem: Condition 'target_has_component' requires component registry access (not implemented here). Assuming false.`);
                return false;
            }

            case 'target_has_property': { // Useful for both Entity and Connection
                const propertyPath = getStringParam('property_path');
                const expectedValue = getValueParam('expected_value');
                if (propertyPath === null || typeof expectedValue === 'undefined') return false;

                // Use the nested property getter
                const actualValue = getNestedProperty(objectToCheck, propertyPath);

                // Comparison logic (strict equality for now)
                return actualValue === expectedValue;
            }

            case 'target_distance': { // Primarily between Entities
                const maxDistance = getNumberParam('max_distance');
                const minDistance = getNumberParam('min_distance', 0);
                if (maxDistance === null || maxDistance < 0 || minDistance < 0 || maxDistance < minDistance) return false;

                // Ensure objectToCheck is an Entity
                if (typeof objectToCheck?.getComponent !== 'function') {
                    console.warn(`ItemUsageSystem: Condition 'target_distance' used on non-entity target. Condition fails.`);
                    return false;
                }
                if (objectToCheck === userEntity) return 0 >= minDistance && 0 <= maxDistance; // Distance to self is 0

                const userPosComp = userEntity.getComponent(PositionComponent);
                const targetPosComp = objectToCheck.getComponent(PositionComponent);
                if (!userPosComp || !targetPosComp || userPosComp.locationId !== targetPosComp.locationId) return false; // Must be in same location

                const dx = (userPosComp.x ?? 0) - (targetPosComp.x ?? 0);
                const dy = (userPosComp.y ?? 0) - (targetPosComp.y ?? 0);
                const distanceSq = dx * dx + dy * dy;
                return distanceSq >= (minDistance * minDistance) && distanceSq <= (maxDistance * maxDistance);
            }

            case 'health_below_max': { // Primarily for Entities
                if (typeof objectToCheck?.getComponent !== 'function') return false; // Not an entity
                const healthComponent = objectToCheck.getComponent(HealthComponent);
                if (!healthComponent) return false;
                return healthComponent.current < healthComponent.max;
            }

            case 'has_status_effect': { // Primarily for Entities
                if (typeof objectToCheck?.getComponent !== 'function') return false;
                const effectId = getStringParam('effect_id');
                if (effectId === null) return false;
                // TODO: Check StatusEffectsComponent on objectToCheck
                console.warn(`ItemUsageSystem: Condition type 'has_status_effect' ('${effectId}') not implemented. Assuming false.`);
                return false;
            }

            case 'attribute_check': { // Primarily for Entities
                if (typeof objectToCheck?.getComponent !== 'function') return false;
                const attributeId = getStringParam('attribute_id');
                const comparison = getStringParam('comparison'); // e.g., '>=', '<', '=='
                const value = getValueParam('value');
                if (attributeId === null || comparison === null || typeof value === 'undefined') return false;
                // TODO: Get attribute value from AttributeComponent on objectToCheck and compare
                console.warn(`ItemUsageSystem: Condition type 'attribute_check' ('${attributeId} ${comparison} ${value}') not implemented. Assuming false.`);
                return false;
            }


            default:
                console.warn(`ItemUsageSystem: Encountered unknown condition_type '${conditionType}'. Assuming condition fails.`);
                return false;
        }
    }

}

export default ItemUsageSystem;
