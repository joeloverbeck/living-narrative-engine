// src/systems/itemUsageSystem.js

// Component Imports (Ensure all necessary components are imported)
import {InventoryComponent} from '../components/inventoryComponent.js';
import {HealthComponent} from '../components/healthComponent.js';
import {PositionComponent} from '../components/positionComponent.js';

// Utilities
import {findTarget} from '../utils/targetFinder.js'; // Potentially needed for contextual search if implemented
import {TARGET_MESSAGES, getDisplayName} from '../utils/messages.js';

// Type Imports for JSDoc
/** @typedef {import('../../eventBus.js').default} EventBus */
/** @typedef {import('../entities/entityManager.js').default} EntityManager */
/** @typedef {import('../../dataManager.js').default} DataManager */
/** @typedef {import('../entities/entity.js').default} Entity */
/** @typedef {import('../events/eventTypes.js').ItemUseAttemptedEventPayload} ItemUseAttemptedEventPayload */
/** @typedef {import('../actions/actionTypes.js').ActionMessage} ActionMessage */
/** @typedef {import('../../data/schemas/item.schema.json').definitions.UsableComponent} UsableComponentData */
/** @typedef {import('../../data/schemas/item.schema.json').definitions.ConditionObject} ConditionObjectData */
/** @typedef {import('../../data/schemas/item.schema.json').definitions.EffectObject} EffectObjectData */


/**
 * Context object passed to effect handlers.
 * @typedef {object} EffectContext
 * @property {Entity} userEntity - The entity using the item.
 * @property {Entity | null} targetEntity - The validated target entity (null if not applicable).
 * @property {EntityManager} entityManager - For accessing/modifying components.
 * @property {EventBus} eventBus - For dispatching events and UI messages.
 * @property {DataManager} dataManager - For accessing entity definitions if needed.
 * @property {UsableComponentData} usableComponentData - The full data of the UsableComponent being processed.
 * @property {string} itemName - The display name of the item being used.
 * // Removed 'dispatch' property as per refactoring requirements.
 */

/**
 * Result object returned by effect handlers.
 * @typedef {object} EffectResult
 * @property {boolean} success - Did the effect apply successfully according to its own logic?
 * @property {ActionMessage[]} [messages] - Optional messages generated by the handler (for logging or specific feedback).
 * @property {boolean} [stopPropagation=false] - If true, indicates this effect failure should prevent subsequent effects in the array from processing.
 */

/**
 * Type definition for an effect handler function.
 * @typedef {(params: object, context: EffectContext) => EffectResult} EffectHandlerFunction
 */


/**
 * ECS System responsible for handling the logic of using items.
 * Reads item behavior from UsableComponent data in item definitions.
 * Listens for event:item_use_attempted to trigger logic.
 */
class ItemUsageSystem {
    #eventBus;
    #entityManager;
    #dataManager;
    // #gameStateManager; // Future

    /** @type {Map<string, EffectHandlerFunction>} */
    #effectHandlers = new Map();

    /**
     * @param {object} options
     * @param {EventBus} options.eventBus
     * @param {EntityManager} options.entityManager
     * @param {DataManager} options.dataManager
     * // @param {GameStateManager} options.gameStateManager
     */
    constructor({eventBus, entityManager, dataManager}) {
        if (!eventBus) throw new Error("ItemUsageSystem requires options.eventBus.");
        if (!entityManager) throw new Error("ItemUsageSystem requires options.entityManager.");
        if (!dataManager) throw new Error("ItemUsageSystem requires options.dataManager.");

        this.#eventBus = eventBus;
        this.#entityManager = entityManager;
        this.#dataManager = dataManager;
        // this.#gameStateManager = gameStateManager;

        this.#registerEffectHandlers(); // Populate the effect handler registry

        this.#eventBus.subscribe(
            'event:item_use_attempted',
            this._handleItemUseAttempt.bind(this) // Use bind to maintain 'this' context
        );

        console.log("ItemUsageSystem: Instance created and subscribed to event:item_use_attempted.");
    }

    /**
     * Registers handlers for known effect types.
     * @private
     */
    #registerEffectHandlers() {
        // Register REAL handlers using arrow functions bound to the instance
        // Ensure these handlers use context.eventBus for UI messages.
        this.#effectHandlers.set('heal', this.#handleHealEffect);
        this.#effectHandlers.set('trigger_event', this.#handleTriggerEventEffect);
        this.#effectHandlers.set('apply_status_effect', this.#handleApplyStatusEffectStub);
        this.#effectHandlers.set('damage', this.#handleDamageEffectStub);
        this.#effectHandlers.set('spawn_entity', this.#handleSpawnEntityEffectStub);
        this.#effectHandlers.set('remove_status_effect', this.#handleRemoveStatusEffectStub);

        console.log(`ItemUsageSystem: Registered ${this.#effectHandlers.size} effect handlers.`);
    }

    // ========================================================================
    // == EVENT HANDLER (REF-USE-04 Implementation) ==========================
    // ========================================================================

    /**
     * Handles the event:item_use_attempted event, implementing core usage logic.
     * Retrieves entities, validates conditions, handles targeting, executes effects,
     * consumes the item, and provides feedback via the EventBus.
     *
     * @param {ItemUseAttemptedEventPayload} payload - The event data.
     * @private
     */
    _handleItemUseAttempt(payload) {
        console.log(`ItemUsageSystem: Received event:item_use_attempted`);

        const {userEntityId, itemInstanceId, itemDefinitionId, explicitTargetEntityId} = payload;
        /** @type {ActionMessage[]} */
        const internalMessages = []; // For logging the process of this handler

        // --- 1. Retrieve Entities & Definitions ---
        const userEntity = this.#entityManager.getEntityInstance(userEntityId);
        const itemInstance = this.#entityManager.getEntityInstance(itemInstanceId); // The specific instance
        const itemDefinition = this.#dataManager.getEntityDefinition(itemDefinitionId); // The template data

        // --- 2. Basic Validation (Entities exist?) ---
        if (!userEntity) {
            console.error(`ItemUsageSystem: User entity ${userEntityId} not found. Cannot process use attempt.`);
            // No user-facing message needed as this is a critical internal error.
            return;
        }
        if (!itemInstance) {
            console.error(`ItemUsageSystem: Item instance ${itemInstanceId} not found. Cannot process use attempt.`);
            // Might indicate item was removed between action and event.
            // Potentially inform user their item is gone? Or let consumption logic handle it later?
            // For now, log error and stop.
            return;
        }
        if (!itemDefinition) {
            console.error(`ItemUsageSystem: Item definition ${itemDefinitionId} not found. Cannot process use attempt.`);
            this.#eventBus.dispatch('ui:message_display', {text: "Error: Item definition is missing.", type: 'error'});
            return;
        }

        const itemName = getDisplayName(itemInstance, "the item"); // Use item instance for name

        // --- 3. Check if the item has a Usable component ---
        /** @type {UsableComponentData | undefined} */
        const usableComponentData = itemDefinition.components?.Usable;
        if (!usableComponentData) {
            console.warn(`ItemUsageSystem: Item ${itemDefinitionId} (${itemName}) definition lacks Usable component.`);
            this.#eventBus.dispatch('ui:message_display', {text: `You cannot use ${itemName}.`, type: 'info'});
            return;
        }

        // --- 4. Check Usability Conditions (User) ---
        const usabilityCheckResult = this._checkConditions(
            userEntity, // Entity to check
            userEntity, // User entity context
            usableComponentData.usability_conditions,
            usableComponentData,
            itemName,
            this.#eventBus, // Pass the whole event bus
            'Usability'
        );
        internalMessages.push(...usabilityCheckResult.messages);
        if (!usabilityCheckResult.success) {
            // _checkConditions already dispatched the UI failure message via eventBus
            console.log(`ItemUsageSystem: Usability conditions failed for ${itemName}.`);
            return; // Stop processing
        }

        // --- 5. Handle Targeting ---
        let validatedTargetEntity = null; // Initialize validated target
        if (usableComponentData.target_required) {
            internalMessages.push({
                text: `Target required for ${itemName}. Explicit ID: ${explicitTargetEntityId}`,
                type: 'internal'
            });

            let potentialTargetEntity = null;

            // --- 5a. Use Explicit Target First ---
            if (explicitTargetEntityId) {
                potentialTargetEntity = this.#entityManager.getEntityInstance(explicitTargetEntityId);
                if (!potentialTargetEntity) {
                    // The Action Handler resolved an ID, but the entity is gone/invalid now.
                    console.warn(`ItemUsageSystem: Explicit target entity ${explicitTargetEntityId} not found.`);
                    // We could try contextual search here, but per previous thoughts, let's fail clearly.
                    this.#eventBus.dispatch('ui:message_display', {
                        text: "The target you specified is no longer valid.",
                        type: 'warning'
                    });
                    return;
                }
                internalMessages.push({
                    text: `Found potential explicit target: ${getDisplayName(potentialTargetEntity)} (${potentialTargetEntity.id})`,
                    type: 'internal'
                });
            } else {
                // --- 5b. No Explicit Target Provided (Handle Contextual Search or Failure) ---
                // TODO: Implement contextual search if needed based on design.
                // For now, if target is required but none was specified/resolved by action handler: FAIL.
                // Contextual search logic (example - finding single closest other entity):
                /*
                const playerPos = userEntity.getComponent(PositionComponent);
                if (playerPos?.locationId) {
                    const nearby = Array.from(this.#entityManager.getEntitiesInLocation(playerPos.locationId))
                        .map(id => this.#entityManager.getEntityInstance(id))
                        .filter(e => e && e.id !== userEntity.id && e.hasComponent(NameComponent)); // Must exist, not user, have name
                    if (nearby.length === 1) { // Only use if unambiguously one target
                        potentialTargetEntity = nearby[0];
                        internalMessages.push({ text: `Found contextual target: ${getDisplayName(potentialTargetEntity)} (${potentialTargetEntity.id})`, type: 'internal'});
                    } else if (nearby.length > 1) {
                        this.#eventBus.dispatch('ui:message_display', { text: `Who do you want to use the ${itemName} on? Be more specific.`, type: 'warning' });
                        return;
                    }
                }
                */
                // Sticking to failure if explicit target is missing:
                internalMessages.push({
                    text: `Target required, but no explicit target entity ID was provided in the event payload.`,
                    type: 'internal'
                });
                this.#eventBus.dispatch('ui:message_display', {
                    text: `You need to specify a target to use the ${itemName}.`,
                    type: 'warning'
                });
                return;
            }

            // --- 5c. Validate the Found/Explicit Target ---
            if (potentialTargetEntity) {
                const targetCheckResult = this._checkConditions(
                    potentialTargetEntity, // Entity to check
                    userEntity,            // User entity context
                    usableComponentData.target_conditions,
                    usableComponentData,
                    itemName,
                    this.#eventBus,         // Pass event bus
                    'Target'
                );
                internalMessages.push(...targetCheckResult.messages);
                if (!targetCheckResult.success) {
                    // _checkConditions dispatched UI failure message
                    console.log(`ItemUsageSystem: Target conditions failed for ${getDisplayName(potentialTargetEntity)}.`);
                    return; // Stop processing
                }
                // Target is valid!
                validatedTargetEntity = potentialTargetEntity;
                internalMessages.push({
                    text: `Target ${getDisplayName(validatedTargetEntity)} validated successfully.`,
                    type: 'internal'
                });

            } else {
                // Should have been handled above (explicit not found or contextual failed)
                // If we reach here, it means target required but none found/validated.
                if (!validatedTargetEntity) { // Double check
                    internalMessages.push({text: `Failed to find or validate a required target.`, type: 'internal'});
                    // Assume appropriate feedback was given earlier
                    // Default message if somehow missed:
                    const defaultFailMsg = usableComponentData.failure_message_default || TARGET_MESSAGES.USE_INVALID_TARGET(itemName);
                    this.#eventBus.dispatch('ui:message_display', {text: defaultFailMsg, type: 'warning'});
                    return;
                }
            }

        } else {
            internalMessages.push({text: `No target required for ${itemName}.`, type: 'internal'});
            // No target required, validatedTargetEntity remains null
        }

        // --- 6. Execute the Effects Loop ---
        let overallEffectsSuccess = true; // Assume success unless a critical effect fails
        let effectsProcessed = false;

        if (usableComponentData.effects && usableComponentData.effects.length > 0) {
            // --- 6a. Create EffectContext ---
            /** @type {EffectContext} */
            const effectContext = {
                userEntity: userEntity,
                targetEntity: validatedTargetEntity, // Use the validated target
                entityManager: this.#entityManager,
                eventBus: this.#eventBus,            // Pass eventBus for feedback
                dataManager: this.#dataManager,
                usableComponentData: usableComponentData,
                itemName: itemName
                // dispatch property intentionally omitted
            };
            internalMessages.push({text: `Executing effects loop for ${itemName}...`, type: 'internal'});

            // --- 6b. Iterate through effects ---
            for (const effect of usableComponentData.effects) {
                effectsProcessed = true; // Mark that we attempted at least one effect
                /** @type {EffectObjectData} */
                const effectData = effect; // Type hint for clarity
                const handler = this.#effectHandlers.get(effectData.effect_type);

                if (handler) {
                    try {
                        internalMessages.push({text: `Executing effect: ${effectData.effect_type}`, type: 'internal'});
                        const result = handler(effectData.effect_params, effectContext);
                        internalMessages.push(...(result.messages || [])); // Log effect messages

                        if (!result.success) {
                            internalMessages.push({
                                text: `Effect ${effectData.effect_type} reported failure. StopPropagation: ${result.stopPropagation}`,
                                type: 'internal'
                            });
                            if (result.stopPropagation) {
                                overallEffectsSuccess = false;
                                break; // Stop processing further effects
                            }
                            // If stopPropagation is false, continue with next effect but note overall success might be partial
                            // For simplicity now, we only track critical failure via stopPropagation.
                        } else {
                            internalMessages.push({
                                text: `Effect ${effectData.effect_type} reported success.`,
                                type: 'internal'
                            });
                        }
                    } catch (error) {
                        console.error(`ItemUsageSystem: Error executing effect handler '${effectData.effect_type}' for ${itemName}:`, error);
                        internalMessages.push({
                            text: `CRITICAL ERROR executing effect ${effectData.effect_type}. ${error.message}`,
                            type: 'error'
                        });
                        overallEffectsSuccess = false; // Critical error stops processing
                        // Maybe dispatch a generic error message?
                        this.#eventBus.dispatch('ui:message_display', {
                            text: `An error occurred while using ${itemName}.`,
                            type: 'error'
                        });
                        break;
                    }
                } else {
                    console.warn(`ItemUsageSystem: No registered effect handler found for type: ${effectData.effect_type} in item ${itemName}. Skipping effect.`);
                    internalMessages.push({
                        text: `Unknown effect type '${effectData.effect_type}'. Skipping.`,
                        type: 'warning'
                    });
                }
            }
            internalMessages.push({
                text: `Effects loop finished. Overall Success: ${overallEffectsSuccess}`,
                type: 'internal'
            });

        } else {
            internalMessages.push({text: `No effects defined for ${itemName}.`, type: 'internal'});
            // If no effects, the action is still considered "successful" if conditions passed
        }

        // --- 7. Handle Item Consumption ---
        // Only consume if effects were generally successful (or non-critical failure) and item is consumable
        if (overallEffectsSuccess && usableComponentData.consume_on_use) {
            const inventoryComponent = userEntity.getComponent(InventoryComponent);
            if (inventoryComponent) {
                // Use the specific itemInstanceId from the payload
                const removed = inventoryComponent.removeItem(itemInstanceId);
                if (removed) {
                    internalMessages.push({
                        text: `Consumed item instance ${itemInstanceId} (${itemName}).`,
                        type: 'internal'
                    });
                    console.log(`ItemUsageSystem: Consumed item instance ${itemInstanceId} (${itemName}) from ${userEntityId}'s inventory.`);
                    // Future: Handle quantity decrement for stackable items
                    // inventoryComponent.decreaseQuantity(itemInstanceId, 1);
                } else {
                    // This could happen if the item was somehow removed between the event firing and now.
                    console.warn(`ItemUsageSystem: Failed to remove item instance ${itemInstanceId} (${itemName}) during consumption for user ${userEntityId}. Item might have already been removed.`);
                    internalMessages.push({
                        text: `Attempted to consume instance ${itemInstanceId}, but it was not found in inventory.`,
                        type: 'warning'
                    });
                    // Should this prevent the success message? Maybe not, the *action* was successful, consumption just failed post-hoc.
                }
            } else {
                console.error(`ItemUsageSystem: User ${userEntityId} lacks InventoryComponent. Cannot consume item ${itemInstanceId}.`);
                internalMessages.push({text: `User missing inventory component, cannot consume item.`, type: 'error'});
                // This is an inconsistency, the user shouldn't have been able to use an item without inventory.
            }
        } else {
            internalMessages.push({
                text: `Item consumption skipped. EffectsSuccess=${overallEffectsSuccess}, ConsumeFlag=${usableComponentData.consume_on_use}`,
                type: 'internal'
            });
        }

        // --- 8. Provide Final Feedback ---
        // If the action reached this point and effects were successful, dispatch the success message.
        // Individual effects might have already sent specific feedback.
        if (overallEffectsSuccess) {
            const successMsg = usableComponentData.success_message;
            if (successMsg) {
                this.#eventBus.dispatch('ui:message_display', {text: successMsg, type: 'info'});
                internalMessages.push({text: `Dispatched custom success message: "${successMsg}"`, type: 'internal'});
            } else if (effectsProcessed) { // Only give generic feedback if effects actually ran
                // Provide a generic fallback message if no specific one exists
                const fallbackMsg = `You use the ${itemName}.`;
                this.#eventBus.dispatch('ui:message_display', {text: fallbackMsg, type: 'info'});
                internalMessages.push({text: `Dispatched generic success message: "${fallbackMsg}"`, type: 'internal'});
            } else {
                // If no effects processed but conditions passed, maybe no message needed unless specified?
                // Or a different generic message? "You handle the [itemName]."
                internalMessages.push({
                    text: `Overall success, but no effects processed and no success message defined.`,
                    type: 'internal'
                });
            }
        } else {
            // Failure feedback should have been handled by condition checks or critical effect failures.
            // A default failure message could be dispatched here if overallEffectsSuccess is false
            // AND no specific failure message was already sent, but that logic is complex.
            // Rely on condition/effect handlers to provide failure feedback for now.
            internalMessages.push({
                text: `Overall action failed or was stopped. Final success feedback skipped.`,
                type: 'internal'
            });
            const defaultFailMsg = usableComponentData.failure_message_default || `Something prevented you from using the ${itemName} correctly.`;
            // Avoid double-messaging if a specific failure message was already sent.
            // Hard to track perfectly without more state. Let's assume prior messages were sufficient.
            // Only dispatch if we suspect a silent failure:
            // if (!internalMessages.some(m => m.type === 'error' || m.type === 'warning')) { // Basic check
            //    this.#eventBus.dispatch('ui:message_display', { text: defaultFailMsg, type: 'warning' });
            // }
        }

        // --- Log Internal Messages ---
        console.log("ItemUsageSystem: _handleItemUseAttempt processing complete.");
        internalMessages.forEach(msg => console.debug(`  [${msg.type}] ${msg.text}`));
    }

    // ========================================================================
    // == EFFECT HANDLERS (Ensure they use context.eventBus for UI feedback) ==
    // ========================================================================

    /**
     * Handles the 'heal' effect type.
     * Restores health to the target entity based on parameters.
     * Adheres to AC for Ticket: USAGE-EFFECT-HEAL
     * Uses context.eventBus for UI feedback.
     * @type {EffectHandlerFunction}
     */
    #handleHealEffect = (params, context) => {
        const messages = [];
        // Note: Use context.eventBus now for UI messages
        const {userEntity, targetEntity, entityManager, eventBus, itemName} = context;
        const {
            amount,
            target: targetSpecifier = 'user', // Default to 'user'
            fail_if_already_max = false // Default to false
        } = params ?? {};

        // 1. Validate Parameters
        if (typeof amount !== 'number' || amount <= 0) {
            const errorMsg = `Invalid 'amount' parameter (${amount}) for 'heal' effect in item ${itemName}.`;
            console.error(`ItemUsageSystem: ${errorMsg}`);
            messages.push({text: `Internal Error: ${itemName} heal effect misconfigured.`, type: 'error'});
            // Dispatch error via eventBus? Maybe too noisy for config errors.
            // eventBus.dispatch('ui:message_display', { text: `Error: ${itemName} is configured incorrectly.`, type: 'error' });
            return {success: false, messages: messages, stopPropagation: true};
        }

        // 2. Identify Target Entity
        let actualTargetEntity = null;
        if (targetSpecifier === 'target') {
            actualTargetEntity = targetEntity;
        } else {
            actualTargetEntity = userEntity;
        }

        if (!actualTargetEntity) {
            const errorMsg = `Could not determine target ('${targetSpecifier}') for 'heal' effect in item ${itemName}. Context Target: ${targetEntity?.id}`;
            console.error(`ItemUsageSystem: ${errorMsg}`);
            messages.push({text: `Internal Error: Could not apply heal from ${itemName}.`, type: 'error'});
            // Use eventBus for generic failure
            eventBus.dispatch('ui:message_display', {text: `Couldn't apply healing from ${itemName}.`, type: 'error'});
            return {success: false, messages: messages, stopPropagation: true}; // Stop if target invalid
        }

        const targetName = getDisplayName(actualTargetEntity);

        // 3. Access Target's HealthComponent
        const healthComponent = actualTargetEntity.getComponent(HealthComponent);
        if (!healthComponent) {
            const errorMsg = `Target ${targetName} (${actualTargetEntity.id}) lacks HealthComponent for 'heal' effect from ${itemName}.`;
            console.warn(`ItemUsageSystem: ${errorMsg}`);
            messages.push({text: `${itemName} has no effect on ${targetName}.`, type: 'internal'});
            // Use eventBus for user feedback
            eventBus.dispatch('ui:message_display', {
                text: `${targetName} cannot be healed by the ${itemName}.`,
                type: 'info'
            });
            return {success: false, messages: messages}; // Cannot heal non-health target
        }

        // 4. Check Health Status
        const currentHealth = healthComponent.current;
        const maxHealth = healthComponent.max;
        const isFullHealth = currentHealth >= maxHealth;

        // 5. Handle Full Health Case
        if (isFullHealth) {
            const feedbackMsg = `${targetName}'s health is already full.`;
            messages.push({text: feedbackMsg, type: 'internal'});

            // Use eventBus for user feedback
            eventBus.dispatch('ui:message_display', {text: feedbackMsg, type: 'info'});

            if (fail_if_already_max) {
                return {success: false, messages: messages, stopPropagation: true}; // Fail and stop
            } else {
                return {success: true, messages: messages}; // Succeed (no effect) and continue
            }
        }

        // 6. Handle Not Full Health Case (Apply Healing)
        const oldHealth = currentHealth;
        healthComponent.current = Math.min(maxHealth, oldHealth + amount);
        const actualHeal = healthComponent.current - oldHealth;

        // 7. Provide Feedback via EventBus
        const healMsg = `${targetName} recovered ${actualHeal} health.`;
        messages.push({text: healMsg, type: 'success'});
        eventBus.dispatch('ui:message_display', {text: healMsg, type: 'success'}); // User-facing via EventBus

        // 8. Return Success
        return {success: true, messages: messages};
    };

    /**
     * Handles the 'trigger_event' effect type.
     * Dispatches a custom event on the global EventBus.
     * Adheres to AC for Ticket: USAGE-EFFECT-EVENT
     * Uses context.eventBus for UI feedback if configured.
     * @type {EffectHandlerFunction}
     */
    #handleTriggerEventEffect = (params, context) => {
        const messages = [];
        // Use context.eventBus for dispatching the trigger AND potential feedback
        const {eventBus, userEntity, targetEntity, itemName} = context;
        const {
            event_name,
            event_payload = {},
            feedback_message // Optional feedback message string
        } = params ?? {};

        // 1. Validate Parameters
        if (typeof event_name !== 'string' || event_name.trim() === '') {
            const errorMsg = `Invalid or missing 'event_name' parameter for 'trigger_event' effect in item ${itemName}.`;
            console.error(`ItemUsageSystem: ${errorMsg}`);
            messages.push({
                text: `Internal Error: ${itemName} trigger_event effect misconfigured (missing event_name).`,
                type: 'error'
            });
            return {success: false, messages: messages, stopPropagation: true};
        }
        if (typeof event_payload !== 'object' || event_payload === null) {
            const errorMsg = `Invalid 'event_payload' parameter (must be an object) for 'trigger_event' effect in item ${itemName}.`;
            console.error(`ItemUsageSystem: ${errorMsg}`);
            messages.push({
                text: `Internal Error: ${itemName} trigger_event effect misconfigured (invalid event_payload).`,
                type: 'error'
            });
            return {success: false, messages: messages, stopPropagation: true};
        }

        // 2. Construct Final Event Payload
        const finalEventPayload = {
            ...event_payload,
            userId: userEntity.id,
            targetId: targetEntity?.id ?? null,
            sourceItemId: itemName // Added item name for context
        };

        // 3. Dispatch Event via context.eventBus
        try {
            console.debug(`ItemUsageSystem: Dispatching event '${event_name}' via EventBus for item ${itemName}. Payload:`, finalEventPayload);
            eventBus.dispatch(event_name, finalEventPayload); // Dispatch the triggered event
            messages.push({text: `Dispatched event '${event_name}' for ${itemName}.`, type: 'internal'});
        } catch (error) {
            const errorMsg = `Error dispatching event '${event_name}' for item ${itemName}: ${error.message}`;
            console.error(`ItemUsageSystem: ${errorMsg}`, error);
            messages.push({text: `Internal Error: Failed to dispatch event for ${itemName}.`, type: 'error'});
            // Dispatch UI error via eventBus
            eventBus.dispatch('ui:message_display', {
                text: `An error occurred triggering an effect from ${itemName}.`,
                type: 'error'
            });
            return {success: false, messages: messages, stopPropagation: true};
        }

        // 4. Optional Feedback via context.eventBus
        if (typeof feedback_message === 'string' && feedback_message.trim() !== '') {
            console.debug(`ItemUsageSystem: Triggering feedback message for ${itemName}: "${feedback_message}"`);
            eventBus.dispatch('ui:message_display', {text: feedback_message, type: 'info'}); // Use eventBus for UI feedback
            messages.push({text: `Dispatched feedback message: "${feedback_message}"`, type: 'internal'});
        }

        // 5. Return Success
        return {success: true, messages: messages};
    };


    // --- Stub Handlers (Keep as is for now) ---

    /** @type {EffectHandlerFunction} */
    #handleApplyStatusEffectStub = (params, context) => {
        console.log(`ItemUsageSystem: STUB: Handling 'apply_status_effect' for ${context.itemName}`);
        // Future: Use context.eventBus for feedback like "You feel stronger."
        return {
            success: true,
            messages: [{text: `Apply_status_effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }

    /** @type {EffectHandlerFunction} */
    #handleDamageEffectStub = (params, context) => {
        console.log(`ItemUsageSystem: STUB: Handling 'damage' for ${context.itemName}`);
        // Future: Use context.eventBus for feedback like "The goblin takes 5 fire damage."
        return {
            success: true,
            messages: [{text: `Damage effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }

    /** @type {EffectHandlerFunction} */
    #handleSpawnEntityEffectStub = (params, context) => {
        console.log(`ItemUsageSystem: STUB: Handling 'spawn_entity' for ${context.itemName}`);
        // Future: Use context.eventBus for feedback like "A small creature appears."
        return {
            success: true,
            messages: [{text: `Spawn_entity effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }

    /** @type {EffectHandlerFunction} */
    #handleRemoveStatusEffectStub = (params, context) => {
        console.log(`ItemUsageSystem: STUB: Handling 'remove_status_effect' for ${context.itemName}`);
        // Future: Use context.eventBus for feedback like "You feel the poison fading."
        return {
            success: true,
            messages: [{text: `Remove_status_effect processed (stub) for ${context.itemName}.`, type: 'internal'}]
        };
    }


    // ========================================================================
    // == CONDITION CHECKING HELPER ===========================================
    // ========================================================================

    /**
     * Checks if the conditions (usability or target) defined in the item's UsableComponent are met.
     * Dispatches UI messages on failure using the provided EventBus instance.
     *
     * @param {Entity} entityToCheck - The entity the conditions are evaluated against (user or target).
     * @param {Entity} userEntity - The entity initiating the action (needed for context like distance).
     * @param {ConditionObjectData[] | undefined} conditions - The array of conditions to check.
     * @param {UsableComponentData} usableData - The Usable component data for fallback messages.
     * @param {string} itemName - The display name of the item being used (for messages).
     * @param {EventBus} eventBus - The event bus instance for dispatching UI messages.
     * @param {'Usability' | 'Target'} checkType - Context for logging/errors.
     * @returns {{success: boolean, messages: ActionMessage[]}} - Result indicating if conditions passed, includes messages for logging.
     * @private
     */
    _checkConditions(entityToCheck, userEntity, conditions, usableData, itemName, eventBus, checkType) {
        /** @type {ActionMessage[]} */
        const messages = [];

        if (!conditions || conditions.length === 0) {
            return {
                success: true,
                messages: [{text: `No ${checkType} conditions to check for ${itemName}.`, type: "internal"}]
            };
        }

        messages.push({
            text: `Checking ${checkType} conditions for ${itemName} against ${getDisplayName(entityToCheck)}...`,
            type: 'internal'
        })

        for (const condition of conditions) {
            // Evaluate the core condition logic
            let conditionMet = this._evaluateCondition(entityToCheck, userEntity, condition);
            const negate = condition.negate ?? false;
            let finalConditionMet = negate ? !conditionMet : conditionMet;

            if (!finalConditionMet) {
                // Determine appropriate failure message
                let failureMsg = condition.failure_message;
                if (!failureMsg) {
                    // Define fallback messages based on schema/ticket description
                    const defaultUsabilityFail = usableData.failure_message_default || TARGET_MESSAGES.USE_CONDITION_FAILED(itemName);
                    const defaultTargetFail = usableData.failure_message_default || TARGET_MESSAGES.USE_INVALID_TARGET(itemName); // Consider a separate target fallback?

                    if (checkType === 'Target') {
                        failureMsg = defaultTargetFail;
                    } else { // checkType === 'Usability'
                        failureMsg = defaultUsabilityFail;
                    }
                }

                // Use the EventBus for immediate condition failure feedback
                eventBus.dispatch('ui:message_display', {text: failureMsg, type: 'warning'});
                messages.push({
                    text: `${checkType} Condition Check Failed for ${itemName}: Type='${condition.condition_type}', Negated=${negate}, Reason='${failureMsg}'`,
                    type: 'internal'
                });
                return {success: false, messages}; // Stop checking on the first failure
            } else {
                messages.push({
                    text: `${checkType} Condition Check Passed for ${itemName}: Type='${condition.condition_type}', Negated=${negate}`,
                    type: 'internal'
                });
            }
        }

        // If loop completes, all conditions passed
        messages.push({text: `All ${checkType} conditions passed for ${itemName}.`, type: 'internal'})
        return {success: true, messages};
    }

    /**
     * Evaluates a single condition object against the target entity, user entity, and potentially game state.
     * Handles parameter retrieval and validation internally.
     * (Implementation remains the same as provided previously)
     *
     * @param {Entity} entityToCheck - The entity the condition applies to (user or target).
     * @param {Entity} userEntity - The entity initiating the action (for context like distance).
     * @param {ConditionObjectData} condition - The condition data object.
     * @returns {boolean} - True if the condition is met, false otherwise. Returns false for unknown condition types or errors.
     * @private
     */
    _evaluateCondition(entityToCheck, userEntity, condition) {
        const conditionType = condition.condition_type;

        // Helper functions (getNumberParam, getStringParam, getValueParam) remain the same...
        const getNumberParam = (paramName, defaultValue = null) => {
            const value = condition[paramName];
            if (typeof value === 'number') return value;
            if (condition.hasOwnProperty(paramName)) console.warn(`ItemUsageSystem: Condition '${conditionType}' expected number for '${paramName}', got ${typeof value}.`);
            if (defaultValue !== null) return defaultValue;
            console.warn(`ItemUsageSystem: Condition '${conditionType}' missing required number param '${paramName}'. Condition fails.`);
            return null; // Indicate failure
        };
        const getStringParam = (paramName, defaultValue = null) => {
            const value = condition[paramName];
            if (typeof value === 'string' && value.length > 0) return value;
            if (condition.hasOwnProperty(paramName)) console.warn(`ItemUsageSystem: Condition '${conditionType}' expected non-empty string for '${paramName}', got ${typeof value}.`);
            if (defaultValue !== null) return defaultValue;
            console.warn(`ItemUsageSystem: Condition '${conditionType}' missing required string param '${paramName}'. Condition fails.`);
            return null; // Indicate failure
        };
        const getValueParam = (paramName) => {
            const value = condition[paramName];
            if (typeof value === 'undefined') {
                console.warn(`ItemUsageSystem: Condition '${conditionType}' missing required param '${paramName}'. Condition fails.`); // Adjusted message
                return undefined; // Indicate failure
            }
            return value;
        };


        switch (conditionType) {
            case 'player_state': {
                const requiredState = getStringParam('state');
                if (requiredState === null) return false;
                if (entityToCheck !== userEntity) {
                    console.warn(`ItemUsageSystem: Condition 'player_state' used on non-user target ${getDisplayName(entityToCheck)}. Condition fails.`);
                    return false;
                }
                console.warn(`ItemUsageSystem: Condition type 'player_state' ('${requiredState}') not implemented. Assuming false.`);
                return false;
            }

            case 'has_status_effect': {
                const effectId = getStringParam('effect_id');
                if (effectId === null) return false;
                console.warn(`ItemUsageSystem: Condition type 'has_status_effect' ('${effectId}') on ${getDisplayName(entityToCheck)} not implemented. Assuming false.`);
                return false;
            }

            case 'target_has_component': {
                const componentName = getStringParam('component_name'); // Param name from schema examples
                if (componentName === null) return false;
                const ComponentClass = this.#entityManager.componentRegistry.get(componentName);
                if (!ComponentClass) {
                    console.warn(`ItemUsageSystem: Condition 'target_has_component': Unknown component '${componentName}'. Assuming false.`);
                    return false;
                }
                return entityToCheck.hasComponent(ComponentClass);
            }

            case 'target_distance': {
                // Params from schema examples: max_distance, min_distance
                const maxDistance = getNumberParam('max_distance');
                const minDistance = getNumberParam('min_distance', 0); // Default min to 0 if omitted
                if (maxDistance === null || maxDistance < 0 || minDistance < 0 || maxDistance < minDistance) {
                    console.warn(`ItemUsageSystem: Condition 'target_distance' has invalid parameters (max:${maxDistance}, min:${minDistance}). Condition fails.`);
                    return false;
                }

                if (entityToCheck === userEntity) return 0 >= minDistance && 0 <= maxDistance;

                const userPosComp = userEntity.getComponent(PositionComponent);
                const targetPosComp = entityToCheck.getComponent(PositionComponent);
                if (!userPosComp || !targetPosComp) {
                    console.warn(`ItemUsageSystem: Condition 'target_distance' requires PositionComponent on user ${getDisplayName(userEntity)} and target ${getDisplayName(entityToCheck)}. Assuming false.`);
                    return false;
                }
                if (userPosComp.locationId !== targetPosComp.locationId) return false;

                const dx = userPosComp.x - targetPosComp.x;
                const dy = userPosComp.y - targetPosComp.y;
                const distanceSq = dx * dx + dy * dy;
                // Check against squared distances to avoid sqrt
                return distanceSq >= (minDistance * minDistance) && distanceSq <= (maxDistance * maxDistance);
            }

            case 'health_below_max': {
                const healthComponent = entityToCheck.getComponent(HealthComponent);
                if (!healthComponent) return false;
                return healthComponent.current < healthComponent.max;
            }

            case 'attribute_check': {
                // Params from schema examples: attribute_id, comparison, value
                const attributeId = getStringParam('attribute_id');
                const comparison = getStringParam('comparison');
                const value = getValueParam('value'); // Gets the comparison value

                if (attributeId === null || comparison === null || typeof value === 'undefined') return false; // getValueParam handles missing 'value'

                console.warn(`ItemUsageSystem: Condition type 'attribute_check' ('${attributeId} ${comparison} ${value}') on ${getDisplayName(entityToCheck)} not implemented. Assuming false.`);
                return false;
            }

            default:
                console.warn(`ItemUsageSystem: Encountered unknown condition_type '${conditionType}' for entity ${getDisplayName(entityToCheck)}. Assuming condition fails.`);
                return false;
        }
    }

}

export default ItemUsageSystem;