// src/core/turns/interfaces/IActorTurnStrategy.js
// --- FILE START ---

/**
 * @typedef {import('./ITurnContext.js').ITurnContext} ITurnContext
 * // ITurnContext provides the strategy with necessary game state, actor info, and services.
 */

/**
 * @interface ITurnAction
 * @description
 * Represents an instance of an action that an actor has decided to take.
 * This object serves as a data packet that links to a data-defined action
 * (via `actionDefinitionId`) and includes any specific parameters that were
 * resolved for this particular invocation of the action (e.g., the target of an attack,
 * the item to use, the direction of movement).
 *
 * The turn system will use this information to:
 * 1. Look up the full action definition (which conforms to the
 * `action-definition.schema.json`) using the `actionDefinitionId`.
 * 2. Validate prerequisites based on the action definition and the current game state
 * (actor, resolvedParameters, etc.).
 * 3. Process the action, which might involve using a logic interpreter for associated rules,
 * generating output based on its template, or dispatching events as specified
 * in the action's definition.
 *
 * This interface does NOT include an `execute` method, as action execution logic
 * is external and data-driven, managed by a separate interpreter or system
 * based on the action's definition file.
 *
 * @property {string} actionDefinitionId - Required. The unique, namespaced ID of the
 * data-defined action that the actor has chosen. This ID corresponds to the `id`
 * field in an action definition JSON file (e.g., "core:wait", "combat:attack",
 * "interaction:talk_to_npc").
 * @property {object} [resolvedParameters] - Optional. An object containing key-value
 * pairs for parameters that have been resolved for this specific instance of the
 * action. The keys should correspond to placeholders in the action definition's
 * template or parameters expected by its prerequisites or event dispatch logic.
 * For example:
 * - For an "attack" action with definition template "attack {targetName}":
 * `resolvedParameters: { targetId: "npc_goblin_001", targetName: "Goblin" }`
 * - For a "go" action with definition template "go {direction}":
 * `resolvedParameters: { direction: "north" }`
 * - For an action like "wait" that requires no parameters, this field may be
 * undefined or an empty object.
 * @property {string} [commandString] - Optional. The fully formed command string
 * that was input by a human player or generated by an AI strategy, representing
 * this action instance (e.g., "attack goblin", "go north", "wait").
 * This can be useful for logging, history, or debugging purposes.
 * The system should primarily rely on `actionDefinitionId` and `resolvedParameters`
 * for processing.
 */

/**
 * @interface IActorTurnStrategy
 * @description
 * Defines the contract for how an actor (human, AI, item with agency, etc.)
 * decides on an action to perform during its turn. Implementations of this
 * interface will encapsulate the specific logic for decision-making,
 * tailored to the nature of the actor.
 *
 * This strategy is a cornerstone of the decoupled turn-handling architecture,
 * enabling actor-agnostic turn states (like `AwaitInputState` or an automated
 * `ExecuteChoiceState`) to function consistently regardless of the actor's type.
 * The turn handler (or the current turn state) will invoke `decideAction` on the
 * actor's current strategy to obtain its intended {@link ITurnAction}.
 *
 * @example
 * // For a human player:
 * class HumanPlayerStrategy extends IActorTurnStrategy {
 * // Assume a command parser is available, perhaps via context or injected.
 * // This parser would map input like "attack goblin" to an ITurnAction.
 * async decideAction(context) {
 * const rawInput = await context.getPlayerPromptService().prompt("Your command?");
 * // The parser would identify the action definition (e.g., "core:attack")
 * // and resolve targets/parameters (e.g., { target: "goblin_id" }).
 * // const parsedAction = this.commandParser.parse(rawInput, context);
 * // return parsedAction; // which should be of type ITurnAction
 * // Example return:
 * // return {
 * //   actionDefinitionId: "core:attack",
 * //   resolvedParameters: { targetId: "goblin_id" },
 * //   commandString: rawInput
 * // };
 * }
 * }
 *
 * @example
 * // For an AI agent (e.g., LLM-based):
 * class LLMAIStrategy extends IActorTurnStrategy {
 * constructor(llmService, actionResolver) {
 * super();
 * this.llmService = llmService;
 * this.actionResolver = actionResolver; // Helper to map LLM output to ITurnAction
 * }
 * async decideAction(context) {
 * // Gathers relevant game state from context, constructs a prompt,
 * // calls LLM, and parses the LLM's structured response (e.g., JSON)
 * // into an ITurnAction.
 * // const llmOutput = await this.llmService.generateChoice(context);
 * // return this.actionResolver.mapLLMOutputToTurnAction(llmOutput, context);
 * // Example return from actionResolver:
 * // return {
 * //   actionDefinitionId: "core:use_item",
 * //   resolvedParameters: { itemId: "potion_health_id", targetId: context.getActor().id }
 * // };
 * }
 * }
 */
export class IActorTurnStrategy {
    /**
     * Determines the action an actor will take for the current turn.
     *
     * This method is the core of the strategy. It must rely entirely on the
     * provided {@link ITurnContext} to access:
     * - The current actor (via `context.getActor()`).
     * - The current game state (via `context.getGame()`).
     * - Available action definitions (potentially via a service in the context that
     * allows querying possible actions based on `action-definition.schema.json`).
     * - Any available services, such as logging (`context.getLogger()`),
     * player prompting (`context.getPlayerPromptService()`), etc.
     *
     * The method is asynchronous (`async`) to robustly accommodate operations
     * that may not complete synchronously. This is essential for:
     * - Human-controlled actors: Waiting for input from a user interface.
     * - AI-controlled actors: Potentially making API calls to external services (like LLMs)
     * or performing complex, time-consuming computations.
     *
     * The strategy is responsible for resolving the player's or AI's intent into a
     * specific, data-defined action and any necessary parameters for that action's instance.
     *
     * @async
     * @param {ITurnContext} context - The turn context for the current turn. This object
     * provides all necessary information and capabilities
     * (e.g., `context.getActor()`, `context.getLogger()`,
     * `context.getPlayerPromptService()`, `context.getGame()`,
     * a service to query available/valid actions)
     * that the strategy might need to make an informed decision.
     * @returns {Promise<ITurnAction>} A Promise that resolves to an {@link ITurnAction}
     * object. This object identifies the data-defined action chosen
     * (e.g., via `actionDefinitionId`) and includes any parameters
     * resolved for this specific instance (e.g., `resolvedParameters`).
     * If the actor decides to take no overt action (e.g., a "pass turn"
     * scenario, often represented by a "core:wait" or "core:pass" action),
     * the strategy should still resolve with an appropriate
     * {@link ITurnAction} (e.g., `{ actionDefinitionId: 'core:wait' }`).
     * @throws {Error} If a decision cannot be formulated due to an internal error,
     * invalid state, or failure of a dependency. The calling
     * turn state or handler is expected to catch this error and manage
     * the turn lifecycle accordingly (e.g., by ending the turn with an error).
     */
    async decideAction(context) {
        // This is an interface method and must be implemented by concrete strategy classes.
        const actorId = context?.getActor()?.id || 'Unknown Actor';
        const errorMessage = `IActorTurnStrategy.decideAction(context) called on the abstract class or an incomplete implementation for actor '${actorId}'. Concrete strategies must override this method.`;

        const logger = context?.getLogger ? context.getLogger() : console;
        logger.error(errorMessage, {context});

        throw new Error(errorMessage);
    }
}

// --- FILE END ---