// src/tests/core/handlers/playerTurnHandler.assertTurnActiveFor.wrongActor.test.js
// --- FILE START ---

import {jest, describe, it, expect, beforeEach, afterEach} from '@jest/globals';

// --- Module to Test ---
// Adjust the path according to your project structure
import PlayerTurnHandler from '../../../core/handlers/playerTurnHandler.js';

// --- Mock Dependencies ---
// (Existing mocks remain the same)
const mockLogger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
};
const mockActionDiscoverySystem = {
    getValidActions: jest.fn(),
};
const mockCommandProcessor = {
    processCommand: jest.fn(),
};
const mockWorldContext = {
    getLocationOfEntity: jest.fn(),
};
const mockEntityManager = {
    getEntityInstance: jest.fn(),
};
const mockGameDataRepository = {
    getActionDefinition: jest.fn(),
};
const mockPromptOutputPort = {
    prompt: jest.fn(),
};
const mockTurnEndPort = {
    notifyTurnEnded: jest.fn(),
};
// <<< ADDED Mock for CommandInputPort >>>
const mockUnsubscribeFn = jest.fn();
const mockCommandInputPort = {
    onCommand: jest.fn(() => mockUnsubscribeFn), // Needed for startTurn
};
// <<< END ADDED Mock >>>
const mockPlayerPromptService = {
    prompt: jest.fn(),
};
const mockCommandOutcomeInterpreter = {
    interpret: jest.fn(),
};
const mockSafeEventDispatcher = {
    dispatchSafely: jest.fn(),
    subscribe: jest.fn(),      // <<< CORRECTED: Added subscribe mock method
};

// --- Test Suite ---
describe('PlayerTurnHandler: #_assertTurnActiveFor - Failure: Wrong Actor (Tested via _handleTurnEnd)', () => {
    /** @type {PlayerTurnHandler} */
    let handler;
    const className = PlayerTurnHandler.name; // Get class name for error messages
    const actualActorId = 'player-actual';
    const wrongActorId = 'player-expected-but-wrong';
    const currentActor = {id: actualActorId}; // Define actor object

    beforeEach(async () => {
        // Reset all mocks before each test run
        jest.clearAllMocks();
        // <<< Reset added mocks >>>
        mockUnsubscribeFn.mockClear();
        mockCommandInputPort.onCommand.mockClear();

        // Instantiate the handler with all mocks
        handler = new PlayerTurnHandler({
            logger: mockLogger,
            actionDiscoverySystem: mockActionDiscoverySystem,
            commandProcessor: mockCommandProcessor,
            worldContext: mockWorldContext,
            entityManager: mockEntityManager,
            gameDataRepository: mockGameDataRepository,
            promptOutputPort: mockPromptOutputPort,
            turnEndPort: mockTurnEndPort,
            commandInputPort: mockCommandInputPort, // <<< ADDED Dependency
            playerPromptService: mockPlayerPromptService,
            commandOutcomeInterpreter: mockCommandOutcomeInterpreter,
            safeEventDispatcher: mockSafeEventDispatcher,
        });

        // --- Setup ---
        // Configure PlayerPromptService.prompt to resolve immediately
        mockPlayerPromptService.prompt.mockResolvedValue();
        // Configure TurnEndPort to resolve if called (though it shouldn't be in this test)
        mockTurnEndPort.notifyTurnEnded.mockResolvedValue();


        // Start the turn for the 'actual' actor and wait for initiation
        await handler.startTurn(currentActor);

        // Allow any microtasks initiated by startTurn to settle.
        // If using Jest 27+, consider: await jest.runAllMicrotasks();
        await new Promise(process.nextTick);

        // Clear any logs generated during setup (like startTurn starting)
        // to focus only on logs generated by the test step.
        jest.clearAllMocks(); // This clears all mocks, including logger and command mocks.
        // Re-clear command mocks specifically if needed, though clearAllMocks should cover it.
        mockUnsubscribeFn.mockClear(); // Redundant if jest.clearAllMocks() is thorough
        mockCommandInputPort.onCommand.mockClear(); // Redundant
    });

    afterEach(async () => { // Make afterEach async if destroy might be
        // Cleanup the handler instance
        if (handler) {
            try {
                // Destroy might trigger _handleTurnEnd if state wasn't perfectly cleaned,
                handler.destroy();
                // If using Jest 27+, consider: await jest.runAllMicrotasks();
                await new Promise(process.nextTick); // Allow potential async in destroy
            } catch (e) {
                // Suppress errors during cleanup
                // console.error("Error during handler.destroy() in afterEach:", e);
            } finally {
                handler = null;
            }
        }
    });

    it('should log warning (from _handleTurnEnd guard) and attempt unsubscribe when _handleTurnEnd is called with the wrong actor ID', async () => { // Updated description
        // Define expected messages based on current implementation
        // *** THIS IS THE CORRECTED LOG MESSAGE ***
        const expectedWarningMessage = `${className}: _handleTurnEnd called for ${wrongActorId} (status: success), but current actor is ${actualActorId} or does not match. Turn may have already ended or belongs to different handler context. Attempting cleanup for waiting mechanisms if ${wrongActorId} was the one being awaited.`;


        // --- Steps ---
        // Call _handleTurnEnd with the wrong actor ID while the actual actor's turn is active.
        await handler._handleTurnEnd(wrongActorId, null); // Pass null error = success status

        // --- Assertions ---

        // 1. No Error Thrown Upwards: (Implicitly tested by test not crashing)

        // 2. Warning Logging (from _handleTurnEnd guard):
        expect(mockLogger.warn).toHaveBeenCalledTimes(1);
        expect(mockLogger.warn).toHaveBeenCalledWith(expectedWarningMessage);

        // 3. No Port Call:
        expect(mockTurnEndPort.notifyTurnEnded).not.toHaveBeenCalled();

        // 4. Attempt Unsubscribe:
        // _handleTurnEnd's guard condition calls _unsubscribeFromCommands. Since startTurn *was* called,
        // #commandUnsubscribeFn should exist (from mockCommandInputPort.onCommand),
        // and the actual unsubscribe function (mockUnsubscribeFn) should be called.
        expect(mockUnsubscribeFn).toHaveBeenCalledTimes(1);

        // Verify the debug log from _unsubscribeFromCommands
        // The actor ID in the unsubscribe log message will be actualActorId because that's #currentActor
        // OR it could be wrongActorId if #awaitingTurnEndForActorId was wrongActorId (it's not in this path)
        // OR 'N/A'. Given currentActor is set to actualActor, it should be actualActorId.
        // Let's make it more general for the purpose of this test's focus if the exact actorId in that specific log is not critical
        // Or be precise:
        expect(mockLogger.debug).toHaveBeenCalledWith(
            `${className}: Unsubscribing from command input for actor ${actualActorId}.`
        );


        // 5. No State Cleanup Attempt for wrongActorId or further processing within _handleTurnEnd for wrongActorId:
        expect(mockLogger.info).not.toHaveBeenCalledWith(expect.stringContaining(`Ending turn for actor ${wrongActorId}`));
        expect(mockLogger.debug).not.toHaveBeenCalledWith(expect.stringContaining(`Notifying TurnEndPort for actor ${wrongActorId}`));

        // It SHOULD NOT clean up state for actualActorId in THIS SPECIFIC CALL to _handleTurnEnd(wrongActorId, ...)
        // because the primary subject of THIS _handleTurnEnd call is wrongActorId, and it exits early.
        // The state for actualActorId remains until _handleTurnEnd(actualActorId, ...) or destroy() is called.
        expect(mockLogger.debug).not.toHaveBeenCalledWith(expect.stringContaining(`Cleaning up active turn state for ${actualActorId}`));
        expect(mockLogger.debug).not.toHaveBeenCalledWith(expect.stringContaining(`_handleTurnEnd sequence completed for ${wrongActorId}`));


        // 6. No Other Critical Logs (like error, or info unrelated to startTurn which was cleared)
        expect(mockLogger.error).not.toHaveBeenCalled();
        // Check that no 'Ending turn for actor actualActorId' log was made during this specific call.
        const infoCalls = mockLogger.info.mock.calls;
        const endingTurnForActualActorLog = infoCalls.some(call => call[0].includes(`Ending turn for actor ${actualActorId}`));
        expect(endingTurnForActualActorLog).toBe(false);

    });
});

// --- FILE END ---