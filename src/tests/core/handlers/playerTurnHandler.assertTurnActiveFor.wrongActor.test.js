// src/tests/core/handlers/playerTurnHandler.assertTurnActiveFor.wrongActor.test.js
// --- FILE START ---

import { jest, describe, it, expect, beforeEach, afterEach } from '@jest/globals';

// --- Module to Test ---
// Adjust the path according to your project structure
import PlayerTurnHandler from '../../../core/handlers/playerTurnHandler.js';

// --- Mock Dependencies ---
// (Mocks remain the same)
const mockLogger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
};
const mockActionDiscoverySystem = {
    getValidActions: jest.fn(),
};
const mockCommandProcessor = {
    processCommand: jest.fn(),
};
const mockWorldContext = {
    getLocationOfEntity: jest.fn(),
};
const mockEntityManager = {
    getEntityInstance: jest.fn(),
};
const mockGameDataRepository = {
    getActionDefinition: jest.fn(),
};
const mockPromptOutputPort = {
    prompt: jest.fn(),
};
const mockTurnEndPort = {
    notifyTurnEnded: jest.fn(),
};
const mockPlayerPromptService = {
    prompt: jest.fn(),
};
const mockCommandOutcomeInterpreter = {
    interpret: jest.fn(),
};
const mockSafeEventDispatcher = {
    dispatchSafely: jest.fn(),
};

// --- Test Suite ---
describe('PlayerTurnHandler: #_assertTurnActiveFor - Failure: Wrong Actor (Tested via _handleTurnEnd)', () => {
    /** @type {PlayerTurnHandler} */
    let handler;
    const className = PlayerTurnHandler.name; // Get class name for error messages
    const actualActorId = 'player-actual';
    const wrongActorId = 'player-expected-but-wrong';
    const currentActor = { id: actualActorId }; // Define actor object

    beforeEach(async () => {
        // Reset all mocks before each test run
        jest.clearAllMocks();

        // Instantiate the handler with all mocks
        handler = new PlayerTurnHandler({
            logger: mockLogger,
            actionDiscoverySystem: mockActionDiscoverySystem,
            commandProcessor: mockCommandProcessor,
            worldContext: mockWorldContext,
            entityManager: mockEntityManager,
            gameDataRepository: mockGameDataRepository,
            promptOutputPort: mockPromptOutputPort,
            turnEndPort: mockTurnEndPort,
            playerPromptService: mockPlayerPromptService,
            commandOutcomeInterpreter: mockCommandOutcomeInterpreter,
            safeEventDispatcher: mockSafeEventDispatcher,
        });

        // --- Setup ---
        // Configure PlayerPromptService.prompt to resolve immediately
        mockPlayerPromptService.prompt.mockResolvedValue();
        // Configure TurnEndPort to resolve if called (though it shouldn't be in this test)
        mockTurnEndPort.notifyTurnEnded.mockResolvedValue();


        // Start the turn for the 'actual' actor and wait for initiation
        // <<< UPDATED: Call startTurn >>>
        await handler.startTurn(currentActor);

        // <<< REMOVED turnPromise and its catch block >>>
        // const turnPromise = handler.handleTurn(currentActor);
        // turnPromise.catch(() => { /* Explicitly ignore rejection */ });

        // Allow any microtasks initiated by startTurn to settle.
        // <<< UPDATED: Use nextTick for consistency >>>
        await new Promise(process.nextTick);

        // Clear any logs generated during setup (like startTurn starting)
        // to focus only on logs generated by the test step.
        jest.clearAllMocks();
    });

    afterEach(async () => { // Make afterEach async if destroy might be
        // Cleanup the handler instance
        if (handler) {
            try {
                // Destroy might trigger _handleTurnEnd if state wasn't perfectly cleaned,
                // but the main assertion failure is tested within the 'it' block.
                await handler.destroy();
            } catch (e) {
                // Suppress errors during cleanup
                // console.error("Error during handler.destroy() in afterEach:", e);
            } finally {
                handler = null;
            }
        }
    });

    it('should log assertion failure (from #_assertTurnActiveFor) and warning (from _handleTurnEnd) when _handleTurnEnd is called with the wrong actor ID', async () => {
        // Define expected messages based on current implementation
        const expectedAssertionErrorMessage = `${className}: Assertion Failed - Turn is not active for the correct actor. Expected '${wrongActorId}' but current actor is '${actualActorId}'.`;
        // <<< UPDATED expectedWarningMessage to include status derived from input args (null error = success) >>>
        const expectedWarningMessage = `${className}: _handleTurnEnd called for ${wrongActorId} (status: success), but assertion failed. Turn may have already ended or belongs to another handler/actor. Aborting end sequence. Error: ${expectedAssertionErrorMessage}`;


        // --- Steps ---
        // 1. Call _handleTurnEnd with the wrong actor ID while the actual actor's turn is active.
        //    This should trigger the internal #_assertTurnActiveFor, which throws.
        //    The error should be caught by the try...catch within _handleTurnEnd.
        //    Pass 'null' for error and 'false' for isRejection (matches the test description intention)
        await handler._handleTurnEnd(wrongActorId, null); // Third arg (isRejection) defaults to false

        // --- Assertions ---

        // 1. No Error Thrown Upwards:
        //    _handleTurnEnd catches the internal assertion error.
        //    (Test execution would fail if an unhandled error was thrown here)

        // 2. Assertion Error Logging:
        //    #_assertTurnActiveFor itself doesn't log errors, the caller does.
        //    _handleTurnEnd catches the error but logs it via logger.warn within its catch block.
        //    So, logger.error should NOT be called directly with the assertion message.
        expect(mockLogger.error).not.toHaveBeenCalled(); // <<< UPDATED: #_assertTurnActiveFor doesn't log error

        // 3. Warning Logging (from _handleTurnEnd catch block):
        //    Verify the specific warning message from the catch block was logged.
        expect(mockLogger.warn).toHaveBeenCalledTimes(1);
        expect(mockLogger.warn).toHaveBeenCalledWith(expectedWarningMessage);

        // <<< REMOVED Logging Order Check - only warn is expected now >>>
        // if (mockLogger.error.mock.invocationCallOrder.length > 0 && mockLogger.warn.mock.invocationCallOrder.length > 0) { ... }


        // 4. No Port Call:
        //    Assertion failed early, so port should not be notified.
        expect(mockTurnEndPort.notifyTurnEnded).not.toHaveBeenCalled();

        // 5. No State Cleanup Attempt or further processing within _handleTurnEnd:
        //    Verify logs associated with the normal flow *after* assertion were not called.
        expect(mockLogger.info).not.toHaveBeenCalledWith(expect.stringContaining(`Ending turn for actor ${wrongActorId}`));
        expect(mockLogger.debug).not.toHaveBeenCalledWith(expect.stringContaining(`Notifying TurnEndPort for actor ${wrongActorId}`));
        expect(mockLogger.debug).not.toHaveBeenCalledWith(expect.stringContaining(`Cleaning up active turn state for ${actualActorId}`)); // Cleanup for actual actor shouldn't happen
        expect(mockLogger.debug).not.toHaveBeenCalledWith(expect.stringContaining(`_handleTurnEnd sequence completed for ${wrongActorId}`));


        // 6. No Other Logs:
        //    Ensure no other unexpected log levels were called by this specific action.
        expect(mockLogger.info).not.toHaveBeenCalled();
        // Allow debug logs from constructor/setup phase if any, but none from the action itself.
        // expect(mockLogger.debug).not.toHaveBeenCalled(); // Might be too strict depending on setup
    });
});

// --- FILE END ---