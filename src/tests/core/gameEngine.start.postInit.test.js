// src/tests/core/gameEngine.start.postInit.test.js

// --- Imports ---
import {describe, it, expect, beforeEach, jest} from '@jest/globals';
import GameEngine from '../../core/gameEngine.js'; // Class under test
import AppContainer from '../../core/config/appContainer.js'; // Needed for type checking and mock structure reference

// --- Type Imports for Mocks ---
// Core Services
/** @typedef {import('../../core/interfaces/coreServices.js').ILogger} ILogger */
/** @typedef {import('../../services/validatedEventDispatcher.js').default} ValidatedEventDispatcher */
/** @typedef {import('../../core/gameLoop.js').default} GameLoop */
// --- Refactoring Specific Imports ---
/** @typedef {import('../../core/initializers/services/initializationService.js').default} InitializationService */
/** @typedef {import('../../core/initializers/services/initializationService.js').InitializationResult} InitializationResult */


// --- Test Suite ---
describe('GameEngine start() - Post-Initialization Success Logic', () => {

    // --- Mocks ---
    /** @type {jest.Mocked<AppContainer>} */
    let mockAppContainer;
    /** @type {jest.Mocked<ILogger>} */
    let mockLogger;
    /** @type {jest.Mocked<ValidatedEventDispatcher>} */
    let mockvalidatedEventDispatcher;
    /** @type {jest.Mocked<GameLoop>} */
    let mockGameLoop;
    /** @type {jest.Mocked<InitializationService>} */ // Mock for the delegated service
    let mockInitializationService;

    // --- Shared Test Variables ---
    const inputWorldName = 'testInputWorld';


    beforeEach(() => {
        jest.clearAllMocks();

        // --- Create Mock Logger ---
        mockLogger = { info: jest.fn(), warn: jest.fn(), error: jest.fn(), debug: jest.fn() };

        // --- Create Mock Core Services Relevant to Post-Init ---
        mockvalidatedEventDispatcher = { dispatchValidated: jest.fn().mockResolvedValue(true) };
        mockGameLoop = { start: jest.fn(), stop: jest.fn(), isRunning: false }; // Key mock for post-init

        // --- Mock Initialization Service ---
        // For post-init tests, assume it SUCCEEDS and returns the mockGameLoop
        const successfulInitResult = { success: true, error: null, gameLoop: mockGameLoop };
        mockInitializationService = {
            runInitializationSequence: jest.fn().mockResolvedValue(successfulInitResult),
        };

        // --- Create Mock AppContainer ---
        mockAppContainer = {
            resolve: jest.fn(), register: jest.fn(), disposeSingletons: jest.fn(), reset: jest.fn(),
        };

        // --- Configure Mock AppContainer.resolve ---
        // Only mock services directly resolved by GameEngine.start() ITSELF
        mockAppContainer.resolve.mockImplementation((key) => {
            if (key === 'ILogger') return mockLogger;
            if (key === 'InitializationService') return mockInitializationService; // Needed to start the process
            // Resolved by start() AFTER successful init for the final message
            if (key === 'ValidatedEventDispatcher') return mockvalidatedEventDispatcher;

            // GameLoop is provided by InitializationService result, NOT resolved again by start()
            // Other services (WorldLoader, Initializers etc.) are handled within InitializationService

            console.warn(`MockAppContainer (Post-Init Tests): Unexpected resolution attempt for key "${key}". Returning undefined.`);
            return undefined;
        });
    });

    // --- Test Case: TEST-ENG-023 (Revised) ---
    // Focus on logs generated by start() *after* InitializationService succeeds
    describe('[TEST-ENG-023 Revised] Logging Post-Successful Initialization', () => {
        it('should log successful completion of initialization and intent to start GameLoop', async () => {
            const gameEngine = new GameEngine({container: mockAppContainer});
            mockLogger.info.mockClear(); // Clear constructor logs

            await gameEngine.start(inputWorldName);

            // Verify InitializationService was called (pre-condition for post-init logic)
            expect(mockInitializationService.runInitializationSequence).toHaveBeenCalledWith(inputWorldName);

            // Assert logs generated by start() *after* awaiting InitializationService
            // *** FIXED: Changed expected log message to match actual code ***
            expect(mockLogger.info).toHaveBeenCalledWith('GameEngine: Initialization sequence reported success.');
            expect(mockLogger.info).toHaveBeenCalledWith('GameEngine: Starting GameLoop...');
            expect(mockLogger.info).toHaveBeenCalledWith('GameEngine: GameLoop started successfully.'); // After gameLoop.start() call
            // Assert specific logs related to internal init steps are GONE
            expect(mockLogger.info).not.toHaveBeenCalledWith(expect.stringContaining('GameDataRepository resolved'));
            expect(mockLogger.info).not.toHaveBeenCalledWith(expect.stringContaining('WorldLoader resolved'));
            expect(mockLogger.info).not.toHaveBeenCalledWith(expect.stringContaining('Delegating input handler setup'));
            expect(mockLogger.info).not.toHaveBeenCalledWith(expect.stringContaining('retrieved world name'));
        });
    });

    // --- Test Cases: TEST-ENG-024, 025, 027 (Removed) ---
    // REASON: Welcome message / title / initial room_entered dispatch responsibility moved away from GameEngine.start()

    // --- Test Case: TEST-ENG-026 (Revised) ---
    // Focus: Ensure GameEngine correctly identifies success state before starting loop.
    // Remove assertions about GameStateManager resolution/calls *by start()*.
    describe('[TEST-ENG-026 Revised] Internal State Check Pre-Loop Start', () => {
        it('should verify internal state reflects successful initialization before starting loop', async () => {
            const gameEngine = new GameEngine({container: mockAppContainer});
            // *** FIXED: Removed attempt to access private fields directly ***
            // Access internal state for verification using public getters

            // State before start
            // *** FIXED: Use public getter gameEngine.isInitialized ***
            expect(gameEngine.isInitialized).toBe(false);
            // *** FIXED: Use public getter gameEngine.gameLoop ***
            expect(gameEngine.gameLoop).toBeNull();

            await gameEngine.start(inputWorldName);

            // Assert state *after* successful init result processing but *before* loop start call
            // (This happens conceptually between the `if (initResult.success)` and `this.#gameLoop.start()`)
            // The test verifies these are set correctly leading up to the loop start.
            // *** FIXED: Use public getter gameEngine.isInitialized ***
            expect(gameEngine.isInitialized).toBe(true);
            // *** FIXED: Use public getter gameEngine.gameLoop ***
            expect(gameEngine.gameLoop).toBe(mockGameLoop);

            // Verify loop was started (confirming the state check passed internally)
            expect(mockGameLoop.start).toHaveBeenCalledTimes(1);

            // REMOVED Assertions about GameStateManager resolve/calls by GameEngine.start() post-init.
            expect(mockAppContainer.resolve).not.toHaveBeenCalledWith('GameStateManager');
        });
    });


    // --- Test Case: TEST-ENG-028 (Remains Valid) ---
    // Checks that start() calls gameLoop.start() after successful init
    describe('[TEST-ENG-028] GameLoop.start Call', () => {
        it('should call mockGameLoop.start exactly once after successful initialization', async () => {
            const gameEngine = new GameEngine({container: mockAppContainer});
            mockGameLoop.start.mockClear();

            await gameEngine.start(inputWorldName);

            // Verify InitializationService was called (pre-condition)
            expect(mockInitializationService.runInitializationSequence).toHaveBeenCalledWith(inputWorldName);
            // Assert GameLoop.start was called by GameEngine.start()
            expect(mockGameLoop.start).toHaveBeenCalledTimes(1);
        });
    });

    // --- Test Case: TEST-ENG-029 (Remains Valid) ---
    // Checks that start() dispatches the final "Game loop started." message
    describe('[TEST-ENG-029] Final Message Dispatch Post-Loop Start', () => {
        it('should resolve ValidatedEventDispatcher and dispatch the final "Game loop started." message', async () => {
            const gameEngine = new GameEngine({container: mockAppContainer});
            const expectedPayload = {
                text: 'Game loop started.', // Specific message from GameEngine.start()
                type: 'info'
            };
            mockvalidatedEventDispatcher.dispatchValidated.mockClear();
            // Clear resolve calls from constructor/setup
            mockAppContainer.resolve.mockClear();
            // Re-establish default mock behavior for this test
            mockAppContainer.resolve.mockImplementation((key) => {
                if (key === 'ILogger') return mockLogger;
                if (key === 'InitializationService') return mockInitializationService;
                if (key === 'ValidatedEventDispatcher') return mockvalidatedEventDispatcher; // This is the key call to check
                return undefined;
            });


            await gameEngine.start(inputWorldName);

            // Verify InitializationService was called (pre-condition)
            expect(mockInitializationService.runInitializationSequence).toHaveBeenCalledWith(inputWorldName);
            // Verify GameLoop was started (pre-condition for the dispatch)
            expect(mockGameLoop.start).toHaveBeenCalledTimes(1);

            // Assert ValidatedEventDispatcher was resolved *by start()* for the final message
            expect(mockAppContainer.resolve).toHaveBeenCalledWith('ValidatedEventDispatcher');

            // Assert the specific final message was dispatched
            expect(mockvalidatedEventDispatcher.dispatchValidated).toHaveBeenCalledWith(
                'textUI:display_message',
                expectedPayload
            );
            // Optional: Ensure it was called *after* the loop started if timing is critical
            // (Jest mock call order assertion or more complex setup might be needed)
        });
    });

}); // End describe block for gameEngine.start.postInit.test.js