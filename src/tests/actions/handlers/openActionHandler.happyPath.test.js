// src/tests/actions/handlers/openActionHandler.happyPath.test.js

import { jest, describe, it, expect, beforeEach } from '@jest/globals';

// --- Function Under Test ---
// Assuming relative path from the test file to the source file
import { executeOpen } from '../../../actions/handlers/openActionHandler.js';

// --- Mocked Dependencies ---
import * as actionExecutionUtils from '../../../actions/actionExecutionUtils.js';
import * as messagesUtils from '../../../utils/messages.js';
import OpenableComponent from '../../../components/openableComponent.js';
import Entity from '../../../entities/entity.js';
import { NameComponent } from '../../../components/nameComponent.js';

// Mock the entire modules containing the dependencies
jest.mock('../../../actions/actionExecutionUtils.js');
jest.mock('../../../utils/messages.js');
jest.mock('../../../entities/entity.js');
// No need to mock OpenableComponent/NameComponent unless testing their internals

// --- Mock Implementations & Test Setup ---

// Provide mock implementations for the mocked functions
// These will hold the Jest mock functions generated by jest.mock()
const mockHandleActionWithTargetResolution = actionExecutionUtils.handleActionWithTargetResolution;
const mockDispatchEventWithCatch = actionExecutionUtils.dispatchEventWithCatch;
const mockGetDisplayName = messagesUtils.getDisplayName;

// Mock TARGET_MESSAGES object
// Ensure all keys used by executeOpen and its callbacks are present
messagesUtils.TARGET_MESSAGES = {
    INTERNAL_ERROR: "Mock Internal Error.",
    NOT_FOUND_OPENABLE: jest.fn((name) => `Mock: Cannot find openable '${name}'.`),
    FILTER_EMPTY_OPENABLE: jest.fn((verb, scope) => `Mock: Nothing ${scope} to ${verb}.`),
    AMBIGUOUS_PROMPT: jest.fn((verb, name, candidates) => `Mock: Which '${name}' to ${verb}?`),
};

// Helper to create mock entities
const createMockEntity = (id, name = 'Mock Entity') => {
    const entity = new Entity(id); // Use the (mocked) Entity constructor
    entity.id = id; // Ensure ID is set even if constructor is mocked simply

    // Mock essential methods used directly or indirectly by executeOpen/onFoundUnique
    entity.getComponent = jest.fn((ComponentClass) => {
        // Use ComponentClass.name comparison for robustness against different import/instance types if needed
        if (ComponentClass === NameComponent || ComponentClass.name === 'NameComponent') {
            // Simulate having a NameComponent for getDisplayName
            return { value: name }; // Return a simple object mimicking the component structure
        }
        if (ComponentClass === OpenableComponent || ComponentClass.name === 'OpenableComponent') {
            // Return a simple object mimicking the component structure, no need for full instance if not used
            return { isOpen: false };
        }
        return undefined;
    });
    // Mock hasComponent if required by handleActionWithTargetResolution mock logic
    entity.hasComponent = jest.fn((ComponentClass) => {
        return (ComponentClass === NameComponent || ComponentClass.name === 'NameComponent' ||
            ComponentClass === OpenableComponent || ComponentClass.name === 'OpenableComponent');
    });
    return entity;
};


// Helper to create mock ActionContext
const createMockContext = (directObjectPhrase = 'door') => {
    const mockPlayer = createMockEntity('player1', 'Player');
    const mockDispatch = jest.fn(); // This specific mock function will be used for eventBus dispatch
    return {
        playerEntity: mockPlayer,
        currentLocation: createMockEntity('loc1', 'Room'),
        parsedCommand: {
            actionId: 'core:open',
            directObjectPhrase: directObjectPhrase,
            preposition: null,
            indirectObjectPhrase: null,
            originalInput: `open ${directObjectPhrase}`,
            error: null,
        },
        dataManager: {}, // Mock if needed
        entityManager: { // Mock if needed by dependencies
            getEntityInstance: jest.fn(id => createMockEntity(id)) // Simple mock
        },
        // Use the specific mockDispatch for both context.dispatch and eventBus.dispatch
        dispatch: mockDispatch,
        eventBus: { dispatch: mockDispatch },
    };
};

// --- Test Suite ---

describe('executeOpen (Isolated Happy Path)', () => {
    let mockContext;
    let mockTargetEntity;

    // --- Variables to control mock behavior ---
    // Note: These are reset in beforeEach, defining them here is optional
    // let simulateResolutionStatus;
    // let simulateDispatchSuccess;

    beforeEach(() => {
        // Reset all mocks before each test to ensure isolation
        jest.clearAllMocks();

        // Create entities needed for tests
        mockTargetEntity = createMockEntity('targetDoor', 'Old Door');

        // Create a default context
        mockContext = createMockContext('Old Door'); // Use specific phrase matching target

        // --- Configure Mock Behavior for Happy Path ---
        const simulateResolutionStatus = 'FOUND_UNIQUE'; // Hardcoded for this test file
        const simulateDispatchSuccess = true;      // Hardcoded for this test file

        // Default mock return for getDisplayName (can be overridden in test if needed)
        // Note: messagesUtils is mocked, so getDisplayName is already a mock fn
        mockGetDisplayName.mockImplementation((entity) => {
            // Provide a basic implementation consistent with createMockEntity
            const nameComp = entity?.getComponent(NameComponent);
            return nameComp?.value ?? entity?.id ?? 'unknown entity';
        });

        // Configure mock return for dispatchEventWithCatch
        // Note: actionExecutionUtils is mocked, so dispatchEventWithCatch is already a mock fn
        mockDispatchEventWithCatch.mockImplementation(async (/* context, eventName, payload, messages, logDetails */) => {
            // Simple success simulation based on the variable
            return { success: simulateDispatchSuccess };
        });

        // *** The core mock for handleActionWithTargetResolution ***
        // Note: actionExecutionUtils is mocked, so handleActionWithTargetResolution is already a mock fn
        mockHandleActionWithTargetResolution.mockImplementation(async (context, options) => {
            // Simulate finding the unique target based on status
            if (simulateResolutionStatus === 'FOUND_UNIQUE') {
                const target = mockTargetEntity; // Use the predefined mock target
                const mockMessagesArray = []; // Simulate internal messages array

                // Add logging to see when the callback is invoked by the mock
                console.log(">>> MOCK handleAction: About to call options.onFoundUnique");

                // *** CRITICAL: Invoke the actual onFoundUnique callback provided in options ***
                // The `onFoundUnique` function comes *from the real executeOpen* code
                const callbackResult = await options.onFoundUnique(context, target, mockMessagesArray);

                console.log(">>> MOCK handleAction: Returned from options.onFoundUnique");

                // Return a result mimicking the utility's success case
                return {
                    success: callbackResult.success, // Result success depends on the callback's success
                    messages: mockMessagesArray.concat(callbackResult.messages || []),
                    newState: callbackResult.newState,
                };
            } else {
                // Basic failure simulation for completeness, though not used by the happy path test
                return { success: false, messages: [{ text: 'Mock: Non-unique resolution', type: 'internal' }], newState: undefined };
            }
        });
    }); // End beforeEach

    // --- Test Case ---

    describe('7.1. Happy Path: Unique Target Found & Event Dispatched Successfully', () => {
        it('should call handleActionWithTargetResolution with correct options and dispatch event:open_attempted', async () => {
            // Arrange:
            // Default setup from beforeEach IS the Happy Path.
            // We can override specific mocks here if needed, e.g., for display name:
            mockGetDisplayName.mockReturnValue('Old Door Display Name'); // Specific name for clarity in logs/payload

            // Act
            const result = await executeOpen(mockContext);

            // Assert
            // 1. Verify handleActionWithTargetResolution call and options
            expect(mockHandleActionWithTargetResolution).toHaveBeenCalledTimes(1);
            const passedOptions = mockHandleActionWithTargetResolution.mock.calls[0][1];
            expect(passedOptions.scope).toBe('nearby_including_blockers');
            expect(passedOptions.requiredComponents).toEqual([OpenableComponent]);
            expect(passedOptions.commandPart).toBe('directObjectPhrase');
            expect(passedOptions.actionVerb).toBe('open');
            expect(passedOptions.onFoundUnique).toBeInstanceOf(Function); // Check the callback was passed
            // Check specific failure messages if they are important for this path
            expect(passedOptions.failureMessages).toEqual({
                notFound: messagesUtils.TARGET_MESSAGES.NOT_FOUND_OPENABLE,
                filterEmpty: messagesUtils.TARGET_MESSAGES.FILTER_EMPTY_OPENABLE,
            });

            // 2. Verify onFoundUnique callback's internal calls (made via the mock handleAction...)
            // Note: getDisplayName is called BOTH inside onFoundUnique AND potentially by the mock entity setup.
            // We care mostly about the call within onFoundUnique triggered by our flow.
            // Check if it was called *with the target entity* specifically.
            expect(mockGetDisplayName).toHaveBeenCalledWith(mockTargetEntity);
            // If mockGetDisplayName is simple, checking times might be fragile. The above is more specific.
            // expect(mockGetDisplayName).toHaveBeenCalledTimes(1); // Or more, depending on entity mock usage

            // Inspect the calls made to the mock dispatchEventWithCatch
            console.log('>>> MOCK DISPATCH CALLS:', JSON.stringify(mockDispatchEventWithCatch.mock.calls, null, 2));

            // ** THE FAILING EXPECTATION **
            expect(mockDispatchEventWithCatch).toHaveBeenCalledTimes(1);

            // Verify the arguments of the single expected call
            const dispatchArgs = mockDispatchEventWithCatch.mock.calls[0];
            expect(dispatchArgs[0]).toBe(mockContext); // Context
            expect(dispatchArgs[1]).toBe('event:open_attempted'); // Event Name
            expect(dispatchArgs[2]).toEqual({ // Payload
                actorId: mockContext.playerEntity.id,
                targetEntityId: mockTargetEntity.id,
            });
            expect(dispatchArgs[3]).toBeInstanceOf(Array); // Messages array
            expect(dispatchArgs[4]).toEqual(expect.objectContaining({ // Log Details
                success: expect.stringContaining('Dispatched event:open_attempted'),
                errorUser: messagesUtils.TARGET_MESSAGES.INTERNAL_ERROR,
                errorInternal: expect.stringContaining('Failed to dispatch event:open_attempted')
            }));

            // 3. Verify overall result (returned by the mock handleAction...)
            expect(result.success).toBe(true);
            expect(result.messages).toBeDefined();
            expect(result.newState).toBeUndefined();
        });
    });

}); // End describe('executeOpen (Isolated Happy Path)')