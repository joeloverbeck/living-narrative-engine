# Advanced Health and Damage System Design for ECS Anatomy Engine

## Overview and Anatomy Graph Architecture

In this design, each character’s body is represented as a directed acyclic graph (DAG) of interconnected body part entities, consistent with the engine’s Entity Component System (ECS) approach. Each body part is an entity with its own components (e.g. anatomy data, health, descriptors) and is connected to other parts via sockets (attachment points). This forms a hierarchy (tree) of parts – for example, a torso part might have sockets for a head and arms, and the head in turn has sockets for eyes, ears, etc. The DAG structure ensures no cycles (a part doesn’t attach back to its ancestors), and it allows complex anatomies like multiple heads or limbs. Below is an illustrative anatomy graph for a humanoid character:

Character (Entity)
└─ Torso (entity: torso)
├─ Head (entity: head)
│ ├─ Left Eye (entity: eye_left)
│ ├─ Right Eye (entity: eye_right)
│ └─ Brain (entity: brain)
├─ Left Arm (entity: arm_left)
│ └─ Left Hand (entity: hand_left)
└─ Right Arm (entity: arm_right)
└─ Right Hand (entity: hand_right)

Each part entity has an anatomy:part component identifying its type and role, and an anatomy:sockets component defining its attachment points for child parts. This modular design means each body part can independently hold data like health, injuries, and status.

## Per-Part Health and Narrative Thresholds

Per-Part Health: Every body part entity will have a Health component (e.g. anatomy:health or similar) tracking its currentHealth and maxHealth values. This is analogous to the existing Breakable component for objects (which uses currentHp/maxHp), but specialized for anatomy parts. For example, a limb might have 100 max health points, while a delicate organ like an eye might have 20. All damage and healing is applied to these per-part health values, enabling granular tracking of injuries on each part of the body.

Health Thresholds & Narrative Labels: To translate raw health numbers into narrative descriptors, the system defines health thresholds that map the ratio of currentHealth to maxHealth into qualitative labels. When a part’s health falls into a certain range (or rises out of it due to healing), its status label updates automatically. The thresholds and labels can be data-driven (configurable in JSON) so designers or modders can adjust them. A typical default mapping might be:

Healthy: 100% to 75% of max health (no significant damage)

Bruised: 75% to 50% (minor damage; superficial wounds or bruises)

Wounded: 50% to 25% (moderate damage; noticeable wounds)

Badly Damaged: 25% to >0% (critical damage; the part is barely functional)

Destroyed: 0% (no health remaining; the part is destroyed or severed)

These ranges can be tuned (for instance, some games might label “Healthy” only at 100% and use different adjectives at higher granularity). The label is stored or computed for each part and can be accessed for narration or UI. As healing or further damage occurs, the engine checks if the part’s health crossed a threshold and updates the label accordingly. This update can trigger an event (e.g. a PartStateChanged event) to let other systems know the narrative state changed. For instance, if a limb’s health goes from 30% to 10%, its label would change from “Wounded” to “Badly Damaged,” possibly dispatching an update event. These narrative labels provide an at-a-glance understanding of each part’s condition and drive descriptive text.

Destroyed Parts: When a part’s health reaches zero (or below), it is considered “Destroyed” – meaning it’s effectively lost or non-functional. This could mean a limb has been severed or crushed, or an organ has been obliterated. A destroyed part typically cannot be used for its normal functions (e.g. a destroyed leg can’t support movement, a destroyed eye can’t see) and may require special intervention (prosthetics or magical regeneration) to restore (this is covered under healing). The system will mark the part’s state as destroyed (e.g. a boolean isDestroyed similar to isBroken for breakables) and fire events as needed. Destroyed parts also have unique narrative descriptors (for example, a destroyed part might be described as “missing” or “ruined” in text).

With per-part health and narrative thresholds, each body part becomes a self-contained unit of health, enabling detailed injury tracking. Players and the narrative system can get rich descriptions (e.g. “head is badly damaged” vs “arm is bruised”) rather than a single HP pool. This granularity lays the groundwork for targeted damage and immersive injury effects described next.

## Damage Application Mechanics

Targeting and Hit Distribution: Damage can be applied either to a specific body part (targeted damage) or to the body in general (untargeted or “general hit”). When damage is not explicitly aimed at a particular part, the system will determine which part is struck based on the anatomy graph and each part’s relative size or exposure. Each part definition includes a size or mass attribute (e.g. a numeric weight or size category) indicating how large/important the part is relative to the whole. The Damage System uses these weights to calculate a probability distribution – for example, the torso (largest) might have, say, 30% chance to be hit on a general attack, each arm 15%, the head 10%, etc., summing to 100%. A random roll (or other stochastic method) then selects the part hit. This means larger parts naturally soak more hits over time, while small targets are hit less often unless specifically aimed for. (Modders could adjust these probabilities by tweaking part sizes or an “impactProbability” field in part data.)

Socket-Based Propagation (Internal Damage): When a part that has child parts (internal organs or sub-parts) is hit, there is a chance that some of the contained parts also suffer damage. For example, if an attack strikes the torso, there’s a configurable probability that internal organs like the heart or lungs are also injured by the blow. Similarly, a hit to the head might also injure an eye or the brain. Each parent part can define a damage propagation configuration listing which child parts might be affected and the chance for each. This probability can also depend on the damage type (discussed in the next section) – e.g. a piercing attack might have a higher chance to pass through armor and hit internal organs, whereas blunt trauma might affect the surface more than the insides. The system can roll for each relevant child part when the parent is hit. If a propagation roll succeeds, a fraction of the damage (or a separate damage amount) is applied to that child part as well.

Example: Suppose the torso part has children: heart and lungs. The game designers set that whenever the torso is hit, there is a 30% chance the heart also takes damage and 50% chance for each lung, if the damage type is piercing (simulating a bullet or stab). If the damage type is blunt, those chances might be lower (say 10% heart, 20% lung, representing internal bruising). Now, if an arrow hits the torso for 40 damage, the system applies 40 to the torso’s health. Then it rolls for internals: it might determine the heart also gets hit (30% chance succeeded), applying perhaps 20 damage to the heart (using a configurable fraction, e.g. 50% of 40). This way, a single attack can wound multiple related parts, creating realistic injury cascades. Internal damage propagation is configurable per part and per damage type to allow fine-tuning per creature (e.g. a dragon’s vital organs might be well-protected, having a low propagation chance).

Direct Part Targeting: If an action or attack specifically targets a particular body part (e.g. an aimed headshot or “slash the enemy’s leg”), the system will apply the damage directly to that part without random selection. Targeted attacks may have accuracy or difficulty modifiers externally (game rules), but once they hit, the specified part’s health is reduced. The propagation to child parts still applies – e.g. if you specifically stab someone in the eye, the eye takes damage and perhaps the brain behind it could also be injured if the weapon penetrates deeply. Targeting allows players or AI to tactically disable certain body parts (like disarming an opponent by damaging an arm).

Damage Scaling by Part Size: The system may also consider the relative size of the part in how damage is applied. A very small part struck by a large attack might be completely destroyed (overkill damage might not carry over, or it might if using overall health – see Death logic). Conversely, a large part might absorb more of an attack’s force. For simplicity, our base design assumes damage values are directly subtracted from currentHealth of the part, but it’s possible to have a rule like “if a part is significantly smaller than the damage source, excess damage spills to connected parts or overall health.” This could be an enhancement if needed for balance, but by default each part just handles its own damage.

By combining weighted random targeting with internal damage propagation, the system supports both general hits that mostly affect larger body areas and called shots that zero in on specific parts. This mechanic ensures that combat feels realistic: most blows strike limbs or torso by chance, but critical hits can harm organs. The design is data-driven so modders can easily adjust part size weights and internal hit probabilities for new creature types or gameplay tuning.

## Damage Types and Special Effects

Not all damage is the same – a sword slash differs from a hammer blow or a fireball. The system defines a set of damage types, each with specific properties and effects. These damage types are data-driven: new types can be added via JSON definitions without engine code changes. A DamageType definition may include fields such as a name, descriptive properties, and flags for special behaviors. For example:

// Example schema for damage types
{
"id": "cutting",
"name": "Cutting",
"description": "Sharp cutting damage from blades. Causes external bleeding.",
"causesBleeding": true,
"bleedSeverity": "high",
"breaksBones": false,
"penetration": 0.8
}

In the above conceptual example, a “cutting” damage type causes bleeding, has high bleed severity, does not typically break bones, and has a high penetration value (meaning it easily cuts through flesh, possibly reaching internal parts). Contrast that with a blunt damage type:

{
"id": "blunt",
"name": "Blunt",
"description": "Crushing force trauma. Breaks bones but causes little external bleeding.",
"causesBleeding": false,
"breaksBones": true,
"stunChance": 0.3
}

A blunt attack might have a chance to stun or stagger a character and is good at breaking bones (perhaps causing an irreparable injury flag, discussed later). Meanwhile, piercing damage might combine aspects: moderate bleeding, high penetration to hit internals, etc. Other types can include fire, cold, acid, poison, magical, each with custom effects (burning could ignite a target causing ongoing fire damage; poison could inflict a status that drains health over time or imposes stat penalties; acid might continue eating away at a part for a few turns).

Bleeding Mechanic: One common special effect is bleeding. If a damage type has causesBleeding=true, when that damage is applied to a body part, the system will check the outcome. If the part is not destroyed outright, it may begin bleeding. Bleeding can be implemented by adding a Bleeding component to the injured part entity or by marking a field in the health component. The bleeding effect includes a severity (e.g. minor, moderate, severe) which could be derived from the damage amount or an explicit property of the damage type. For instance, cutting weapons might always cause at least moderate bleeding, while piercing causes minor bleeding unless a major artery is hit (which might be determined by whether an organ like the heart was struck). The engine will dispatch an event like character:bleeding_started for that part, which can be picked up by the Bleeding System and other systems (for example, an AI ally might react to seeing a friend bleed).

The Bleeding System runs at a regular interval (e.g. each turn). At the start of each turn, it will iterate over all body parts that have an active bleeding status. It will then apply ongoing damage (or health reduction) to those parts (or possibly to overall health, if modeling blood loss systemically). For example, a severe bleed might cause a part to lose 5 health per turn until staunched. If that part’s health hits 0 due to bleeding, it becomes destroyed (e.g. a leg that continues bleeding might effectively be ruined). The system could also reduce the character’s overall health or consciousness if severe bleeding is occurring, representing blood pressure loss – however, to keep things simple, we might just handle it at the part level and rely on overall health being the sum of parts. Bleeding will continue until something stops it: either a healing action (like bandaging or magical healing) removes or reduces the bleed, or a natural clotting (for minor wounds, perhaps the bleeding component auto-ends after some turns), or the character dies.

### Other Damage-Type Effects:

Bone Fracture: As noted, blunt damage could trigger broken bones. The system can flag a part as Broken if a blunt hit exceeds a certain threshold of the part’s max health (e.g. a hit doing >50% of bone part’s HP = fracture). A “broken” limb might function at reduced capacity even if it still has some HP (for example, a broken leg part might impose a movement penalty). Broken status might be represented by a status component on the part (distinct from health) and may require special healing (addressed in Healing section).

Burning: Fire or heat damage might ignite a character’s body part or equipment. This could be handled by a Burning component that causes ongoing damage similar to bleeding (though representing burns). Burn injuries might not bleed but instead risk infection or leave lasting scars.

Poison/Disease: A damage type (like venom or toxic gas) could apply a Poisoned status to the whole character (not just one part) – likely via an event that a specialized system picks up, since poison is more of a condition. Over time, the poison might tick down overall health or systematically damage multiple organs.

Dismemberment: High damage of certain types (sharp or explosive) might immediately sever a limb. The system would handle this as simply health dropping to 0 (destroying the part). But a special effect could be a check like “if damage > X% of max and type is cutting, instantly set currentHealth=0” to simulate a clean cut. This is an optional dramatic effect to ensure extremely powerful hits visibly remove parts rather than just heavily injure them.

All these special effects are managed in a data-driven and event-driven manner. Each damage application will be processed by the Damage System, which will look up the damage type’s properties and apply the corresponding logic: add bleeding component, mark broken bones, start fires, etc., and dispatch events. The use of components for ongoing effects (Bleeding, Burning, Poisoned, etc.) means the ECS can have dedicated systems handling each effect in parallel. This modular design keeps the damage application code straightforward (it mainly worries about immediate health reduction and flagging statuses) while delegating ongoing consequences to other systems.

By having damage types and effects defined in JSON, modders could introduce new damage types (e.g. “psychic damage” that only affects mental organs) or tweak existing ones (increase bleeding rates, etc.) without engine changes, fitting the modding-first philosophy.

## Death and Critical State Logic

The system must determine when an entity (character or creature) actually dies. In a detailed body-part model, death isn’t simply reaching 0 HP as in traditional games; instead it results from critical injuries to vital systems. We define several conditions that can cause death, and the engine will check these conditions whenever relevant (e.g. after damage is applied or at end of turn):

Brain/Thinking Organ Destruction: If a character loses all organs responsible for thought or consciousness, they die. For humanoids, this usually means the brain (often housed in the head). In our anatomy graph, we might have a brain part or simply consider the head part as the thinking organ if no separate brain entity. The game data should mark which parts count as “thinking organs” (this could be a property in the part’s definition or blueprint). For multi-headed or multi-brained creatures, all such parts must be destroyed for the character to be brain-dead. For example, a mythical hydra might have 5 heads – it dies only when all 5 are destroyed (unless other conditions like blood loss occur). The Death System will maintain a count of remaining functional thinking organs; if it drops to zero, that triggers death.

Heart/Pumping Organ Critical Damage: Many creatures rely on a heart or similar organ for circulation. If the heart is destroyed – or even critically damaged past a threshold – the character’s life is in immediate jeopardy. The blueprint can mark one or more parts as “pumping” vital organs (heart, hearts, central blood pump, etc.). The rule could be that if a heart is completely destroyed (0 HP), the character dies. Alternatively, for a bit more drama, the rule could say if the heart’s health falls to, say, Badly Damaged or below, the character enters a critical dying state (since the heart is failing). This allows perhaps a last moment for rescue (e.g. magical healing of the heart) before death occurs. If multiple hearts (some fantasy creatures have more than one heart), then all must be gone or failing similarly to be fatal – otherwise one heart might keep them alive albeit weakly.

Overall Health Threshold: In addition to specific organs, the system monitors the overall condition of the body. We define Overall Health as the aggregation of the health of all important parts (or simply the sum of all currentHealth values across the body, as a proxy for total bodily integrity). If the overall health drops below a critical fraction (e.g. 10% of total), the character can no longer sustain life. This condition represents massive trauma or blood loss even if no single organ was completely destroyed. For instance, someone who is grievously wounded in many places might die from shock or cumulative damage. In practice, the engine can compute totalMaxHealth as the sum of maxHealth of all parts (or of core parts only) and totalCurrentHealth as sum of currentHealth. If totalCurrentHealth / totalMaxHealth < 0.1 (10%), that triggers the death logic. Designers can adjust this percentage; 10% is a reasonable default to indicate a character is on the brink.

Immediate Lethal Hits: Some attacks might impose instant death regardless of the above (e.g. decapitation should kill even if technically overall health > 10%). However, those cases are naturally handled by the organ destruction rule (head destroyed => brain destroyed => death). Another example: an attack that obliterates the upper body might simultaneously destroy heart and more. So in general the above conditions cover most lethal situations.

Dying State vs. Instant Death: Rather than always killing the character the moment a condition is met, the system can introduce a “Dying” state as an intermediate step. This is a flag or component on the entity indicating they are critically wounded, incapacitated, and will die without intervention. When a fatal condition first occurs, the Death System could set the character to Dying = true and dispatch an event instead of immediately finalizing death. While Dying, the character might be unconscious or unable to act (game rules can enforce that), and a countdown or criteria for death is started. For example, if no one applies first aid or healing within 3 turns, or if another vital organ fails, then the character’s Dying state progresses to actual Death. This delay allows dramatic rescue opportunities and heroic last stands. It’s up to game logic whether every fatal injury uses the dying state or only some. We might say: destruction of the brain or decapitation is irreversible (instant death), but a failing heart or massive blood loss triggers dying status (giving a brief window to save the character). The conditions and durations for the dying state can be data-defined (e.g. a JSON rule that says “if heart destroyed, dying state for 1 turn then death” or “if overall health < 10%, dying state for 2 minutes”).

Death Finalization: When a character actually dies (either immediately or after a dying countdown), the system will: mark the entity as dead (could be a core:dead component or a state in the Health component), broadcast an entity_died event, and prevent any further actions by that entity (maybe involving the 'core:participating' component). Other systems may listen for this event – for example, a loot system might drop the character’s items, an AI system might have allies react to the death, etc. The engine ensures that event:entity_died is dispatched exactly once per death so listeners don’t duplicate reactions. At death, ongoing effects like bleeding would typically be stopped (no point in bleeding if you’re dead), and the body could be treated as an object for further interactions (looting, necromancy, etc., but that’s beyond scope).

In summary, the death logic is comprehensive and data-driven: it checks multiple failure criteria (brain, heart, total health) and supports a dying grace period for better gameplay. It’s flexible enough to accommodate non-humanoid anatomies (by configuring which parts are “vital”) and aligns with the narrative focus – deaths will occur in ways that make sense (e.g. described as “succumbing to wounds” if overall health drained, versus “instantly killed” if head destroyed).

## Healing and Irrecoverable Injuries

The system not only damages but also heals and recovers, within limits. Healing can come from various sources: potions, medical treatment, magic spells, natural regeneration, etc. The health system must support these by restoring currentHealth to injured parts and removing negative statuses, while respecting injuries that cannot be simply undone.

Healing Mechanics: A Healing action or event will typically target either the character in general or a specific part (similar to damage). If general, it may distribute healing points across the body’s parts or prioritize vital areas. A straightforward approach is for healing to apply to the most severely injured parts first – for example, a healing potion that restores 30 HP might automatically heal the part that is in worst condition (lowest health % or absolute deficit), then next, and so on, until expended. Alternatively, certain healing spells might specifically say they heal all parts in an area or one particular part (e.g. “Heal Arm” vs “Mass Cure”). The Healing System will interpret the healing effect based on its definition and increase the currentHealth of affected parts up to their maxHealth. As parts’ health crosses thresholds upward, their narrative state labels will update (e.g. a part goes from “Badly Damaged” back to “Wounded” or better as it heals). Corresponding health_changed events should be fired for positive changes too, so any UI or narrative can reflect “healing occurred” updates.

Stopping Bleeding: Healing actions (especially medical ones) may also stop ongoing effects like bleeding. For instance, using a bandage item might not restore HP, but it removes the Bleeding component from a part (stabilizing the wound). The design should allow a healing effect to specify that it stops bleeding on the target part(s), perhaps by dispatching a bleeding_stopped event or directly removing the bleeding status. This is important because sometimes first aid is about stabilizing (preventing further HP loss) rather than instantly restoring health.

Irrecoverable Injuries: Not all damage can be magically whisked away. The system supports the concept of injuries that cannot be healed by normal means. These include: completely destroyed body parts (e.g. a limb that’s been cut off), certain critical wounds like a crushed spine, or complex damage like a bone that healed improperly. To implement this, we introduce flags or separate status components for such injuries. For example, when a part is destroyed (health = 0), the engine could set a flag permanentDamage: true on that part. Normal healing potions might check for this flag and refuse to regenerate that part since it’s beyond ordinary repair. Similarly, a Broken Bone status might be a component that remains until a specific action (like a “set bone” or a long rest) removes it – basic healing spells might restore HP but not fix the break (the part might still operate at reduced efficiency or pain until properly healed).

A practical way to handle irrecoverable injuries is via injury types or tags on the part. For instance:

A severed limb might add a component anatomy:missing (with data about the missing part). While that component is present, generic healing won’t regrow the limb. Only a special “Regeneration” spell or advanced prosthetics system might clear that condition (and perhaps spawn a new part or restore the part’s entity with full health).

A broken bone could be a field on the part’s health component like broken: true. Standard healing could maybe restore the HP but leave broken: true (meaning the part is at full health but still non-functional due to the unset fracture). A different action (like a surgery or time passage) would be needed to clear the broken flag.

Healing Rules for Irrecoverables: The data for healing items/spells can specify whether they ignore certain injury flags. For example, a Healing Potion might have "healDestroyedParts": false meaning it only heals existing HP but won’t regrow a lost part. A Regeneration Elixir might say "healDestroyedParts": true and when applied, it finds destroyed parts and either dramatically heals them from 0 (effectively reattaching/regrowing them) or triggers a replacement mechanism. Some injuries might be marked “Unhealable” in general – e.g., maybe an enchanted curse wound that will not heal until the curse is lifted; this could be enforced by a component that continuously sets the part’s health back or prevents it from increasing beyond a point.

Persistent Consequences: To enhance narrative richness, even after a part is healed to full health, the system can leave behind descriptors of the injury. For example, a part that was badly damaged might get a scar descriptor attached once healed. This doesn’t affect mechanics but will appear in descriptions (“a long scar crosses his torso, a reminder of the battle”). Modders can control this by specifying if a damage event should add a lasting descriptor or trait to the part entity.

In summary, the healing system is robust but bounded: it can restore lost hit points and stop bleeding, but it respects flags for irrecoverable damage. This ensures that gameplay isn’t trivialized by easy healing – if an arm is cut off, a basic spell won’t just pop it back on. Players must seek specific remedies or accept the permanent loss, which adds weight to combat decisions and narrative consequences. All of this healing logic is implemented with the same ECS event approach (e.g. a useItem action triggers events that the HealingSystem or appropriate systems handle to apply the effects).

## Event System and Integration

Throughout this design, we’ve alluded to various events being dispatched. Here we detail the event-driven architecture that glues the health/damage system together and integrates it with the rest of the engine (including the modding system). The engine uses a central Event Bus pattern, where systems can emit events and other systems (or scriptable rules) can listen for them and react. For the health and damage domain, we introduce a set of domain-specific events:

Damage Events: When an entity is attacked or takes damage, an anatomy:damage_applied event is emitted. The payload would include the target entity ID, the amount of damage, the damage type, and which part(s) were affected. In a multi-part hit (like torso and heart both taking damage), it might dispatch separate events or one event with an array of affected parts. These events allow other systems to react – for instance, a Sound system might play an appropriate injury sound, or a Quest system might log that the character was injured.

Health Change Events: Any time a part’s currentHealth changes, the system emits anatomy:health_changed. The event payload will have the part ID, the old health and new health values, and possibly the cause (damage or healing). This event is crucial for UI updates (to redraw health bars or status indicators) and for triggering narrative responses. It’s mentioned in development notes that the engine should dispatch health_changed with correct values whenever damage is applied. The Health System itself may listen to these to check for threshold crossings (to update narrative labels or trigger threshold-specific effects).

Part State Events: When a part’s condition label changes (Healthy→Bruised, Wounded→Destroyed, etc.), the system can emit a specialized event, e.g. anatomy:part_state_changed with details of the new state. This could be considered a subset of health_changed, but having a distinct event is useful for narrative systems. For example, a Narration system might listen and generate a descriptive message: “Alice’s left arm is now badly damaged.” This separation keeps health logic and narration loosely coupled via events.

Bleeding Events: Starting or stopping bleeding on a part triggers anatomy:bleeding_started or anatomy:bleeding_stopped. Other systems (like a visual effect system or AI) could respond (NPCs might panic upon seeing blood, etc.). The Bleeding System itself might simply set the component and fire the event; the Turn Manager or similar will then call the Bleeding System each turn to apply damage. If bleeding causes a part to cross a threshold or die, further events cascade as normal.

Status Effect Events: Similarly, if a part or character is affected by a status like Poisoned, Stunned, Broken bone, etc., we dispatch events like anatomy:status_added (with details of which status). This allows, for example, the UI to show an icon or the narrative to note “<name> seems to be stunned.” When such status ends, status_removed events fire.

Death Events: As described, when a death is finalized, an entity_died event is fired exactly once. We also might have an entity_dying event when the dying state is first entered. These events inform all subsystems about the character’s state change. For instance, an AI system might remove the dead character from active combat, the Inventory system might unlock loot, and the Narrative system might queue a dramatic description of the death.

All these events are designed to be consumed by the engine’s rule system and other ECS systems. Because the engine is modding-first, we expect many of these events to have corresponding JSON rule triggers. For example, modders could write a rule that listens for anatomy:damage_applied and applies a specific effect if the damage type is certain (perhaps a mod that causes characters to drop their weapon if they take a heavy blunt hit to the arm – this could be done via a rule on the event, checking damage type and part == arm, then executing a drop action). The event names and payloads should be documented so that mod creators can hook into them easily.

In code, an example might look like: when damage is processed, we call something like eventBus.emit('anatomy:damage_applied', {...}). The HealthComponent or HealthSystem then updates health and calls eventBus.emit('anatomy:health_changed', {...}). If health <= 0, maybe the same system emits anatomy:part_destroyed. Separately, the DeathSystem listening to health changes or part_destroyed decides if whole entity death triggers, then emits entity_died. This sequence guarantees a clear chain of cause and effect that any subsystem can augment. For instance, a Logging system could listen to these and produce combat log messages (“Goblin takes 5 piercing damage to the head!”) for debugging or player feedback.

In conclusion, the event system is the backbone that integrates health/damage with the rest of the engine. It supports the modding-first goal by allowing content creators to inject logic at many points (via JSON-defined event listeners similar to the rules for actions). This makes the health and damage mechanics not a black box, but an extensible part of the game’s ecosystem.

## Injury Reporting and User Interface

To make the depth of this system player-comprehensible and to feed into narrative output (including LLM prompts), we need robust injury reporting. The engine will generate structured summaries of a character’s injuries for use in the UI and for narrative descriptions. The goal is to produce text like the example: "Emily's head, left eye, and left ear are badly damaged and bleeding. Her torso is bruised." in a systematic way.

Data Aggregation: The injury reporting functionality will likely be part of a Character Status System or UI system that queries the state of all body parts on a character. It will iterate through the anatomy graph of an entity and collect any part that is not in “Healthy” status. For each part, it will note its narrative status label (Bruised, Wounded, etc.) and whether that part is bleeding (and possibly other conditions like broken or missing). It may ignore very minor injuries (depending on design, maybe we don’t report Bruised if we want to reduce noise, or maybe we do — likely we do, for completeness). This collection results in a list of injury descriptors, which can be structured as an array of objects for programmatic use. For example:

[
{ "part": "head", "status": "Badly Damaged", "bleeding": true },
{ "part": "left eye", "status": "Badly Damaged", "bleeding": true },
{ "part": "left ear", "status": "Badly Damaged", "bleeding": true },
{ "part": "torso", "status": "Bruised", "bleeding": false }
]

This kind of data structure makes it easy to then format into human-readable text.

Narrative Formatting: With the collected data, the system forms sentences or phrases. A straightforward algorithm is to group parts by their severity level and bleeding status to create concise phrases. In the example given, the head, left eye, and left ear all share the same status (“badly damaged”) and all are bleeding, so they were grouped in one sentence. The torso, with a different status (“bruised”), was described separately. The formatting rules can be like: list all parts that share the highest severity, mention that severity and any common effect like bleeding. Use proper grammar (commas and “and” for the last item in a list). Then move to the next group of severity. Also, use pronouns or the character’s name appropriately (first sentence uses name or possessive, subsequent sentences can use pronoun if the context is clear, e.g. "Her torso is bruised."). We might integrate a small template system for this, or hardcode the logic if the style is fixed.

For example, pseudocode for report generation:

function generateInjuryReport(character):
partsByStatus = group non-healthy parts by status label (and bleeding)
sentenceList = []
for each group (status, bleeding) in descending severity:
partNames = list of part names in that group
if empty group: continue
// Construct phrase
statusText = status label (lowercase)
if bleeding == true:
statusText += " and bleeding"
// e.g. "badly damaged and bleeding"
partListText = commaJoin(partNames) // e.g. "head, left eye, and left ear"
sentence = character.name + "'s " + partListText + " are " + statusText + "."
sentenceList.append(sentence)
return sentences joined with " "

The result: "Emily's head, left eye, and left ear are badly damaged and bleeding. Her torso is bruised.".

We will also ensure the system uses the correct pluralization and possessives. Notice that after using "Emily's" for the first sentence, we switched to "Her" for the second. We can either always use the name’s possessive for clarity, or use pronouns after the first reference if needed. This is a minor linguistic detail that can be handled by the narrative component (perhaps by providing the character’s pronoun in their data).

LLM Prompt Integration: For the narrative engine (which might use large language models to generate story), these structured injury summaries are vital. They can be included in the context given to the LLM so it knows, for example, that Emily is bleeding from multiple injuries and her torso is bruised. This ensures the AI can mention or take into account her physical state in dialogue or action choices (e.g. an LLM character might say “I’m badly hurt…” or an ally might notice the blood). We might feed the LLM a snippet like: <InjuryStatus entity="Emily">Head: Badly Damaged (bleeding); Left Eye: Badly Damaged (bleeding); Left Ear: Badly Damaged (bleeding); Torso: Bruised.</InjuryStatus> or as a simple sentence as above. The exact format would be tuned to what the LLM understands best, but the information comes from the structured data.

By providing clear injury reports, we ensure that the complexity of the simulation is communicated to players and the narrative. This bridges the gap between the numeric model and storytelling, turning “15 HP left on arm” into “arm is wounded and bleeding” which is more immersive. It also helps players make decisions (e.g. seeing “left leg destroyed” tells them their character can’t walk on it). Overall, injury reporting is both a gameplay aid and a narrative enhancer, tightly integrated with the health system’s state.

## Support for Diverse Anatomies and Blueprint Configuration

One of the strengths of a data-driven ECS approach is the ability to handle vastly different creature anatomies with the same system. Our health and damage design is built to accommodate humanoids, animals, monsters, multi-headed beings, creatures with regenerative abilities, undead with no vital organs, etc., purely through configuration in the anatomy blueprints and part definitions.

Vital Organs per Blueprint: Each anatomy blueprint (the definition of a creature’s body structure) can specify which parts are considered vital and in what way. We can extend the blueprint JSON schema to include a section for vital roles. For example:

"vitals": {
"thinking": [ "anatomy:brain", "anatomy:head" ],
"pumping": [ "anatomy:heart" ],
"core": [ "anatomy:torso" ]
}

In this hypothetical snippet, the blueprint declares that any parts of type “brain” or “head” count as thinking organs, any part of type “heart” is a pumping organ, and the torso is considered a “core” part (perhaps meaning if the torso is destroyed, the creature cannot survive even if head/heart are intact). The Death System will then use these lists to evaluate death conditions, instead of hardcoding for specific part names. A multi-headed creature’s blueprint might list multiple heads in the thinking category, as shown. A creature could have multiple hearts listed under pumping (e.g. an octopus might have three hearts – all would need to fail). Undead like skeletons might have an empty pumping list (since they have no heart) and maybe “thinking: [skull]” if the skull is treated as the locus of whatever magic animates it. This could be done in a more data-driven way by including certain components in specific body parts. For example, a very specific 'anatomy:bearded_humanoid_head' could have the anatomy:allows_thinking component, and the relevant code would check for the presence of those components in anatomy nodes.

Damage Propagation Differences: Blueprints or part data can also control how damage propagates. For instance, a gelatinous cube monster might have no distinct organs; its blueprint could turn off internal damage propagation entirely (since it’s just one blob). A turtle-like creature might have a “shell” part that intercepts damage for internal parts (the shell could have a property that reduces or nullifies propagation of certain damage types to what’s inside it). We can implement this by giving parts attributes like protectionValue or simply by customizing the propagation probabilities as part of the creature’s data. The ECS system will use the specific entity’s configuration when calculating damage – meaning each creature follows the rules of its blueprint.

Anatomy Tags and Special Cases: The system might leverage tags on parts for general behaviors. For example, tag a part as vital: true for any organ that is absolutely essential (thinking or pumping). Or tag parts as locomotion (legs, wings) meaning if those are destroyed, the entity loses movement ability (not death, but important for gameplay). While locomotion loss isn’t directly death, it’s another blueprint-defined role that systems can use (e.g. MovementSystem checks if any locomotion parts are functional). This extends the idea of diverse anatomies to diverse functionality beyond just health – some creatures might have unique vital functions (e.g. a golem might have a “power core” as vital, which we could classify under pumping or just call it “core”).

Multi-Headed Creatures: A special note on multi-headed or multi-brained entities: Our death logic already covers “all thinking organs destroyed” for death. However, living with multiple heads might also affect other systems – for instance, if one head is destroyed but others remain, the creature is alive but perhaps suffers penalties (maybe reduced mental capacity or loss of whatever senses were on that head). The blueprint can define that as well. It might, for example, tie each head to a Mind component of the entity and the loss of a head could dispatch a mind_lost event or similar. While this drifts into AI, it’s relevant to consider for completeness: the health system should allow partial survival states like “one head left out of two” and ensure the character isn’t erroneously marked dead until the last one is gone.

Non-Humanoids and Unorthodox Biology: Our system can model non-standard life forms too. Imagine a plant-like creature with no brain or heart – its blueprint simply wouldn’t list any thinking or pumping vitals; instead it might have a “core” or just rely on overall health threshold for death. The Death System would interpret that as “this creature only dies when it’s taken enough total damage” since no specific organ triggers. Another example: an undead zombie could be set so that only destroying the head kills it (common trope). That blueprint’s vitals would be thinking: [head], and perhaps pumping empty (since it doesn’t need a heart). The total health threshold might be irrelevant if the zombie can keep going until the head is severed – we could even set the threshold very low or 0 for such creatures meaning overall damage won’t stop it, you must hit the vital point.

Blueprint-Driven Resistances and Immunities: Diverse anatomies might also interact with damage types differently. While not explicitly asked, it’s logical to mention: blueprint or part data could include resistances (e.g. skeletons might be immune to piercing (arrows) because they slip through bones, or a fire elemental is immune to fire damage). These would be implemented as part properties that the Damage System checks (e.g. if target has immunity: fire, then incoming fire damage is nullified or reduced). The question’s scope is health and damage, so including this note shows the system’s flexibility, though this is more of a combat mechanic.

Adaptability Example: If we introduce a new creature via mod – say a giant alien with two brains and four hearts – we’d create a blueprint listing two thinking organs and four pumping organs. Without any engine code change, the death logic will apply: the alien dies when both brains are gone or when all four hearts are destroyed (or overall health too low). We might also define that losing 1–2 hearts imposes some penalties but not death; this we can handle in the event system (e.g. a rule listening to a heart part being destroyed that applies a “weakened” status to the alien, but death only on the last heart lost).

In summary, the health and damage system’s rules for death and damage propagation are not hardwired to a human body – they are generalized. By data-driving vital part roles and anatomy configurations, we ensure the engine can handle creatures from a one-headed human to a hundred-headed hydra or even amorphous beings. This makes the game world feel consistent (each creature has believable weaknesses) and allows modders to go wild with creature design without needing new code for each new anatomy type.

## Additional Enhancements and Considerations

Beyond the core requirements, here are additional enhancements and ideas to improve gameplay, immersion, and narrative richness in the health and damage system:

Pain and Shock Mechanics: Introduce a concept of pain that corresponds to injuries. For example, when a character is Wounded or worse on any major part, they might accumulate a pain level. High pain could impose penalties on actions (simulating the difficulty of fighting while hurt) or risk the character falling into shock/unconsciousness. A system could track pain as a numeric value (perhaps proportional to % of health lost across the body) and compare it to a pain tolerance (could be a character attribute). If pain exceeds tolerance, the character might be stunned or pass out. This adds a layer of realism – even if an injury isn’t immediately fatal, it can take someone out of a fight. Narratively, it gives cues like “grimacing in pain” or needing to grit their teeth to continue. Pain could be reduced by certain items (morphine, magical calm) separate from healing HP.

Temporary vs. Permanent Effects: To increase immersion, not every effect should last forever. We touched on scars and permanent loss, but also consider temporary debuffs: e.g. after taking a heavy blow to the head, a character could have a “Dazed” status for a few turns (blurry vision, etc.). A leg wound might inflict a “Limping” status reducing speed until healed above a threshold. These statuses make injuries more than just HP loss – they change gameplay moment-to-moment. The system can implement these via events (e.g. when a part goes to Badly Damaged, add a Limping component if that part is a leg). Removing the status when healed back above the threshold (or after some time) can also be handled with events or periodic checks.

Environmental Interactions with Blood: For greater narrative depth, consider that bleeding could have environmental effects. For example, blood on the ground could make surfaces slippery (affecting movement in that location) or attract predators/monsters that smell blood. This could be implemented by having the Bleeding System drop a “blood pool” entity in the location when severe bleeding occurs. That entity might have properties that certain AI detect (e.g. wolves get a stimulus when near blood). This ties the health system into the world ecosystem and can lead to emergent situations (a badly injured character might inadvertently lure a shark in the water or a pack of wolves in a forest, adding urgency to heal or escape).

Integration with Armor and Equipment: A realistic damage system should consider armor on body parts. As an enhancement, each body part could have an Armor component if covered by equipment (like a helmet on head, cuirass on torso). Before applying damage to the part, the system checks armor rating and damage type interactions. For example, cutting damage might be reduced heavily by plate armor, blunt might still do some through armor (bruising), and piercing might ignore some percentage if armor coverage isn’t full. This could be extended by an Armor Damage system – armor itself has durability (HP) and can break after absorbing damage, which then exposes the part beneath. This adds a layer of strategy (targeting unarmored parts, maintaining your gear) and narrative ( “The arrow punctures the knight’s armor, hitting flesh!” ).

Critical Hits & Injuries: The system can incorporate a critical hit mechanism where certain hits cause especially severe consequences beyond just extra damage. For instance, a critical hit could force an immediate roll on a injury table (even if part isn’t at 0 HP, it might still lose a finger, etc.). This is more of a game design flavor – e.g. in a tabletop RPG style, a critical might blind an eye or sever an ear even if it didn’t fully deplete that part’s HP. Because we already model body parts, we can actually reflect that (e.g. eye “destroyed” even if head is not destroyed). The rules for critical effects could be data-driven events (triggered on high dice roll or specific conditions).

Long-Term Consequences and Recovery: For narrative richness, consider that recovery from injuries might take time or special training. If the game timeline allows, a character who was badly injured might suffer chronic effects if not properly treated. For example, a badly damaged arm that was just left to heal with basic magic might regain HP but the character could have a “Weak Grip” trait thereafter. Proper rehabilitation (maybe a side-quest or extended downtime) could remove it. This encourages players to address injuries in story ways, not just HP numbers. From a system perspective, it means logging serious injuries and potentially adding long-term tags on the character that only clear via specific events.

LLM Narrative Enhancements: Since the game uses an LLM for emergent narrative, we can leverage the health system data to prompt more vivid storytelling. For example, when generating narrative, the system could include not just the injury summary but also descriptive hints: if a character’s part is in Badly Damaged state, provide adjectives like “agonizingly” or “grievously” to color the LLM’s descriptions of the character’s demeanor. These details can be algorithmically generated based on the part and damage type (a cut wound vs a burn wound would be described differently). Essentially, use the mechanics to feed the LLM contextual flavor.

By implementing these enhancements thoughtfully, we greatly enrich gameplay and storytelling. Players will feel the impact of every injury, not just in numbers but in how their characters perform and how the world reacts. Meanwhile, the narrative layer will have plenty of material to create gripping tales of heroism and desperation. Importantly, all these additions remain data-driven and modular, so the complexity can be tailored to the project’s needs. This advanced health and damage system, with its per-part precision and event-driven design, will form a cornerstone of an immersive, emergent gameplay experience where what happens to the characters’ bodies genuinely matters in the game world.
