/**
 * @file security-middleware-header-validation-success.integration.test.js
 * @description Integration test ensuring the security configuration validator
 *              recognizes when all required headers are present and avoids
 *              producing unnecessary warnings. The scenario mirrors how the
 *              enhanced security middleware is composed in the real server
 *              setup without any mocking.
 */

import { describe, it, expect, jest } from '@jest/globals';
import express from 'express';
import request from 'supertest';

import {
  createSecurityConfigValidator,
  createSecurityMiddleware,
} from '../../src/middleware/security.js';

describe('Security middleware header validation success flow', () => {
  it('preserves required headers and skips warning logging when configuration is correct', async () => {
    const logger = {
      warn: jest.fn(),
      error: jest.fn(),
    };

    const app = express();
    app.use(createSecurityMiddleware());
    app.use(createSecurityConfigValidator({ logger }));

    app.get('/secure', (req, res) => {
      res.json({
        nonce: req.cspNonce,
        appliedTimestamp: res.get('X-Security-Applied'),
        permissionsPolicy: res.get('Permissions-Policy'),
      });
    });

    const response = await request(app).get('/secure');
    expect(response.status).toBe(200);

    // Helmet should provide these headers and the validator should see them all.
    const expectedHeaders = [
      'x-content-type-options',
      'x-frame-options',
      'strict-transport-security',
      'content-security-policy',
      'x-csp-nonce',
      'x-security-applied',
      'permissions-policy',
    ];
    for (const header of expectedHeaders) {
      expect(response.headers[header]).toBeDefined();
    }

    // Ensure the nonce generated by the security middleware propagates through the request lifecycle.
    expect(response.body.nonce).toEqual(response.headers['x-csp-nonce']);
    expect(response.body.appliedTimestamp).toEqual(
      response.headers['x-security-applied']
    );
    expect(typeof response.body.permissionsPolicy).toBe('string');

    // Wait for the finish event to give the validator time to inspect headers.
    await new Promise((resolve) => setImmediate(resolve));

    expect(logger.warn).not.toHaveBeenCalled();
    expect(logger.error).not.toHaveBeenCalled();
  });
});
