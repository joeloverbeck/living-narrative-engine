# Axis Space Analysis Implementation Report

This document explains the implementation details of the "Axis Space Analysis" section in `prototype-analysis.html`. The analysis is performed by `AxisGapAnalyzer.js` and rendered by `PrototypeAnalysisController.js`.

## Overview

The Axis Space Analysis runs four sequential analysis phases:
1. **Dimensionality Analysis (PCA)** - Identifies unexplained variance in prototype data
2. **Hub Prototype Detection** - Finds prototypes with high connectivity in the overlap graph
3. **Coverage Gap Detection** - Identifies clusters of prototypes far from existing axes
4. **Multi-Axis Conflict Detection** - Finds prototypes with unusual axis usage patterns

Each phase can generate recommendations. The final "Potential Gaps" count equals the total number of recommendations generated.

---

## 1. How "Potential Gaps" Value is Determined

**Location:** `AxisGapAnalyzer.js` → `#synthesizeReport()` method

```javascript
#synthesizeReport(pcaAnalysis, hubs, coverageGaps, multiAxisConflicts, recommendations) {
  return {
    summary: {
      potentialGapsDetected: recommendations.length,  // <-- THIS IS THE VALUE
      pcaResidualVariance: pcaAnalysis.residualVarianceRatio,
      hubCount: hubs.length,
      coverageGapCount: coverageGaps.length,
      multiAxisConflictCount: multiAxisConflicts.length,
    },
    // ... rest of report
  };
}
```

**Key insight:** `potentialGapsDetected` is simply the count of recommendations generated by `#generateRecommendations()`. It is NOT a separate calculation - it reflects how many actionable suggestions the analysis produced based on all detected signals.

---

## 2. Dimensionality Analysis (PCA)

**Location:** `AxisGapAnalyzer.js` → `#runPCAAnalysis()` method

### Algorithm Steps

1. **Build Weight Matrix** (`#buildWeightMatrix`):
   - Creates an N×M matrix where N = number of prototypes, M = number of axes
   - Each cell contains the axis weight from the prototype's profile
   - Axes tracked: Dynamically collected from prototype weights at runtime. No hardcoded list - the system adapts to whatever axes are present in prototype data (up to 19 axes: 10 mood + 4 affect traits + 5 sexual).

2. **Standardize Matrix** (`#standardizeMatrix`):
   - For each column (axis), computes mean and standard deviation
   - Applies z-score normalization: `(value - mean) / stdDev`
   - Handles zero standard deviation by leaving values as 0

3. **Compute Covariance Matrix** (`#computeCovariance`):
   - Computes M×M covariance matrix from standardized data
   - Uses formula: `cov[i][j] = sum((x[k][i] - mean_i) * (x[k][j] - mean_j)) / (n - 1)`

4. **Eigenvalue Decomposition** (`#computeEigenDecomposition`):
   - Uses **Jacobi eigenvalue algorithm** with up to 50 iterations
   - Convergence threshold: `1e-10`
   - Returns eigenvalues and eigenvectors sorted by eigenvalue (descending)

5. **Calculate Metrics**:
   ```javascript
   // Sum of all eigenvalues
   const totalVariance = eigenvalues.reduce((sum, val) => sum + val, 0);

   // Count components with eigenvalue >= 1.0 (Kaiser criterion)
   const significantComponents = eigenvalues.filter(
     (val) => val >= this.#config.pcaKaiserThreshold
   ).length;

   // Expected axis count (number of axes in the system)
   const expectedAxisCount = this.#computeExpectedAxisCount();

   // Variance explained by significant components
   const explainedBySignificant = eigenvalues
     .slice(0, significantComponents)
     .reduce((sum, val) => sum + val, 0);

   // CRITICAL METRIC: Residual variance ratio
   const residualVarianceRatio = 1 - explainedBySignificant / totalVariance;
   ```

6. **Compute Extreme Prototypes** (`#computeExtremePrototypes`):
   - For each significant principal component, finds prototypes with highest absolute projection scores
   - Returns prototype IDs sorted by score magnitude
   - **NOTE**: These are PCA *scores* (prototype projections onto the component), NOT *loadings* (axis contributions to the component). Values outside [-1, 1] are expected for scores.

### Configuration Thresholds

| Parameter | Default Value | Purpose |
|-----------|---------------|---------|
| `pcaResidualVarianceThreshold` | `0.15` | If residual variance ratio exceeds this, suggests unexplained variance |
| `pcaKaiserThreshold` | `1.0` | Eigenvalue threshold for significant components (Kaiser criterion) |

### When PCA Triggers a Recommendation

A recommendation is generated when:
```javascript
if (pcaAnalysis.residualVarianceRatio > this.#config.pcaResidualVarianceThreshold) {
  recommendations.push({
    type: 'pca_residual',
    priority: 'medium',
    message: 'PCA analysis suggests unexplained variance. Investigate the extreme prototypes for potential axis candidates.',
    evidence: {
      residualVariance: pcaAnalysis.residualVarianceRatio,
      threshold: this.#config.pcaResidualVarianceThreshold,
      // topLoadingPrototypes contains objects with { prototypeId, score }
      // where 'score' is the prototype's projection onto the unexplained component
      topLoadings: pcaAnalysis.topLoadingPrototypes,
    },
  });
}
```

---

## 3. Hub Prototypes Detection

**Location:** `AxisGapAnalyzer.js` → `#identifyHubPrototypes()` method

### Algorithm Steps

1. **Build Overlap Graph** (`#buildOverlapGraph`):
   - Creates adjacency list from `pairResults` (overlap analysis results)
   - Each edge stores: `partnerId`, `overlapType`, `coPassProbability`, `behavioralScore`, `gateImplication`
   - Edge weight computed by `#computeCompositeEdgeWeight`:
     ```javascript
     #computeCompositeEdgeWeight(edge) {
       const coPass = edge.coPassProbability ?? 0;
       const behavioral = edge.behavioralScore ?? 0;
       // Weighted combination: 60% co-pass probability, 40% behavioral score
       return 0.6 * coPass + 0.4 * behavioral;
     }
     ```

2. **Filter Candidates**:
   - **Minimum degree**: Must have at least `hubMinDegree` connections (default: 4)
   - **Maximum edge weight**: Average edge weight must be ≤ `hubMaxEdgeWeight` (default: 0.9)
     - Rationale: Very high edge weights suggest near-duplicates, not hubs
   - **Neighborhood diversity**: Must connect to prototypes spanning at least `hubMinNeighborhoodDiversity` distinct axes (default: 2)

3. **Compute Hub Score** (`#computeHubScore`):
   ```javascript
   #computeHubScore(prototypeId, graph) {
     const edges = graph.get(prototypeId);
     const degree = edges.length;
     const avgWeight = edges.reduce((sum, e) => sum + this.#getEdgeWeight(e), 0) / degree;
     const diversity = this.#getNeighborhoodDiversity(edges);

     // Hub score formula: degree * diversity * (1 - avgWeight)
     // High degree + high diversity + moderate weights = high hub score
     return degree * diversity * (1 - avgWeight);
   }
   ```

4. **Get Neighborhood Diversity** (`#getNeighborhoodDiversity`):
   - Counts unique primary axes among connected prototypes
   - Uses each neighbor's highest-weighted axis as their "primary axis"

### Configuration Thresholds

| Parameter | Default Value | Purpose |
|-----------|---------------|---------|
| `hubMinDegree` | `4` | Minimum connections to be considered a hub |
| `hubMaxEdgeWeight` | `0.9` | Maximum average edge weight (filters out near-duplicates) |
| `hubMinNeighborhoodDiversity` | `2` | Minimum distinct axes in neighborhood |

### When Hubs Trigger a Recommendation

```javascript
if (hubs.length > 0) {
  recommendations.push({
    type: 'hub_prototypes',
    priority: 'low',
    message: `Found ${hubs.length} hub prototype(s) that connect multiple axis regions. These may represent emotional blends deserving dedicated axis space.`,
    evidence: {
      hubs: hubs.map((h) => ({
        id: h.prototypeId,
        score: h.hubScore,
        connections: h.connections,
      })),
    },
  });
}
```

---

## 4. Coverage Gaps Detection

**Location:** `AxisGapAnalyzer.js` → `#detectCoverageGaps()` method

### Algorithm Steps

1. **Extract Clusters** (`#extractClusters`):
   - Uses k-means clustering on intensity vectors (full axis space)
   - Each prototype is assigned to the cluster with nearest centroid by L2 distance
   - Cluster IDs are `cluster-0`, `cluster-1`, etc. (geometry-based, NOT axis-named)
   - **NOTE**: Clusters are NOT grouped by "highest-weighted axis" - the assignment uses squared Euclidean distance to k-means centroids

2. **Compute Cluster Centroids**:
   - For each cluster, averages the weight values across all axes
   - Result: A representative point in axis-space for each cluster

3. **Get Axis Unit Vectors** (`#getAxisUnitVectors`):
   - Creates unit vectors for each axis (e.g., valence axis = [1, 0, 0, 0, 0, 0])
   - These represent the "pure" positions of each defined axis

4. **Compute Nearest Axis Distance** (`#computeNearestAxisDistance`):
   - For each cluster centroid, finds the minimum cosine distance to any axis unit vector
   - Uses cosine distance: `1 - cosineSimilarity`
   - Cosine similarity: `dotProduct / (magnitude1 * magnitude2)`

5. **Filter Coverage Gaps**:
   - Clusters where `nearestAxisDistance > coverageGapAxisDistanceThreshold` (default: 0.6)
   - AND cluster size ≥ `coverageGapMinClusterSize` (default: 3)

### Configuration Thresholds

| Parameter | Default Value | Purpose |
|-----------|---------------|---------|
| `coverageGapAxisDistanceThreshold` | `0.6` | Minimum distance from axes to be considered a gap |
| `coverageGapMinClusterSize` | `3` | Minimum prototypes in cluster to warrant attention |

### When Coverage Gaps Trigger a Recommendation

```javascript
if (coverageGaps.length > 0) {
  recommendations.push({
    type: 'coverage_gap',
    priority: 'high',
    message: `Detected ${coverageGaps.length} cluster(s) of prototypes distant from all existing axes. Consider defining new axes to cover these regions.`,
    evidence: {
      gaps: coverageGaps.map((g) => ({
        dominantAxis: g.dominantAxis,
        distance: g.nearestAxisDistance,
        size: g.clusterSize,
        members: g.members.slice(0, 5), // Top 5 examples
      })),
    },
  });
}
```

---

## 5. Multi-Axis Conflicts Detection

**Location:** `AxisGapAnalyzer.js` → `#detectMultiAxisConflicts()` method

### Algorithm Steps

1. **Compute Axis Usage Per Prototype**:
   - For each prototype, counts how many axes have non-zero weight in their profile
   - Creates array of `{ prototypeId, axisCount }` objects

2. **IQR-Based Outlier Detection**:
   ```javascript
   // Sort axis counts
   const counts = usageData.map((d) => d.axisCount).sort((a, b) => a - b);

   // Calculate quartiles
   const q1 = counts[Math.floor(counts.length * 0.25)];
   const q3 = counts[Math.floor(counts.length * 0.75)];
   const iqr = q3 - q1;

   // Upper fence (multiplied by threshold)
   const upperFence = q3 + this.#config.multiAxisUsageThreshold * iqr;

   // Outliers: prototypes exceeding upper fence
   const outliers = usageData.filter((d) => d.axisCount > upperFence);
   ```

3. **Sign Balance Filtering**:
   - For each outlier, computes sign balance across all axes:
     ```javascript
     // Count positive and negative weights
     const positive = Object.values(profile.weights).filter((w) => w > 0).length;
     const negative = Object.values(profile.weights).filter((w) => w < 0).length;
     const total = positive + negative;

     // Balance ratio: 0 = all same sign, 1 = perfectly balanced
     const signBalance = total > 0 ? Math.min(positive, negative) / Math.max(positive, negative) : 0;
     ```
   - Only includes outliers where `signBalance >= multiAxisSignBalanceThreshold` (default: 0.4)
   - Rationale: Prototypes using many axes with balanced positive/negative weights may indicate complex blended emotions

### Configuration Thresholds

| Parameter | Default Value | Purpose |
|-----------|---------------|---------|
| `multiAxisUsageThreshold` | `1.5` | IQR multiplier for outlier detection |
| `multiAxisSignBalanceThreshold` | `0.4` | Minimum sign balance to flag as conflict |

### When Multi-Axis Conflicts Trigger a Recommendation

```javascript
if (multiAxisConflicts.length > 0) {
  recommendations.push({
    type: 'multi_axis_conflict',
    priority: 'medium',
    message: `Found ${multiAxisConflicts.length} prototype(s) with unusually high multi-axis usage. These may benefit from dedicated representation.`,
    evidence: {
      conflicts: multiAxisConflicts.map((c) => ({
        id: c.prototypeId,
        axisCount: c.axisCount,
        signBalance: c.signBalance,
      })),
      threshold: upperFence,
    },
  });
}
```

---

## 6. Recommendation Generation Logic

**Location:** `AxisGapAnalyzer.js` → `#generateRecommendations()` method

### Individual Signal Recommendations

Each analysis phase can independently generate a recommendation (see sections above). The priority levels are:

| Signal Type | Priority | Condition |
|-------------|----------|-----------|
| PCA Residual Variance | `medium` | `residualVarianceRatio > 0.15` |
| Hub Prototypes | `low` | `hubs.length > 0` |
| Coverage Gaps | `high` | `coverageGaps.length > 0` |
| Multi-Axis Conflicts | `medium` | `multiAxisConflicts.length > 0` |

### Compound Signal Recommendations

The system also detects combinations of signals that together suggest stronger evidence:

```javascript
// Compound: PCA + Coverage Gaps
if (
  pcaAnalysis.residualVarianceRatio > this.#config.pcaResidualVarianceThreshold &&
  coverageGaps.length > 0
) {
  recommendations.push({
    type: 'compound_pca_coverage',
    priority: 'high',
    message: 'Both PCA residual variance and coverage gaps detected. Strong evidence for missing axis dimensions.',
    evidence: {
      pcaResidual: pcaAnalysis.residualVarianceRatio,
      gapCount: coverageGaps.length,
    },
  });
}

// Compound: Hubs + Multi-Axis Conflicts
if (hubs.length > 0 && multiAxisConflicts.length > 0) {
  // Find intersection
  const hubIds = new Set(hubs.map((h) => h.prototypeId));
  const conflictIds = new Set(multiAxisConflicts.map((c) => c.prototypeId));
  const intersection = [...hubIds].filter((id) => conflictIds.has(id));

  if (intersection.length > 0) {
    recommendations.push({
      type: 'compound_hub_conflict',
      priority: 'high',
      message: `${intersection.length} prototype(s) are both hubs and multi-axis outliers. These are strong candidates for new axis definitions.`,
      evidence: {
        candidates: intersection,
      },
    });
  }
}
```

### Recommendation Messages Reference

| Type | Message Text |
|------|--------------|
| `pca_residual` | "PCA analysis suggests unexplained variance. Investigate the top-loading prototypes for potential axis candidates." |
| `hub_prototypes` | "Found N hub prototype(s) that connect multiple axis regions. These may represent emotional blends deserving dedicated axis space." |
| `coverage_gap` | "Detected N cluster(s) of prototypes distant from all existing axes. Consider defining new axes to cover these regions." |
| `multi_axis_conflict` | "Found N prototype(s) with unusually high multi-axis usage. These may benefit from dedicated representation." |
| `compound_pca_coverage` | "Both PCA residual variance and coverage gaps detected. Strong evidence for missing axis dimensions." |
| `compound_hub_conflict` | "N prototype(s) are both hubs and multi-axis outliers. These are strong candidates for new axis definitions." |

---

## 7. Configuration Reference

**Location:** `src/expressionDiagnostics/config/prototypeOverlapConfig.js`

```javascript
// Axis Gap Detection Settings
enableAxisGapDetection: true,

// PCA Analysis
pcaResidualVarianceThreshold: 0.15,  // Trigger if unexplained variance > 15%
pcaKaiserThreshold: 1.0,             // Kaiser criterion for significant components

// Hub Detection
hubMinDegree: 4,                     // Minimum connections to be a hub
hubMaxEdgeWeight: 0.9,               // Maximum average edge weight
hubMinNeighborhoodDiversity: 2,      // Minimum distinct axes in neighborhood

// Coverage Gap Detection
coverageGapAxisDistanceThreshold: 0.6,  // Cosine distance threshold
coverageGapMinClusterSize: 3,           // Minimum cluster size

// Multi-Axis Conflict Detection
multiAxisUsageThreshold: 1.5,           // IQR multiplier for outliers
multiAxisSignBalanceThreshold: 0.4      // Minimum sign balance ratio
```

---

## 8. Data Flow Architecture

```
PrototypeOverlapAnalyzer.js
    │
    │ Calls: axisGapAnalyzer.analyze(prototypes, outputVectors, profiles, pairResults)
    │
    ▼
AxisGapAnalyzer.js
    │
    ├── #runPCAAnalysis(outputVectors, profiles)
    │       └── Returns: { residualVarianceRatio, significantComponents, topLoadings, ... }
    │
    ├── #identifyHubPrototypes(pairResults)
    │       └── Returns: [{ prototypeId, hubScore, connections, neighborhoodDiversity }, ...]
    │
    ├── #detectCoverageGaps(profiles)
    │       └── Returns: [{ dominantAxis, nearestAxisDistance, clusterSize, members }, ...]
    │
    ├── #detectMultiAxisConflicts(profiles)
    │       └── Returns: [{ prototypeId, axisCount, signBalance }, ...]
    │
    ├── #generateRecommendations(pcaAnalysis, hubs, coverageGaps, multiAxisConflicts)
    │       └── Returns: [{ type, priority, message, evidence }, ...]
    │
    └── #synthesizeReport(...)
            └── Returns: { summary, dimensionalityAnalysis, hubPrototypes, coverageGaps, multiAxisConflicts, recommendations }
    │
    ▼
PrototypeAnalysisController.js
    │
    └── #renderAxisGapAnalysis(report)
            ├── #renderAxisGapSummary(summary)     → "Potential Gaps: N"
            ├── #renderPCAAnalysis(dimensionality) → PCA details
            ├── #renderHubPrototypes(hubs)         → Hub list
            ├── #renderCoverageGaps(gaps)          → Gap clusters
            ├── #renderMultiAxisConflicts(...)     → Conflict list
            └── #renderAxisGapRecommendations(...) → Recommendation cards
```

---

## 9. Potential Areas for Investigation

### Mathematical Accuracy

1. **PCA Implementation**: The Jacobi eigenvalue algorithm is correct but may have numerical stability issues with:
   - Very small datasets (< 10 prototypes)
   - Highly correlated axes
   - Near-zero variance in some axes

2. **Cosine Distance Calculation**: Verify handling of zero-magnitude vectors in coverage gap detection

3. **IQR Calculation**: Check edge cases when quartiles fall between array indices

### Threshold Calibration

1. **`pcaResidualVarianceThreshold: 0.15`**: Is 15% the right threshold? May need tuning based on actual data distributions

2. **`hubMinDegree: 4`**: With small prototype sets, this may be too restrictive

3. **`coverageGapAxisDistanceThreshold: 0.6`**: The cosine distance range (0-2) means 0.6 is relatively permissive

### Logic Issues to Verify

1. **Empty Data Handling**: What happens when:
   - No prototypes have profiles
   - All prototypes have identical weights
   - pairResults is empty

2. **Compound Recommendation Logic**: The intersection logic for `compound_hub_conflict` may miss edge cases

3. **Recommendation Deduplication**: Are there scenarios where the same underlying issue generates multiple recommendations?

### Performance Concerns

1. **Eigendecomposition**: O(n³) complexity for n axes - acceptable for 6 axes but may not scale

2. **Graph Building**: Creating adjacency lists from all pair results could be expensive with many prototypes

---

## 10. File Reference Summary

| File | Purpose |
|------|---------|
| `src/expressionDiagnostics/services/AxisGapAnalyzer.js` | Core analysis implementation |
| `src/expressionDiagnostics/config/prototypeOverlapConfig.js` | Configuration thresholds |
| `src/expressionDiagnostics/services/PrototypeOverlapAnalyzer.js` | Orchestrates axis gap analysis |
| `src/domUI/prototype-analysis/PrototypeAnalysisController.js` | Renders results in UI |

---

*Report generated for investigation of Axis Space Analysis implementation in Living Narrative Engine.*
