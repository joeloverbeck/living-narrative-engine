/**
 * @file Integration tests for TargetResolutionService using the real UnifiedScopeResolver.
 * @description Exercises collaborative behaviour between the resolution service and the
 * unified resolver without relying on Jest mocks for the core modules. The test harness
 * wires in lightweight concrete dependencies so that scope evaluation flows through the
 * production code paths.
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { TargetResolutionService } from '../../../src/actions/targetResolutionService.js';
import { UnifiedScopeResolver } from '../../../src/actions/scopes/unifiedScopeResolver.js';
import { ActionTargetContext } from '../../../src/models/actionTargetContext.js';
import SimpleEntityManager from '../../common/entities/simpleEntityManager.js';

/**
 * Entity manager with a couple of helpers the unified resolver expects during validation.
 */
class TestEntityManager extends SimpleEntityManager {
  getAllComponentTypesForEntity(entityId) {
    const entity = this.entities.get(entityId);
    return entity ? Object.keys(entity.components) : [];
  }

  getEntities() {
    return Array.from(this.entities.values()).map((entity) => ({
      id: entity.id,
      components: entity.components,
    }));
  }

  getEntitiesWithComponent(componentId) {
    const matches = [];
    for (const entity of this.entities.values()) {
      if (Object.prototype.hasOwnProperty.call(entity.components, componentId)) {
        matches.push({ id: entity.id, components: entity.components });
      }
    }
    return matches;
  }
}

/**
 * Minimal action error context builder used by the resolver when failures happen.
 */
class TestActionErrorContextBuilder {
  buildErrorContext({ error, actorId, phase, additionalContext }) {
    return {
      error,
      actorId,
      phase,
      timestamp: Date.now(),
      additionalContext,
    };
  }
}

/**
 * Lightweight scope registry that exposes the real API expected by UnifiedScopeResolver.
 */
class TestScopeRegistry {
  constructor(definitions) {
    this.definitions = definitions;
  }

  getScope(name) {
    return this.definitions[name] ?? null;
  }
}

/**
 * Scope engine that understands a small AST vocabulary for the tests. It inspects the
 * runtime context generated by UnifiedScopeResolver to produce entity id sets.
 */
class TestScopeEngine {
  constructor(entityManager) {
    this.entityManager = entityManager;
  }

  resolve(ast, actor, runtimeCtx) {
    if (!ast || typeof ast !== 'object') {
      throw new Error('Invalid AST provided to scope engine');
    }

    switch (ast.type) {
      case 'match-location': {
        const includeSelf = ast.includeSelf ?? false;
        const locationId = runtimeCtx.location;
        const matches = [];

        for (const entity of this.entityManager.entities.values()) {
          const entityLocation = entity.components['core:position']?.locationId;
          if (entityLocation === locationId) {
            if (!includeSelf && entity.id === actor.id) {
              continue;
            }
            matches.push(entity.id);
          }
        }

        return new Set(matches);
      }
      case 'direct': {
        return new Set(ast.targetIds ?? []);
      }
      case 'empty': {
        return new Set();
      }
      case 'error': {
        throw new Error('Scope evaluation failed intentionally');
      }
      default:
        return new Set();
    }
  }
}

/**
 * JsonLogic evaluation service stub – the scopes under test do not require JSON Logic, but
 * UnifiedScopeResolver validates the dependency exists.
 */
class TestJsonLogicEvaluationService {
  evaluate() {
    return true;
  }
}

/**
 * DSL parser stub – definitions include pre-baked ASTs so the parser is never invoked, but
 * the resolver validates the dependency.
 */
class TestDslParser {
  parse(expr) {
    return { type: 'direct', targetIds: expr ? expr.split(',') : [] };
  }
}

/**
 * Creates a fully wired TargetResolutionService instance backed by a real UnifiedScopeResolver.
 */
function createTargetResolutionHarness() {
  const logger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
  };

  const entityManager = new TestEntityManager([
    {
      id: 'actor-1',
      components: {
        'core:actor': { isPlayer: true },
        'core:position': { locationId: 'room-1' },
      },
    },
    {
      id: 'friend-1',
      components: {
        'core:actor': { isPlayer: false },
        'core:position': { locationId: 'room-1' },
      },
    },
    {
      id: 'friend-2',
      components: {
        'core:actor': { isPlayer: false },
        'core:position': { locationId: 'room-1' },
      },
    },
    {
      id: 'outsider-1',
      components: {
        'core:actor': { isPlayer: false },
        'core:position': { locationId: 'room-2' },
      },
    },
  ]);

  const scopeRegistry = new TestScopeRegistry({
    'social:friends_in_same_room': {
      expr: 'match-location',
      ast: { type: 'match-location', includeSelf: false },
    },
    'social:include_everyone_here': {
      expr: 'match-location(include self)',
      ast: { type: 'match-location', includeSelf: true },
    },
    'social:empty_scope': {
      expr: 'empty',
      ast: { type: 'empty' },
    },
    'positioning:available_furniture': {
      expr: 'direct(friend-1)',
      ast: { type: 'direct', targetIds: ['friend-1'] },
    },
  });

  const scopeEngine = new TestScopeEngine(entityManager);
  const jsonLogicEvaluationService = new TestJsonLogicEvaluationService();
  const dslParser = new TestDslParser();
  const actionErrorContextBuilder = new TestActionErrorContextBuilder();

  const unifiedScopeResolver = new UnifiedScopeResolver({
    scopeRegistry,
    scopeEngine,
    entityManager,
    jsonLogicEvaluationService,
    dslParser,
    logger,
    actionErrorContextBuilder,
  });

  const service = new TargetResolutionService({
    unifiedScopeResolver,
    logger,
  });

  const actor = entityManager.getEntityInstance('actor-1');
  const discoveryContext = {
    currentLocation: 'room-1',
    entityManager,
  };

  return {
    service,
    logger,
    entityManager,
    actor,
    discoveryContext,
  };
}

describe('TargetResolutionService with UnifiedScopeResolver (real integration)', () => {
  let harness;

  beforeEach(() => {
    harness = createTargetResolutionHarness();
  });

  it('resolves nearby friends through the unified scope resolver and maps them to ActionTargetContext instances', () => {
    const trace = {
      withSpan: jest.fn((name, fn) => fn()),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
    };

    const result = harness.service.resolveTargets(
      'social:friends_in_same_room',
      harness.actor,
      harness.discoveryContext,
      trace,
      'positioning:sit_down'
    );

    expect(trace.withSpan).toHaveBeenCalledWith(
      'target.resolve',
      expect.any(Function),
      expect.objectContaining({
        scopeName: 'social:friends_in_same_room',
        actorId: 'actor-1',
        actionId: 'positioning:sit_down',
      })
    );

    expect(result.success).toBe(true);
    const resolvedIds = result.value.map((ctx) => ctx.entityId);
    expect(resolvedIds).toEqual(['friend-1', 'friend-2']);
    result.value.forEach((ctx) => expect(ctx).toBeInstanceOf(ActionTargetContext));

    expect(harness.logger.info).toHaveBeenCalledWith(
      expect.stringContaining('[DEBUG] TargetResolutionService resolving scope for sit_down:'),
      expect.objectContaining({
        scopeName: 'social:friends_in_same_room',
        actorId: 'actor-1',
      })
    );
    expect(trace.info).toHaveBeenCalledWith(
      "Delegating scope resolution for 'social:friends_in_same_room' to UnifiedScopeResolver.",
      'TargetResolutionService.resolveTargets'
    );
    expect(trace.info).toHaveBeenCalledWith(
      "Scope 'social:friends_in_same_room' resolved to 2 target(s).",
      'TargetResolutionService.resolveTargets',
      { targetIds: ['friend-1', 'friend-2'] }
    );
  });

  it('returns a noTarget context when the special none scope resolves to an empty set', () => {
    const trace = { info: jest.fn(), warn: jest.fn(), error: jest.fn() };

    const result = harness.service.resolveTargets(
      'none',
      harness.actor,
      harness.discoveryContext,
      trace
    );

    expect(result.success).toBe(true);
    expect(result.value).toEqual([ActionTargetContext.noTarget()]);
    expect(trace.info).toHaveBeenCalledWith(
      "Scope 'none' resolved to no targets - returning noTarget context.",
      'TargetResolutionService.resolveTargets'
    );
  });

  it('returns an empty array when a scope resolves to no entities and verifies trace logging without spans', () => {
    const trace = { info: jest.fn(), warn: jest.fn(), error: jest.fn() };

    const result = harness.service.resolveTargets(
      'social:empty_scope',
      harness.actor,
      harness.discoveryContext,
      trace,
      'social:handwave'
    );

    expect(result.success).toBe(true);
    expect(result.value).toEqual([]);
    expect(trace.info).toHaveBeenCalledWith(
      "Scope 'social:empty_scope' resolved to no targets.",
      'TargetResolutionService.resolveTargets'
    );
  });

  it('propagates resolver failures with enhanced context', () => {
    const trace = { info: jest.fn(), warn: jest.fn(), error: jest.fn() };

    const result = harness.service.resolveTargets(
      'social:missing_scope',
      harness.actor,
      harness.discoveryContext,
      trace
    );

    expect(result.success).toBe(false);
    expect(result.errors).toHaveLength(1);
    expect(result.errors[0].name).toBe('ScopeNotFoundError');
    expect(result.errors[0].additionalContext.scopeName).toBe('social:missing_scope');
  });

  it('supports the sit_down debug logging path even when the scope resolves through direct ids', () => {
    const trace = {
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
    };

    const result = harness.service.resolveTargets(
      'positioning:available_furniture',
      harness.actor,
      harness.discoveryContext,
      trace,
      'positioning:sit_down'
    );

    expect(result.success).toBe(true);
    expect(result.value.map((ctx) => ctx.entityId)).toEqual(['friend-1']);

    expect(harness.logger.info).toHaveBeenCalledWith(
      expect.stringContaining('[DEBUG] UnifiedScopeResolver result for sit_down:'),
      expect.objectContaining({
        valueSize: 1,
        entities: ['friend-1'],
      })
    );
  });
});
