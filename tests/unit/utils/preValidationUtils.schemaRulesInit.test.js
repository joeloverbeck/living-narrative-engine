/**
 * @file preValidationUtils.schemaRulesInit.test.js
 * @description Tests for schema-derived parameter rules initialization
 * @see tickets/SCHVALTESINT-011-integrate-autogenerated-rules.md
 */

import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import {
  initializeParameterRules,
  getOperationParameterRules,
  isParameterRulesInitialized,
  _resetParameterRulesForTesting,
  KNOWN_OPERATION_TYPES,
} from '../../../src/utils/preValidationUtils.js';

describe('preValidationUtils - Schema Rules Initialization', () => {
  afterEach(() => {
    // Reset state after each test
    _resetParameterRulesForTesting();
  });

  describe('initializeParameterRules', () => {
    it('should initialize rules from schemas', async () => {
      expect(isParameterRulesInitialized()).toBe(false);

      await initializeParameterRules({ assertCoverage: false });

      expect(isParameterRulesInitialized()).toBe(true);
    });

    it('should generate rules for all known operation types', async () => {
      await initializeParameterRules({ assertCoverage: false });

      const rules = getOperationParameterRules();

      // Rules should be generated for most known types (some may not have schemas)
      expect(Object.keys(rules).length).toBeGreaterThan(0);
    });

    it('should not re-initialize if already initialized', async () => {
      await initializeParameterRules({ assertCoverage: false });
      const firstRules = getOperationParameterRules();

      // Call again
      await initializeParameterRules({ assertCoverage: false });
      const secondRules = getOperationParameterRules();

      // Should be the same object reference
      expect(secondRules).toBe(firstRules);
    });

    it('should merge schema rules with manual typo-detection rules', async () => {
      await initializeParameterRules({ assertCoverage: false });

      const rules = getOperationParameterRules();

      // GET_NAME must exist since it has a schema
      expect(rules.GET_NAME).toBeDefined();

      // Schema-derived properties
      expect(Array.isArray(rules.GET_NAME.required)).toBe(true);
      expect(Array.isArray(rules.GET_NAME.optional)).toBe(true);
      expect(Array.isArray(rules.GET_NAME.templateFields)).toBe(true);

      // Manual typo-detection properties (preserved from OPERATION_PARAMETER_RULES)
      expect(Array.isArray(rules.GET_NAME.invalidFields)).toBe(true);
      expect(typeof rules.GET_NAME.fieldCorrections).toBe('object');
      expect(rules.GET_NAME.invalidFields).toContain('entity_id');
      expect(rules.GET_NAME.fieldCorrections.entity_id).toBe('entity_ref');
    });

    it('should include templateFields for operations with template-capable parameters', async () => {
      await initializeParameterRules({ assertCoverage: false });

      const rules = getOperationParameterRules();

      // LOCK_GRABBING has count parameter which accepts templates
      // This must exist since we have its schema
      expect(rules.LOCK_GRABBING).toBeDefined();
      expect(Array.isArray(rules.LOCK_GRABBING.templateFields)).toBe(true);
      expect(rules.LOCK_GRABBING.templateFields).toContain('count');
    });
  });

  describe('getOperationParameterRules', () => {
    it('should throw if called before initialization', () => {
      expect(isParameterRulesInitialized()).toBe(false);

      expect(() => {
        getOperationParameterRules();
      }).toThrow('Operation parameter rules not initialized');
    });

    it('should return rules after initialization', async () => {
      await initializeParameterRules({ assertCoverage: false });

      const rules = getOperationParameterRules();

      expect(typeof rules).toBe('object');
      expect(rules).not.toBeNull();
    });
  });

  describe('isParameterRulesInitialized', () => {
    it('should return false before initialization', () => {
      expect(isParameterRulesInitialized()).toBe(false);
    });

    it('should return true after initialization', async () => {
      await initializeParameterRules({ assertCoverage: false });

      expect(isParameterRulesInitialized()).toBe(true);
    });
  });

  describe('_resetParameterRulesForTesting', () => {
    it('should reset initialization state', async () => {
      await initializeParameterRules({ assertCoverage: false });
      expect(isParameterRulesInitialized()).toBe(true);

      _resetParameterRulesForTesting();

      expect(isParameterRulesInitialized()).toBe(false);
    });

    it('should allow re-initialization after reset', async () => {
      await initializeParameterRules({ assertCoverage: false });
      _resetParameterRulesForTesting();

      // Should not throw
      await initializeParameterRules({ assertCoverage: false });

      expect(isParameterRulesInitialized()).toBe(true);
    });
  });

  describe('coverage assertion', () => {
    it('should report coverage statistics without throwing when assertCoverage is false', async () => {
      // This test verifies we can check coverage without assertion
      await initializeParameterRules({ assertCoverage: false });
      const rules = getOperationParameterRules();

      const generatedTypes = Object.keys(rules);
      const missingTypes = KNOWN_OPERATION_TYPES.filter(
        (t) => !generatedTypes.includes(t)
      );

      // We expect high coverage (>90%) but some types may lack schemas
      const coveragePercentage =
        (generatedTypes.length / KNOWN_OPERATION_TYPES.length) * 100;
      expect(coveragePercentage).toBeGreaterThan(90);

      // Document what's missing for maintenance purposes
      // Currently HAS_BODY_PART_WITH_COMPONENT_VALUE and SEQUENCE lack schemas
      expect(missingTypes.length).toBeLessThanOrEqual(5);
    });

    it('should skip assertion when assertCoverage is false', async () => {
      // Should not throw even if coverage is incomplete
      await expect(
        initializeParameterRules({ assertCoverage: false })
      ).resolves.not.toThrow();
    });

    it('should handle assertCoverage: true based on actual schema coverage', async () => {
      // This test documents the expected behavior when assertCoverage is enabled
      // Currently there are 2 operation types without schemas (HAS_BODY_PART_WITH_COMPONENT_VALUE, SEQUENCE)
      // so assertCoverage: true will throw INV-3 Violation
      //
      // When all schemas are added, this test will pass without throwing
      // Either outcome is correct behavior for the implementation

      const initPromise = initializeParameterRules({ assertCoverage: true });

      // We know there are missing schemas, so this should reject
      // If this test fails, it means all schemas have been added (which is good!)
      await expect(initPromise).rejects.toThrow('INV-3 Violation');
    });
  });

  describe('rule structure', () => {
    beforeEach(async () => {
      await initializeParameterRules({ assertCoverage: false });
    });

    it('should have required array for each rule', async () => {
      const rules = getOperationParameterRules();

      for (const rule of Object.values(rules)) {
        expect(Array.isArray(rule.required)).toBe(true);
      }
    });

    it('should have optional array for each rule', async () => {
      const rules = getOperationParameterRules();

      for (const rule of Object.values(rules)) {
        expect(Array.isArray(rule.optional)).toBe(true);
      }
    });

    it('should have templateFields array for each rule', async () => {
      const rules = getOperationParameterRules();

      for (const rule of Object.values(rules)) {
        expect(Array.isArray(rule.templateFields)).toBe(true);
      }
    });

    it('should have invalidFields array for each rule', async () => {
      const rules = getOperationParameterRules();

      for (const rule of Object.values(rules)) {
        expect(Array.isArray(rule.invalidFields)).toBe(true);
      }
    });

    it('should have fieldCorrections object for each rule', async () => {
      const rules = getOperationParameterRules();

      for (const rule of Object.values(rules)) {
        expect(typeof rule.fieldCorrections).toBe('object');
      }
    });
  });
});
