/**
 * @file Verification that the attempt_action schema fix resolves the validation issue
 * @description Tests that verify the schema now includes all properties generated by MultiTargetEventBuilder
 */

import { describe, it, expect, beforeEach } from '@jest/globals';
import { createTestBed } from '../../../common/testBed.js';
import MultiTargetEventBuilder from '../../../../src/entities/multiTarget/multiTargetEventBuilder.js';
import fs from 'fs';
import path from 'path';

describe('Attempt Action Schema Fix - Verification Tests', () => {
  let testBed;
  let logger;
  let builder;
  let attemptActionSchema;

  beforeEach(() => {
    testBed = createTestBed();
    logger = testBed.mockLogger;
    builder = new MultiTargetEventBuilder({ logger });

    // Load the updated schema file directly
    const schemaPath = path.resolve(
      'data/mods/core/events/attempt_action.event.json'
    );
    const schemaContent = fs.readFileSync(schemaPath, 'utf8');
    const schemaFile = JSON.parse(schemaContent);
    attemptActionSchema = schemaFile.payloadSchema;
  });

  afterEach(() => {
    testBed.cleanup();
  });

  describe('Schema Fix Verification', () => {
    it('should confirm that schema now includes all properties generated by legacy target builder', () => {
      const payload = builder
        .setActor('p_erotica:iker_aguirre_instance')
        .setAction('personal-space:get_close')
        .setOriginalInput('get close to Amaia Castillo')
        .setLegacyTarget('p_erotica:amaia_castillo_instance')
        .buildUnsafe();

      // The payload contains these properties that previously caused validation failures
      expect(payload).toHaveProperty(
        'primaryId',
        'p_erotica:amaia_castillo_instance'
      );
      expect(payload).toHaveProperty('secondaryId', null);
      expect(payload).toHaveProperty('tertiaryId', null);

      // Now the schema SHOULD define these properties:
      const schemaProperties = attemptActionSchema.properties;
      expect(schemaProperties).toHaveProperty('primaryId');
      expect(schemaProperties).toHaveProperty('secondaryId');
      expect(schemaProperties).toHaveProperty('tertiaryId');

      // Verify the property definitions are correct
      expect(schemaProperties.primaryId).toHaveProperty('$ref');
      expect(schemaProperties.primaryId.description).toContain(
        'Primary target entity ID'
      );
      expect(schemaProperties.secondaryId).toHaveProperty('$ref');
      expect(schemaProperties.secondaryId.description).toContain(
        'Secondary target entity ID'
      );
      expect(schemaProperties.tertiaryId).toHaveProperty('$ref');
      expect(schemaProperties.tertiaryId.description).toContain(
        'Tertiary target entity ID'
      );
    });

    it('should confirm that schema now includes metadata properties', () => {
      const payload = builder
        .setActor('test:actor')
        .setAction('test:action')
        .setOriginalInput('test command')
        .setLegacyTarget('test:target')
        .setMetadata({
          resolvedTargetCount: 1,
          hasContextDependencies: false,
        })
        .buildUnsafe();

      // The payload contains these metadata properties that previously caused validation failures
      expect(payload).toHaveProperty('resolvedTargetCount', 1);
      expect(payload).toHaveProperty('hasContextDependencies', false);

      // Now the schema SHOULD define these properties:
      const schemaProperties = attemptActionSchema.properties;
      expect(schemaProperties).toHaveProperty('resolvedTargetCount');
      expect(schemaProperties).toHaveProperty('hasContextDependencies');

      // Verify the property definitions are correct
      expect(schemaProperties.resolvedTargetCount).toEqual({
        type: 'number',
        description: 'Number of targets that were resolved for this action',
        minimum: 0,
      });

      expect(schemaProperties.hasContextDependencies).toEqual({
        type: 'boolean',
        description: 'Whether the action targets have context dependencies',
      });
    });

    it('should verify exact payload from error logs now has all required schema properties', () => {
      const payload = builder
        .setActor('p_erotica:iker_aguirre_instance')
        .setAction('personal-space:get_close')
        .setOriginalInput('get close to Amaia Castillo')
        .setLegacyTarget('p_erotica:amaia_castillo_instance')
        .setMetadata({
          resolvedTargetCount: 1,
          hasContextDependencies: false,
        })
        .setTimestamp(1754060279113)
        .buildUnsafe();

      // This payload matches the one from the error logs
      expect(payload).toEqual({
        eventName: 'core:attempt_action',
        timestamp: 1754060279113,
        actorId: 'p_erotica:iker_aguirre_instance',
        actionId: 'personal-space:get_close',
        originalInput: 'get close to Amaia Castillo',
        targetId: 'p_erotica:amaia_castillo_instance',
        primaryId: 'p_erotica:amaia_castillo_instance',
        secondaryId: null,
        tertiaryId: null,
        resolvedTargetCount: 1,
        hasContextDependencies: false,
      });

      // All properties in this payload should now be defined in the schema
      const schemaProperties = attemptActionSchema.properties;
      Object.keys(payload).forEach((key) => {
        expect(schemaProperties).toHaveProperty(key);
      });
    });

    it('should maintain backward compatibility with existing valid payloads', () => {
      // Legacy single-target payload should still be valid
      const legacyPayload = {
        eventName: 'core:attempt_action',
        actorId: 'test:actor',
        actionId: 'test:action',
        originalInput: 'test command',
        targetId: 'test:target',
        timestamp: Date.now(),
      };

      // All properties should be defined in schema
      const schemaProperties = attemptActionSchema.properties;
      Object.keys(legacyPayload).forEach((key) => {
        expect(schemaProperties).toHaveProperty(key);
      });

      // Multi-target payload should also still be valid
      const multiTargetPayload = {
        eventName: 'core:attempt_action',
        actorId: 'test:actor',
        actionId: 'test:action',
        originalInput: 'test command',
        targetId: 'test:primary',
        targets: {
          primary: 'test:primary',
          secondary: 'test:secondary',
        },
        timestamp: Date.now(),
      };

      Object.keys(multiTargetPayload).forEach((key) => {
        expect(schemaProperties).toHaveProperty(key);
      });
    });
  });

  describe('Multi-Target Fix Verification', () => {
    it('should verify multi-target payloads now have all properties defined in schema', () => {
      const targets = {
        primary: 'test:primary',
        secondary: 'test:secondary',
        tertiary: 'test:tertiary',
      };

      const payload = builder
        .setActor('test:actor')
        .setAction('test:action')
        .setOriginalInput('test command')
        .setTargets(targets)
        .buildUnsafe();

      // Multi-target mode adds the flattened ID properties
      expect(payload).toHaveProperty('primaryId', 'test:primary');
      expect(payload).toHaveProperty('secondaryId', 'test:secondary');
      expect(payload).toHaveProperty('tertiaryId', 'test:tertiary');

      // These should now be defined in the schema
      const schemaProperties = attemptActionSchema.properties;
      expect(schemaProperties).toHaveProperty('primaryId');
      expect(schemaProperties).toHaveProperty('secondaryId');
      expect(schemaProperties).toHaveProperty('tertiaryId');
    });
  });

  describe('Schema Structure Verification', () => {
    it('should confirm updated schema maintains proper structure', () => {
      // Verify basic schema structure is intact
      expect(attemptActionSchema).toHaveProperty('type', 'object');
      expect(attemptActionSchema).toHaveProperty('additionalProperties', false);
      expect(attemptActionSchema).toHaveProperty('required');
      expect(attemptActionSchema.required).toEqual([
        'eventName',
        'actorId',
        'actionId',
        'originalInput',
      ]);

      // Verify all expected properties are present (original + new)
      const expectedProperties = [
        'eventName',
        'actorId',
        'actionId',
        'originalInput',
        'targetId',
        'targets',
        'timestamp',
        'primaryId',
        'secondaryId',
        'tertiaryId',
        'resolvedTargetCount',
        'hasContextDependencies',
      ];

      const schemaProperties = attemptActionSchema.properties;
      expectedProperties.forEach((prop) => {
        expect(schemaProperties).toHaveProperty(prop);
      });

      // Verify the new properties have proper types and references
      expect(schemaProperties.primaryId.$ref).toBe(
        'schema://living-narrative-engine/common.schema.json#/definitions/nullableNamespacedId'
      );
      expect(schemaProperties.secondaryId.$ref).toBe(
        'schema://living-narrative-engine/common.schema.json#/definitions/nullableNamespacedId'
      );
      expect(schemaProperties.tertiaryId.$ref).toBe(
        'schema://living-narrative-engine/common.schema.json#/definitions/nullableNamespacedId'
      );
      expect(schemaProperties.resolvedTargetCount.type).toBe('number');
      expect(schemaProperties.hasContextDependencies.type).toBe('boolean');
    });

    it('should verify schema anyOf conditions are still intact', () => {
      // The schema should still have the anyOf conditions for backward compatibility
      expect(attemptActionSchema).toHaveProperty('anyOf');
      expect(Array.isArray(attemptActionSchema.anyOf)).toBe(true);
      expect(attemptActionSchema.anyOf).toHaveLength(2);

      // Verify legacy format condition
      const legacyCondition = attemptActionSchema.anyOf[0];
      expect(legacyCondition.description).toContain('Legacy format');
      expect(legacyCondition.required).toContain('targetId');

      // Verify multi-target format condition
      const multiTargetCondition = attemptActionSchema.anyOf[1];
      expect(multiTargetCondition.description).toContain('Multi-target format');
      expect(multiTargetCondition.required).toContain('targets');
      expect(multiTargetCondition.required).toContain('targetId');
    });
  });
});
