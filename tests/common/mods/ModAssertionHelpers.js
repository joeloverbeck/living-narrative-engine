/**
 * @file Specialized assertion helpers for mod integration tests
 * @description Provides standardized assertions for common mod test scenarios
 */

import { expect } from '@jest/globals';

/**
 * Helper class providing specialized assertions for mod integration tests.
 *
 * Standardizes the verification patterns commonly used across mod tests,
 * reducing code duplication and improving test consistency.
 */
export class ModAssertionHelpers {
  /**
   * Asserts that an action executed successfully with the expected workflow.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {string} expectedMessage - Expected success message
   * @param {object} options - Additional options
   * @param {boolean} [options.shouldEndTurn] - Whether turn should end (default: true)
   * @param {boolean} [options.shouldHavePerceptibleEvent] - Whether perceptible event should exist (default: true)
   */
  static assertActionSuccess(events, expectedMessage, options = {}) {
    if (!Array.isArray(events)) {
      throw new Error(
        'ModAssertionHelpers.assertActionSuccess: events must be an array'
      );
    }

    if (events.length === 0) {
      throw new Error(
        'ModAssertionHelpers.assertActionSuccess: events array cannot be empty'
      );
    }
    const { shouldEndTurn = true, shouldHavePerceptibleEvent = true } = options;

    // Check that we have the basic required events
    const successEvent = events.find(
      (e) => e.eventType === 'core:display_successful_action_result'
    );
    expect(successEvent).toBeDefined();
    expect(successEvent.payload.message).toBe(expectedMessage);

    if (shouldHavePerceptibleEvent) {
      const perceptibleEvent = events.find(
        (e) => e.eventType === 'core:perceptible_event'
      );
      expect(perceptibleEvent).toBeDefined();
      expect(perceptibleEvent.payload.descriptionText).toBe(expectedMessage);
    }

    if (shouldEndTurn) {
      const turnEndedEvent = events.find(
        (e) => e.eventType === 'core:turn_ended'
      );
      expect(turnEndedEvent).toBeDefined();
      expect(turnEndedEvent.payload.success).toBe(true);
    }
  }

  /**
   * Asserts that a perceptible event was generated correctly.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {object} expectedEvent - Expected event properties
   * @param {string} expectedEvent.descriptionText - Expected description
   * @param {string} expectedEvent.locationId - Expected location ID
   * @param {string} expectedEvent.actorId - Expected actor ID
   * @param {string} [expectedEvent.targetId] - Expected target ID
   * @param {string} [expectedEvent.perceptionType] - Expected perception type
   */
  static assertPerceptibleEvent(events, expectedEvent) {
    if (!Array.isArray(events)) {
      throw new Error(
        'ModAssertionHelpers.assertPerceptibleEvent: events must be an array'
      );
    }

    if (!expectedEvent || typeof expectedEvent !== 'object') {
      throw new Error(
        'ModAssertionHelpers.assertPerceptibleEvent: expectedEvent must be an object'
      );
    }
    const perceptibleEvent = events.find(
      (e) => e.eventType === 'core:perceptible_event'
    );

    expect(perceptibleEvent).toBeDefined();

    const { payload } = perceptibleEvent;
    expect(payload.descriptionText).toBe(expectedEvent.descriptionText);
    expect(payload.locationId).toBe(expectedEvent.locationId);
    expect(payload.actorId).toBe(expectedEvent.actorId);

    if (expectedEvent.targetId) {
      expect(payload.targetId).toBe(expectedEvent.targetId);
    }

    if (expectedEvent.perceptionType) {
      expect(payload.perceptionType).toBe(expectedEvent.perceptionType);
    } else {
      expect(payload.perceptionType).toBe('action_target_general');
    }

    // Default expectations for perceptible events
    expect(payload.involvedEntities).toEqual([]);
  }

  /**
   * Asserts that a component was added to an entity correctly.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} entityId - The entity ID to check
   * @param {string} componentId - The component type ID that should exist
   * @param {object} [expectedData] - Expected component data
   */
  static assertComponentAdded(
    entityManager,
    entityId,
    componentId,
    expectedData = {}
  ) {
    if (
      !entityManager ||
      typeof entityManager.getEntityInstance !== 'function'
    ) {
      throw new Error(
        'ModAssertionHelpers.assertComponentAdded: entityManager must be provided with getEntityInstance method'
      );
    }

    if (!entityId || typeof entityId !== 'string') {
      throw new Error(
        'ModAssertionHelpers.assertComponentAdded: entityId must be a non-empty string'
      );
    }

    if (!componentId || typeof componentId !== 'string') {
      throw new Error(
        'ModAssertionHelpers.assertComponentAdded: componentId must be a non-empty string'
      );
    }
    const entity = entityManager.getEntityInstance(entityId);
    expect(entity).toBeDefined();
    expect(entity.components[componentId]).toBeDefined();

    if (Object.keys(expectedData).length > 0) {
      expect(entity.components[componentId]).toEqual(
        expect.objectContaining(expectedData)
      );
    }
  }

  /**
   * Asserts that a component was removed from an entity.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} entityId - The entity ID to check
   * @param {string} componentId - The component type ID that should not exist
   */
  static assertComponentRemoved(entityManager, entityId, componentId) {
    if (
      !entityManager ||
      typeof entityManager.getEntityInstance !== 'function'
    ) {
      throw new Error(
        'ModAssertionHelpers.assertComponentRemoved: entityManager must be provided with getEntityInstance method'
      );
    }

    if (!entityId || typeof entityId !== 'string') {
      throw new Error(
        'ModAssertionHelpers.assertComponentRemoved: entityId must be a non-empty string'
      );
    }

    if (!componentId || typeof componentId !== 'string') {
      throw new Error(
        'ModAssertionHelpers.assertComponentRemoved: componentId must be a non-empty string'
      );
    }
    const entity = entityManager.getEntityInstance(entityId);
    expect(entity).toBeDefined();
    expect(entity.components[componentId]).toBeUndefined();
  }

  /**
   * Asserts the standard event sequence for a successful action.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {Array<string>} [expectedTypes] - Expected event types in order
   */
  static assertStandardEventSequence(events, expectedTypes = null) {
    const defaultExpectedTypes = [
      'core:attempt_action',
      'core:perceptible_event',
      'core:display_successful_action_result',
      'core:turn_ended',
    ];

    const typesToCheck = expectedTypes || defaultExpectedTypes;
    const eventTypes = events.map((e) => e.eventType);

    typesToCheck.forEach((expectedType) => {
      expect(eventTypes).toContain(expectedType);
    });
  }

  /**
   * Asserts that an action failed to execute (no success events).
   *
   * @param {Array} events - The captured events from the test environment
   * @param {object} options - Options for failure checking
   * @param {boolean} [options.shouldHaveAttempt] - Whether attempt event should exist (default: true)
   */
  static assertActionFailure(events, options = {}) {
    const { shouldHaveAttempt = true } = options;

    if (shouldHaveAttempt) {
      const attemptEvent = events.find(
        (e) => e.eventType === 'core:attempt_action'
      );
      expect(attemptEvent).toBeDefined();
    }

    // Should not have success events
    const successEvent = events.find(
      (e) => e.eventType === 'core:display_successful_action_result'
    );
    expect(successEvent).toBeUndefined();

    const turnEndedEvent = events.find(
      (e) => e.eventType === 'core:turn_ended'
    );

    if (turnEndedEvent) {
      expect(turnEndedEvent.payload.success).toBe(false);
    }
  }

  /**
   * Asserts that only specific events were generated (no unexpected events).
   *
   * @param {Array} events - The captured events from the test environment
   * @param {Array<string>} allowedEventTypes - Event types that are allowed
   */
  static assertOnlyExpectedEvents(events, allowedEventTypes) {
    const eventTypes = events.map((e) => e.eventType);
    const unexpectedEvents = eventTypes.filter(
      (type) => !allowedEventTypes.includes(type)
    );

    expect(unexpectedEvents).toEqual([]);
  }

  /**
   * Asserts that two entities have mutual closeness components.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} entity1Id - First entity ID
   * @param {string} entity2Id - Second entity ID
   */
  static assertMutualCloseness(entityManager, entity1Id, entity2Id) {
    const entity1 = entityManager.getEntityInstance(entity1Id);
    const entity2 = entityManager.getEntityInstance(entity2Id);

    expect(entity1).toBeDefined();
    expect(entity2).toBeDefined();

    expect(entity1.components['positioning:closeness']).toBeDefined();
    expect(entity2.components['positioning:closeness']).toBeDefined();

    expect(entity1.components['positioning:closeness'].partners).toContain(
      entity2Id
    );
    expect(entity2.components['positioning:closeness'].partners).toContain(
      entity1Id
    );
  }

  /**
   * Asserts that entities are in the same location.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {Array<string>} entityIds - Entity IDs to check
   * @param {string} expectedLocationId - Expected location ID
   */
  static assertSameLocation(entityManager, entityIds, expectedLocationId) {
    entityIds.forEach((entityId) => {
      const entity = entityManager.getEntityInstance(entityId);
      expect(entity).toBeDefined();
      expect(entity.components).toBeDefined();

      const positionComponent = entity.components['core:position'];
      expect(positionComponent).toBeDefined();
      expect(positionComponent.locationId).toBe(expectedLocationId);
    });
  }

  /**
   * Asserts that a rule did not trigger for a different action.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {number} initialEventCount - Number of events before the test action
   */
  static assertRuleDidNotTrigger(events, initialEventCount) {
    // Should only have the dispatched event, no rule-generated events
    expect(events.length).toBe(initialEventCount + 1);

    // Should not have any success or perceptible events
    const successEvents = events.filter(
      (e) => e.eventType === 'core:display_successful_action_result'
    );
    const perceptibleEvents = events.filter(
      (e) => e.eventType === 'core:perceptible_event'
    );

    expect(successEvents).toHaveLength(0);
    expect(perceptibleEvents).toHaveLength(0);
  }

  /**
   * Asserts that messages match between success and perceptible events.
   *
   * @param {Array} events - The captured events from the test environment
   */
  static assertConsistentMessages(events) {
    const successEvent = events.find(
      (e) => e.eventType === 'core:display_successful_action_result'
    );
    const perceptibleEvent = events.find(
      (e) => e.eventType === 'core:perceptible_event'
    );

    if (successEvent && perceptibleEvent) {
      expect(successEvent.payload.message).toBe(
        perceptibleEvent.payload.descriptionText
      );
    }
  }

  /**
   * Asserts that an entity has specific components.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} entityId - Entity ID to check
   * @param {Array<string>} componentIds - Component IDs that should exist
   */
  static assertEntityHasComponents(entityManager, entityId, componentIds) {
    const entity = entityManager.getEntityInstance(entityId);
    expect(entity).toBeDefined();

    componentIds.forEach((componentId) => {
      expect(entity.components[componentId]).toBeDefined();
    });
  }

  /**
   * Asserts that an entity does not have specific components.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} entityId - Entity ID to check
   * @param {Array<string>} componentIds - Component IDs that should not exist
   */
  static assertEntityLacksComponents(entityManager, entityId, componentIds) {
    const entity = entityManager.getEntityInstance(entityId);
    expect(entity).toBeDefined();

    componentIds.forEach((componentId) => {
      expect(entity.components[componentId]).toBeUndefined();
    });
  }

  /**
   * Asserts that event counts match expected values.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {object} expectedCounts - Object mapping event types to expected counts
   */
  static assertEventCounts(events, expectedCounts) {
    Object.entries(expectedCounts).forEach(([eventType, expectedCount]) => {
      const actualCount = events.filter(
        (e) => e.eventType === eventType
      ).length;
      expect(actualCount).toBe(expectedCount);
    });
  }

  /**
   * Asserts anatomy body structure is correct.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} entityId - Entity with anatomy:body component
   * @param {string} rootPartId - Expected root body part ID
   */
  static assertBodyStructure(entityManager, entityId, rootPartId) {
    const entity = entityManager.getEntityInstance(entityId);
    expect(entity).toBeDefined();
    expect(entity.components['anatomy:body']).toBeDefined();
    expect(entity.components['anatomy:body'].body.root).toBe(rootPartId);
  }

  /**
   * Asserts body part relationships are correct.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} partId - Body part entity ID
   * @param {object} expectedStructure - Expected part structure
   * @param {string} [expectedStructure.parent] - Expected parent ID
   * @param {Array<string>} [expectedStructure.children] - Expected children IDs
   * @param {string} expectedStructure.subType - Expected subtype
   */
  static assertBodyPart(entityManager, partId, expectedStructure) {
    const part = entityManager.getEntityInstance(partId);
    expect(part).toBeDefined();
    expect(part.components['anatomy:part']).toBeDefined();

    const partData = part.components['anatomy:part'];

    if (expectedStructure.parent !== undefined) {
      expect(partData.parent).toBe(expectedStructure.parent);
    }

    if (expectedStructure.children) {
      expect(partData.children).toEqual(expectedStructure.children);
    }

    expect(partData.subType).toBe(expectedStructure.subType);
  }

  /**
   * Finds the first event of a specified type.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {string} eventType - The event type to search for
   * @returns {object|undefined} The first matching event or undefined
   */
  static findEventByType(events, eventType) {
    if (!Array.isArray(events)) {
      throw new Error(
        'ModAssertionHelpers.findEventByType: events must be an array'
      );
    }

    if (!eventType || typeof eventType !== 'string') {
      throw new Error(
        'ModAssertionHelpers.findEventByType: eventType must be a non-empty string'
      );
    }
    return events.find((event) => event.eventType === eventType);
  }

  /**
   * Finds all events of a specified type.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {string} eventType - The event type to search for
   * @returns {Array} Array of matching events
   */
  static findAllEventsByType(events, eventType) {
    if (!Array.isArray(events)) {
      throw new Error(
        'ModAssertionHelpers.findAllEventsByType: events must be an array'
      );
    }

    if (!eventType || typeof eventType !== 'string') {
      throw new Error(
        'ModAssertionHelpers.findAllEventsByType: eventType must be a non-empty string'
      );
    }
    return events.filter((event) => event.eventType === eventType);
  }

  /**
   * Gets the payload from the first event of a specified type.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {string} eventType - The event type to search for
   * @returns {object|null} The event payload or null if not found
   */
  static getEventPayload(events, eventType) {
    const event = this.findEventByType(events, eventType);
    return event ? event.payload : null;
  }

  /**
   * Asserts a complete action workflow including success, perceptible events,
   * and component changes.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {object} expectedFlow - Expected workflow configuration
   * @param {string} [expectedFlow.successMessage] - Expected success message
   * @param {string} [expectedFlow.perceptibleContent] - Expected perceptible content
   * @param {Array} [expectedFlow.componentChanges] - Array of component change expectations
   * @param {boolean} [expectedFlow.errorExpected] - Whether an error is expected
   */
  static assertCompleteActionWorkflow(events, expectedFlow = {}) {
    const {
      successMessage = null,
      perceptibleContent = null,
      componentChanges = [],
      errorExpected = false,
    } = expectedFlow;

    if (errorExpected) {
      return this.assertActionFailure(events);
    }

    // Use existing assertActionSuccess method if success message provided
    if (successMessage) {
      this.assertActionSuccess(events, successMessage, {
        shouldHavePerceptibleEvent: !!perceptibleContent,
      });
    }

    // Validate perceptible content if specified
    if (perceptibleContent) {
      const perceptibleEvent = this.findEventByType(
        events,
        'core:perceptible_event'
      );
      expect(perceptibleEvent).toBeDefined();
      expect(perceptibleEvent.payload.descriptionText).toContain(
        perceptibleContent
      );
    }

    // Validate component changes
    componentChanges.forEach((change) => {
      if (change.removed) {
        this.assertComponentRemoved(
          change.entityManager,
          change.entityId,
          change.componentId
        );
      } else {
        this.assertComponentAdded(
          change.entityManager,
          change.entityId,
          change.componentId,
          change.expectedData
        );
      }
    });
  }

  /**
   * Asserts that events occurred in a specific sequence order.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {Array<string>} expectedSequence - Expected event types in order
   * @returns {Array} The events that matched the sequence
   */
  static assertEventSequence(events, expectedSequence) {
    expect(events.length).toBeGreaterThanOrEqual(expectedSequence.length);

    let eventIndex = 0;
    const matchedEvents = [];

    for (const expectedType of expectedSequence) {
      // Find next occurrence of expected type starting from current index
      let found = false;
      while (eventIndex < events.length) {
        if (events[eventIndex].eventType === expectedType) {
          matchedEvents.push(events[eventIndex]);
          found = true;
          eventIndex++;
          break;
        }
        eventIndex++;
      }

      if (!found) {
        throw new Error(
          `Expected event type '${expectedType}' not found in sequence at position ${matchedEvents.length}`
        );
      }
    }

    return matchedEvents;
  }

  /**
   * Asserts that an action failed due to lack of closeness.
   *
   * @param {Array} events - The captured events from the test environment
   */
  static assertClosenessRequired(events) {
    const errorEvent = this.findEventByType(
      events,
      'core:system_error_occurred'
    );
    expect(errorEvent).toBeDefined();
    expect(errorEvent.payload.error.toLowerCase()).toContain('closeness');
  }

  /**
   * Asserts an intimate action succeeded with the expected message format.
   *
   * @param {Array} events - The captured events from the test environment
   * @param {string} actorName - The actor's name
   * @param {string} targetName - The target's name
   * @param {string} actionDescription - Description of the intimate action (may already include target)
   */
  static assertIntimateActionSuccess(
    events,
    actorName,
    targetName,
    actionDescription
  ) {
    // If the action description already includes the target name, use it as is
    // Otherwise, append the target name
    const expectedMessage = actionDescription.includes(targetName)
      ? `${actorName} ${actionDescription}`
      : `${actorName} ${actionDescription} ${targetName}`;
    return this.assertActionSuccess(events, expectedMessage);
  }

  /**
   * Asserts a kneeling position component was added correctly.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} actorId - The kneeling actor's entity ID
   * @param {string} targetId - The target entity ID
   */
  static assertKneelingPosition(entityManager, actorId, targetId) {
    const actor = entityManager.getEntityInstance(actorId);
    expect(actor).toBeDefined();
    expect(actor.components['positioning:kneeling_before']).toBeDefined();

    if (targetId) {
      expect(actor.components['positioning:kneeling_before'].target).toBe(
        targetId
      );
    }

    return actor.components['positioning:kneeling_before'];
  }

  /**
   * Asserts a standing behind position component was added correctly.
   *
   * @param {object} entityManager - Entity manager instance
   * @param {string} actorId - The standing actor's entity ID
   * @param {string} targetId - The target entity ID
   */
  static assertStandingPosition(entityManager, actorId, targetId) {
    const actor = entityManager.getEntityInstance(actorId);
    expect(actor).toBeDefined();
    expect(actor.components['positioning:standing_behind']).toBeDefined();

    if (targetId) {
      expect(actor.components['positioning:standing_behind'].target).toBe(
        targetId
      );
    }

    return actor.components['positioning:standing_behind'];
  }

  /**
   * Asserts message content contains expected substring.
   *
   * @param {object} event - The event to check
   * @param {string} expectedSubstring - Expected substring in message
   */
  static assertMessageContains(event, expectedSubstring) {
    expect(event).toBeDefined();
    expect(event.payload).toBeDefined();

    const message =
      event.payload.message || event.payload.descriptionText || '';
    expect(message).toContain(expectedSubstring);
  }

  /**
   * Asserts message content matches regex pattern.
   *
   * @param {object} event - The event to check
   * @param {RegExp|string} expectedPattern - Expected pattern to match
   */
  static assertMessageMatches(event, expectedPattern) {
    expect(event).toBeDefined();
    expect(event.payload).toBeDefined();

    const message =
      event.payload.message || event.payload.descriptionText || '';
    const pattern =
      typeof expectedPattern === 'string'
        ? new RegExp(expectedPattern)
        : expectedPattern;

    expect(message).toMatch(pattern);
  }
}

export default ModAssertionHelpers;
