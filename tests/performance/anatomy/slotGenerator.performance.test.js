/**
 * @file slotGenerator.performance.test.js
 * @description Performance benchmarks for SlotGenerator template expansion
 * Ensures slot generation overhead remains acceptable (<5ms per blueprint expansion)
 * CRITICAL: Validates that slot keys match socket IDs generated by SocketGenerator
 * @see workflows/ANABLUNONHUM-012-performance-benchmarks.md
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import SlotGenerator from '../../../src/anatomy/slotGenerator.js';
import { measureSamples } from '../../helpers/performancePercentiles.js';

describe('SlotGenerator - Performance Tests', () => {
  let slotGenerator;
  let mockLogger;

  beforeEach(() => {
    // Create mock logger to avoid logging overhead in performance measurements
    mockLogger = {
      debug: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
    };

    slotGenerator = new SlotGenerator({ logger: mockLogger });
  });

  /**
   * Helper function to create structure template for testing
   *
   * @param {number} limbSetCount - Number of limb sets
   * @param {number} slotsPerLimbSet - Number of slots per limb set
   * @param {string} arrangement - Arrangement type (bilateral, radial, indexed, custom)
   * @param {boolean} optional - Whether slots are optional
   * @returns {object} Structure template
   */
  const createStructureTemplate = (
    limbSetCount,
    slotsPerLimbSet,
    arrangement = 'bilateral',
    optional = false
  ) => ({
    topology: {
      limbSets: Array.from({ length: limbSetCount }, (_, setIndex) => ({
        type: `limb_${setIndex}`,
        count: slotsPerLimbSet,
        socketPattern: {
          idTemplate: `socket_${setIndex}_{{index}}`,
          allowedTypes: ['test_part'],
        },
        arrangement,
        optional,
      })),
      appendages: [],
    },
  });

  /**
   * Helper to create template with appendages
   *
   * @param {number} appendageCount - Number of appendages
   * @param {boolean} optional - Whether appendages are optional
   * @returns {object} Structure template with appendages
   */
  const createAppendageTemplate = (appendageCount, optional = false) => ({
    topology: {
      limbSets: [],
      appendages: Array.from({ length: appendageCount }, (_, index) => ({
        type: `appendage_${index}`,
        count: 1,
        socketPattern: {
          idTemplate: `app_${index}`,
          allowedTypes: ['test_appendage'],
        },
        optional,
      })),
    },
  });

  describe('Slot Generation Performance', () => {
    it('should generate single slot efficiently (<0.05ms)', () => {
      const template = createStructureTemplate(1, 1);
      const iterations = 1000; // Reduced from 10000 for faster tests

      // Warmup phase to ensure JIT compilation
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      // Allow CI variance while still catching >3x regressions
      // Reference: archive/performance-test-flakiness/performance-test-flakiness-analysis.md
      expect(totalTime).toBeLessThan(50);

      // Average time per call should remain under 0.05ms (50 microseconds)
      expect(avgTime).toBeLessThan(0.05);

      console.log(
        `Single slot generation: ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should generate 10 slots efficiently (<0.1ms)', () => {
      const template = createStructureTemplate(1, 10);
      const iterations = 1000; // Reduced from 10000

      // Warmup phase
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      // Should complete 1k iterations in under 100ms (scaled from 1000ms for 10k)
      expect(totalTime).toBeLessThan(100);

      // Average time per call should be under 0.1ms
      expect(avgTime).toBeLessThan(0.1);

      console.log(
        `10 slots generation: ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should generate 20 slots efficiently (<0.2ms)', () => {
      const template = createStructureTemplate(1, 20);
      const iterations = 1000; // Reduced from 10000

      // Warmup phase
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      // Should complete 1k iterations in under 200ms (scaled from 2000ms for 10k)
      expect(totalTime).toBeLessThan(200);

      // Average time per call should be under 0.2ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `20 slots generation: ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('maintains stable median and p95 timings across samples', () => {
      const template = createStructureTemplate(1, 20);

      const stats = measureSamples(
        () => slotGenerator.generateBlueprintSlots(template),
        {
          samples: 5,
          iterations: 100,
          warmupIterations: 50,
        }
      );

      expect(stats.median).toBeLessThan(60);
      expect(stats.p95).toBeLessThan(90);

      console.log(
        `20 slots percentile sample -> median: ${stats.median.toFixed(2)}ms, p95: ${stats.p95.toFixed(2)}ms`
      );
    });

    it('should generate 50 slots efficiently (<0.5ms)', () => {
      const template = createStructureTemplate(1, 50);
      const iterations = 1000; // Reduced from 10000

      // Warmup phase
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      // Should complete 1k iterations in under 500ms (scaled from 5000ms for 10k)
      expect(totalTime).toBeLessThan(500);

      // Average time per call should be under 0.5ms
      expect(avgTime).toBeLessThan(0.5);

      console.log(
        `50 slots generation: ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should generate 100 slots efficiently (<1ms)', () => {
      const template = createStructureTemplate(1, 100);
      const iterations = 1000; // Reduced from 10000

      // Warmup phase
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      // Should complete 1k iterations in under 1000ms (scaled from 10000ms for 10k)
      expect(totalTime).toBeLessThan(1000);

      // Average time per call should be under 1ms
      expect(avgTime).toBeLessThan(1);

      console.log(
        `100 slots generation: ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });
  });

  describe('Arrangement Scheme Performance', () => {
    it('should handle bilateral arrangement efficiently', () => {
      const template = createStructureTemplate(2, 10, 'bilateral');
      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Bilateral arrangement (20 slots): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should handle radial arrangement efficiently', () => {
      const template = createStructureTemplate(2, 10, 'radial');
      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Radial arrangement (20 slots): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should handle indexed arrangement efficiently', () => {
      const template = createStructureTemplate(2, 10, 'indexed');
      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Indexed arrangement (20 slots): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should handle custom arrangement efficiently', () => {
      const template = createStructureTemplate(2, 10, 'custom');
      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Custom arrangement (20 slots): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });
  });

  describe('Optional vs Required Slot Performance', () => {
    it('should handle optional slots efficiently', () => {
      const template = createStructureTemplate(2, 10, 'bilateral', true);
      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Optional slots (20 total): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });

    it('should handle required slots efficiently', () => {
      const template = createStructureTemplate(2, 10, 'bilateral', false);
      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Required slots (20 total): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });
  });

  describe('Mixed LimbSet and Appendage Performance', () => {
    it('should handle combined limbSets and appendages efficiently', () => {
      const template = {
        topology: {
          limbSets: [
            {
              type: 'leg',
              count: 10,
              socketPattern: {
                idTemplate: 'leg_{{index}}',
                allowedTypes: ['leg_part'],
              },
              arrangement: 'bilateral',
              optional: false,
            },
          ],
          appendages: Array.from({ length: 10 }, (_, index) => ({
            type: `tail_segment_${index}`,
            count: 1,
            socketPattern: {
              idTemplate: `tail_${index}`,
              allowedTypes: ['tail_part'],
            },
            optional: true,
          })),
        },
      };

      const iterations = 1000; // Reduced from 10000

      // Warmup
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      const start = performance.now();
      for (let i = 0; i < iterations; i++) {
        slotGenerator.generateBlueprintSlots(template);
      }
      const totalTime = performance.now() - start;
      const avgTime = totalTime / iterations;

      // 20 total slots: should be < 0.2ms avg
      expect(totalTime).toBeLessThan(200); // Scaled from 2000ms
      expect(avgTime).toBeLessThan(0.2);

      console.log(
        `Combined limbSets + appendages (20 slots): ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`
      );
    });
  });

  describe('Stress Testing', () => {
    it('should handle rapid successive calls without degradation', () => {
      const template = createStructureTemplate(2, 15); // 30 slots total
      const times = [];

      // Warmup phase
      for (let i = 0; i < 100; i++) {
        // Reduced from 1000
        slotGenerator.generateBlueprintSlots(template);
      }

      // Measure performance over 5 batches to detect degradation (reduced from 10)
      for (let batch = 0; batch < 5; batch++) {
        const batchStart = performance.now();

        for (let i = 0; i < 100; i++) {
          slotGenerator.generateBlueprintSlots(template);
        }

        const batchTime = performance.now() - batchStart;
        times.push(batchTime);
      }

      const firstBatchTime = times[0];
      const lastBatchTime = times[times.length - 1];
      const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
      const degradationRatio = lastBatchTime / firstBatchTime;

      console.log(
        `Stress test batch times: [${times.map((t) => t.toFixed(2)).join(', ')}]ms`
      );
      console.log(
        `First batch: ${firstBatchTime.toFixed(2)}ms, Last batch: ${lastBatchTime.toFixed(2)}ms`
      );
      console.log(`Average batch time: ${avgTime.toFixed(2)}ms`);
      console.log(`Degradation ratio: ${degradationRatio.toFixed(2)}x`);

      // Performance should not degrade significantly (last batch < 5x first batch)
      expect(degradationRatio).toBeLessThan(5);

      // All batches should complete within reasonable time (100 operations in < 50ms)
      times.forEach((time) => {
        expect(time).toBeLessThan(50);
      });
    });

    it('should maintain consistent performance across multiple generations', () => {
      const templates = [
        createStructureTemplate(1, 1), // 1 slot
        createStructureTemplate(1, 10), // 10 slots
        createStructureTemplate(1, 50), // 50 slots
        createAppendageTemplate(20), // 20 appendages
      ];

      const iterations = 100; // Keep at 100, already minimal

      for (const template of templates) {
        // Warmup
        for (let i = 0; i < 50; i++) {
          // Reduced from 100
          slotGenerator.generateBlueprintSlots(template);
        }

        const start = performance.now();
        for (let i = 0; i < iterations; i++) {
          slotGenerator.generateBlueprintSlots(template);
        }
        const totalTime = performance.now() - start;

        // All template variations should maintain good performance
        expect(totalTime).toBeLessThan(100);
      }
    });
  });

  describe('Slot Key Validation', () => {
    it('should generate slot keys that match expected socket ID patterns', () => {
      const template = createStructureTemplate(1, 5);

      const slots = slotGenerator.generateBlueprintSlots(template);
      const slotKeys = Object.keys(slots);

      // Should generate 5 slots
      expect(slotKeys.length).toBe(5);

      // Each slot key should match the socket ID pattern: socket_0_1, socket_0_2, etc.
      for (let i = 1; i <= 5; i++) {
        const expectedKey = `socket_0_${i}`;
        expect(slotKeys).toContain(expectedKey);
      }
    });

    it('should generate unique slot keys for multiple limb sets', () => {
      const template = createStructureTemplate(3, 5); // 3 limb sets, 5 slots each

      const slots = slotGenerator.generateBlueprintSlots(template);
      const slotKeys = Object.keys(slots);

      // Should generate 15 unique slots (3 sets × 5 slots)
      expect(slotKeys.length).toBe(15);

      // All keys should be unique (no duplicates)
      const uniqueKeys = new Set(slotKeys);
      expect(uniqueKeys.size).toBe(15);
    });
  });

  describe('Performance Summary', () => {
    it('should demonstrate that slot generation is performant across all scales', () => {
      const testCases = [
        {
          name: '1 slot',
          template: createStructureTemplate(1, 1),
          target: 0.01,
        },
        {
          name: '10 slots',
          template: createStructureTemplate(1, 10),
          target: 0.1,
        },
        {
          name: '20 slots',
          template: createStructureTemplate(1, 20),
          target: 0.2,
        },
        {
          name: '50 slots',
          template: createStructureTemplate(1, 50),
          target: 0.5,
        },
        {
          name: '100 slots',
          template: createStructureTemplate(1, 100),
          target: 1,
        },
      ];

      console.log('\n=== Slot Generation Performance Summary ===');

      const results = [];

      for (const testCase of testCases) {
        const iterations = 500; // Reduced from 1000 for summary test

        // Warmup
        for (let i = 0; i < 50; i++) {
          // Reduced from 100
          slotGenerator.generateBlueprintSlots(testCase.template);
        }

        const start = performance.now();
        for (let i = 0; i < iterations; i++) {
          slotGenerator.generateBlueprintSlots(testCase.template);
        }
        const totalTime = performance.now() - start;
        const avgTime = totalTime / iterations;

        results.push({
          name: testCase.name,
          avgTime,
          target: testCase.target,
          passed: avgTime < testCase.target,
        });

        console.log(
          `${testCase.name}: ${avgTime.toFixed(4)}ms avg (target: <${testCase.target}ms) - ${avgTime < testCase.target ? '✓ PASS' : '✗ FAIL'}`
        );
      }

      // All test cases should pass their performance targets
      results.forEach((result) => {
        expect(result.passed).toBe(true);
      });

      console.log('===========================================\n');
    });
  });
});
