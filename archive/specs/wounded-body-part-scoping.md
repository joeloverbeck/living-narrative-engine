# Wounded Body Part Scoping

## Context
- `data/mods/violence/actions/peck_target.action.json` uses `violence:actor_beak_body_parts`, which is defined as `actor.body_parts[][ {and: [...]} ]` in `data/mods/violence/scopes/actor_beak_body_parts.scope`. The scope DSL resolves `actor.body_parts` via `BodyPartStepResolver` + `ArrayIterationResolver`, which calls `BodyGraphService.getAllParts` over the actor’s `anatomy:body.body.root` and parts map.
- Anatomy graphs are generated by `AnatomyGenerationService` orchestrating `BodyBlueprintFactory` (via `AnatomyOrchestrator` / `AnatomyGenerationWorkflow`) to create part entities with `anatomy:part` + `anatomy:joint`, then stores `body.root` + `body.parts` on `anatomy:body`. `BodyGraphService` builds an adjacency cache from those joints and offers `getAllParts`, `findPartsByType`, etc.
- The anatomy visualizer (`anatomy-visualizer.html` + `src/anatomy-visualizer.js` + `src/domUI/anatomy-renderer/VisualizationComposer.js`) boots the minimal container, fetches an entity’s `anatomy:body.body`, and BFS-renders the graph (name/type/descriptor tooltips) while pulling descriptions from `AnatomyDescriptionService`.
- Existing operators:
  - `hasPartSubTypeContainingOperator` → substring match on cached `partType` (subType) after `getAllParts`.
  - `hasPartWithComponentValueOperator` → equality check on a component property path on any part.
  - `hasPartOfTypeWithComponentValueOperator` → filters by partType then equality on a component property path.
  - None of these support relational comparisons (e.g., `currentHealth < maxHealth`) or component presence-only checks.

## Findings
- Scope filters already receive full part entities in the JSON Logic context (`entity.components...`), so we can express “wounded” with built-in operators today:  
  `{"and":[{"var":"entity.components.anatomy:part_health"},{"<":[{"var":"entity.components.anatomy:part_health.currentHealth"},{"var":"entity.components.anatomy:part_health.maxHealth"}]}]}`  
  and bleeding/status with `{"!!":[{"var":"entity.components.anatomy:bleeding"}]}` or specific fields under that component.
- If we need boolean conditions outside a scope filter (action prerequisites, conditions), the current operators only offer equality; there is no `hasWoundedPart`/`hasPartWithComponent` operator that supports inequality or presence checks.

## Proposal
1. **Scope-level filters (works now)**  
   - Add medical scopes that project wounded or status-affected parts using the existing DSL, e.g. `actor.body_parts[][ {and:[{"var":"entity.components.anatomy:part_health"},{"<":[{"var":"entity.components.anatomy:part_health.currentHealth"},{"var":"entity.components.anatomy:part_health.maxHealth"}]}]} ]` and a variant that also requires `anatomy:bleeding` to exist. Reuse BodyGraphService caching path.
2. **Optional operator (if we want reusable predicates for conditions)**  
   - Introduce `hasWoundedPart` (or a generic `hasPartWithComponentComparison`) that scans `getAllParts` and returns true when `part_health.currentHealth < maxHealth` or when `state !== 'healthy'`.  
   - Introduce `hasPartWithStatusEffect(componentId, propertyPath?, predicate?)` for presence/field matches (e.g., `anatomy:bleeding.severity === 'severe'`). Both would extend `BaseBodyPartOperator`, reuse cache, and accept comparison predicates rather than strict equality.
3. **Interplay**  
   - Scopes should prefer JSON-Logic filters for selection (returns the actual part IDs), while operators give precondition-style booleans for action availability. Keep both paths consistent by centralizing the wound predicate in a helper to avoid drift.

## Testing Requirements
- Add at least one e2e test under `tests/e2e/` (model after APPLY_DAMAGE suites like `tests/e2e/actions/swingAtTargetFullFlow.e2e.test.js` or `regenerateDescriptionAfterDamage.e2e.test.js`) that:
  - Builds/generates an anatomy, applies damage to a specific part to drop `currentHealth` below `maxHealth`, and optionally adds `anatomy:bleeding`.
  - Resolves the new medical scope (or operator + scope combo) and asserts only genuinely wounded parts from the anatomy graph are returned.
  - Verifies health/state mutations still flow through the existing APPLY_DAMAGE pipeline and descriptions stay consistent.
